// ==UserScript==
// @name     Artist's Dashboard Dev
// @namespace https://github.com/siefkenj/react-userscripts
// @version  1.1
// @description A sample userscript built using react
// @include https://*.popmundo.com/World/Popmundo.aspx/Artist/*
// @grant    none
// ==/UserScript==


var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function() {
  "use strict";
  function _mergeNamespaces(n2, m2) {
    for (var i = 0; i < m2.length; i++) {
      const e3 = m2[i];
      if (typeof e3 !== "string" && !Array.isArray(e3)) {
        for (const k2 in e3) {
          if (k2 !== "default" && !(k2 in n2)) {
            const d2 = Object.getOwnPropertyDescriptor(e3, k2);
            if (d2) {
              Object.defineProperty(n2, k2, d2.get ? d2 : {
                enumerable: true,
                get: () => e3[k2]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l$3 = Symbol.for("react.element"), n$4 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
  function A$2(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z$2 && a[z$2] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B$1 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C$1 = Object.assign, D$1 = {};
  function E$1(a, b2, e3) {
    this.props = a;
    this.context = b2;
    this.refs = D$1;
    this.updater = e3 || B$1;
  }
  E$1.prototype.isReactComponent = {};
  E$1.prototype.setState = function(a, b2) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b2, "setState");
  };
  E$1.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E$1.prototype;
  function G$1(a, b2, e3) {
    this.props = a;
    this.context = b2;
    this.refs = D$1;
    this.updater = e3 || B$1;
  }
  var H$1 = G$1.prototype = new F();
  H$1.constructor = G$1;
  C$1(H$1, E$1.prototype);
  H$1.isPureReactComponent = true;
  var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
  function M$1(a, b2, e3) {
    var d2, c6 = {}, k2 = null, h2 = null;
    if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c6[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c6.children = e3;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c6.children = f2;
    }
    if (a && a.defaultProps) for (d2 in g2 = a.defaultProps, g2) void 0 === c6[d2] && (c6[d2] = g2[d2]);
    return { $$typeof: l$3, type: a, key: k2, ref: h2, props: c6, _owner: K$1.current };
  }
  function N$1(a, b2) {
    return { $$typeof: l$3, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O$1(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l$3;
  }
  function escape(a) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b2[a2];
    });
  }
  var P$1 = /\/+/g;
  function Q$1(a, b2) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
  }
  function R$1(a, b2, e3, d2, c6) {
    var k2 = typeof a;
    if ("undefined" === k2 || "boolean" === k2) a = null;
    var h2 = false;
    if (null === a) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$3:
          case n$4:
            h2 = true;
        }
    }
    if (h2) return h2 = a, c6 = c6(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c6) ? (e3 = "", null != a && (e3 = a.replace(P$1, "$&/") + "/"), R$1(c6, b2, e3, "", function(a2) {
      return a2;
    })) : null != c6 && (O$1(c6) && (c6 = N$1(c6, e3 + (!c6.key || h2 && h2.key === c6.key ? "" : ("" + c6.key).replace(P$1, "$&/") + "/") + a)), b2.push(c6)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I$1(a)) for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e3, f2, c6);
    }
    else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e3, f2, c6);
    else if ("object" === k2) throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S$1(a, b2, e3) {
    if (null == a) return a;
    var d2 = [], c6 = 0;
    R$1(a, d2, "", "", function(a2) {
      return b2.call(e3, a2, c6++);
    });
    return d2;
  }
  function T$1(a) {
    if (-1 === a._status) {
      var b2 = a._result;
      b2 = b2();
      b2.then(function(b3) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b3;
      }, function(b3) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b3;
      });
      -1 === a._status && (a._status = 0, a._result = b2);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
  function X$1() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S$1, forEach: function(a, b2, e3) {
    S$1(a, function() {
      b2.apply(this, arguments);
    }, e3);
  }, count: function(a) {
    var b2 = 0;
    S$1(a, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a) {
    return S$1(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E$1;
  react_production_min.Fragment = p$5;
  react_production_min.Profiler = r$3;
  react_production_min.PureComponent = G$1;
  react_production_min.StrictMode = q$4;
  react_production_min.Suspense = w$1;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
  react_production_min.act = X$1;
  react_production_min.cloneElement = function(a, b2, e3) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d2 = C$1({}, a.props), c6 = a.key, k2 = a.ref, h2 = a._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
      void 0 !== b2.key && (c6 = "" + b2.key);
      if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
      for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e3;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l$3, type: a.type, key: c6, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u$2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t$3, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M$1;
  react_production_min.createFactory = function(a) {
    var b2 = M$1.bind(null, a);
    b2.type = a;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v$4, render: a };
  };
  react_production_min.isValidElement = O$1;
  react_production_min.lazy = function(a) {
    return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
  };
  react_production_min.memo = function(a, b2) {
    return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a) {
    var b2 = V$1.transition;
    V$1.transition = {};
    try {
      a();
    } finally {
      V$1.transition = b2;
    }
  };
  react_production_min.unstable_act = X$1;
  react_production_min.useCallback = function(a, b2) {
    return U$1.current.useCallback(a, b2);
  };
  react_production_min.useContext = function(a) {
    return U$1.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U$1.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b2) {
    return U$1.current.useEffect(a, b2);
  };
  react_production_min.useId = function() {
    return U$1.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b2, e3) {
    return U$1.current.useImperativeHandle(a, b2, e3);
  };
  react_production_min.useInsertionEffect = function(a, b2) {
    return U$1.current.useInsertionEffect(a, b2);
  };
  react_production_min.useLayoutEffect = function(a, b2) {
    return U$1.current.useLayoutEffect(a, b2);
  };
  react_production_min.useMemo = function(a, b2) {
    return U$1.current.useMemo(a, b2);
  };
  react_production_min.useReducer = function(a, b2, e3) {
    return U$1.current.useReducer(a, b2, e3);
  };
  react_production_min.useRef = function(a) {
    return U$1.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U$1.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b2, e3) {
    return U$1.current.useSyncExternalStore(a, b2, e3);
  };
  react_production_min.useTransition = function() {
    return U$1.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  {
    react.exports = react_production_min;
  }
  var reactExports = react.exports;
  const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  const ReactOriginal = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: React$1
  }, [reactExports]);
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function(exports) {
    function f2(a, b2) {
      var c6 = a.length;
      a.push(b2);
      a: for (; 0 < c6; ) {
        var d2 = c6 - 1 >>> 1, e3 = a[d2];
        if (0 < g2(e3, b2)) a[d2] = b2, a[c6] = e3, c6 = d2;
        else break a;
      }
    }
    function h2(a) {
      return 0 === a.length ? null : a[0];
    }
    function k2(a) {
      if (0 === a.length) return null;
      var b2 = a[0], c6 = a.pop();
      if (c6 !== b2) {
        a[0] = c6;
        a: for (var d2 = 0, e3 = a.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c6)) n2 < e3 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c6, d2 = n2) : (a[d2] = C2, a[m2] = c6, d2 = m2);
          else if (n2 < e3 && 0 > g2(x2, c6)) a[d2] = x2, a[n2] = c6, d2 = n2;
          else break a;
        }
      }
      return b2;
    }
    function g2(a, b2) {
      var c6 = a.sortIndex - b2.sortIndex;
      return 0 !== c6 ? c6 : a.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a) {
      B2 = false;
      G2(a);
      if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
    }
    function J2(a, b2) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c6 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e3 = d2(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c6, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a = exports.unstable_now();
        Q2 = a;
        var b2 = true;
        try {
          b2 = O2(true, a);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F2) S2 = function() {
      F2(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a) {
      O2 = a;
      N2 || (N2 = true, S2());
    }
    function K2(a, b2) {
      L2 = D2(function() {
        a(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c6 = y2;
      y2 = b2;
      try {
        return a();
      } finally {
        y2 = c6;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c6 = y2;
      y2 = a;
      try {
        return b2();
      } finally {
        y2 = c6;
      }
    };
    exports.unstable_scheduleCallback = function(a, b2, c6) {
      var d2 = exports.unstable_now();
      "object" === typeof c6 && null !== c6 ? (c6 = c6.delay, c6 = "number" === typeof c6 && 0 < c6 ? d2 + c6 : d2) : c6 = d2;
      switch (a) {
        case 1:
          var e3 = -1;
          break;
        case 2:
          e3 = 250;
          break;
        case 5:
          e3 = 1073741823;
          break;
        case 4:
          e3 = 1e4;
          break;
        default:
          e3 = 5e3;
      }
      e3 = c6 + e3;
      a = { id: u2++, callback: b2, priorityLevel: a, startTime: c6, expirationTime: e3, sortIndex: -1 };
      c6 > d2 ? (a.sortIndex = c6, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c6 - d2))) : (a.sortIndex = e3, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
      return a;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a) {
      var b2 = y2;
      return function() {
        var c6 = y2;
        y2 = b2;
        try {
          return a.apply(this, arguments);
        } finally {
          y2 = c6;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var aa = reactExports, ca = schedulerExports;
  function p$4(a) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c6 = 1; c6 < arguments.length; c6++) b2 += "&args[]=" + encodeURIComponent(arguments[c6]);
    return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b2) {
    ha(a, b2);
    ha(a + "Capture", b2);
  }
  function ha(a, b2) {
    ea[a] = b2;
    for (a = 0; a < b2.length; a++) da.add(b2[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b2, c6, d2) {
    if (null !== c6 && 0 === c6.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c6) return !c6.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b2, c6, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c6, d2)) return true;
    if (d2) return false;
    if (null !== c6) switch (c6.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v$3(a, b2, c6, d2, e3, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e3;
    this.mustUseProperty = c6;
    this.propertyName = a;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z$1 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z$1[a] = new v$3(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b2 = a[0];
    z$1[b2] = new v$3(b2, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z$1[a] = new v$3(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z$1[a] = new v$3(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z$1[a] = new v$3(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z$1[a] = new v$3(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z$1[a] = new v$3(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z$1[a] = new v$3(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z$1[a] = new v$3(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b2 = a.replace(
      ra,
      sa
    );
    z$1[b2] = new v$3(b2, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b2 = a.replace(ra, sa);
    z$1[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b2 = a.replace(ra, sa);
    z$1[b2] = new v$3(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z$1[a] = new v$3(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z$1.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z$1[a] = new v$3(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b2, c6, d2) {
    var e3 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
    if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c6, e3, d2) && (c6 = null), d2 || null === e3 ? oa(b2) && (null === c6 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c6)) : e3.mustUseProperty ? a[e3.propertyName] = null === c6 ? 3 === e3.type ? false : "" : c6 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c6 ? a.removeAttribute(b2) : (e3 = e3.type, c6 = 3 === e3 || 4 === e3 && true === c6 ? "" : "" + c6, d2 ? a.setAttributeNS(d2, b2, c6) : a.setAttribute(b2, c6)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A$1 = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c6) {
      var b2 = c6.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b2) {
    if (!a || Na) return "";
    Na = true;
    var c6 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2]) {
                var k2 = "\n" + e3[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c6;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c6) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b2 = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b2 = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a) {
    var b2 = Ta(a) ? "checked" : "value", c6 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
    if (!a.hasOwnProperty(b2) && "undefined" !== typeof c6 && "function" === typeof c6.get && "function" === typeof c6.set) {
      var e3 = c6.get, f2 = c6.set;
      Object.defineProperty(a, b2, { configurable: true, get: function() {
        return e3.call(this);
      }, set: function(a2) {
        d2 = "" + a2;
        f2.call(this, a2);
      } });
      Object.defineProperty(a, b2, { enumerable: c6.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a2) {
        d2 = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b2];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b2 = a._valueTracker;
    if (!b2) return true;
    var c6 = b2.getValue();
    var d2 = "";
    a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d2;
    return a !== c6 ? (b2.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b2) {
      return a.body;
    }
  }
  function Ya(a, b2) {
    var c6 = b2.checked;
    return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c6 ? c6 : a._wrapperState.initialChecked });
  }
  function Za(a, b2) {
    var c6 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c6 = Sa(null != b2.value ? b2.value : c6);
    a._wrapperState = { initialChecked: d2, initialValue: c6, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a, b2) {
    b2 = b2.checked;
    null != b2 && ta(a, "checked", b2, false);
  }
  function bb(a, b2) {
    ab(a, b2);
    var c6 = Sa(b2.value), d2 = b2.type;
    if (null != c6) if ("number" === d2) {
      if (0 === c6 && "" === a.value || a.value != c6) a.value = "" + c6;
    } else a.value !== "" + c6 && (a.value = "" + c6);
    else if ("submit" === d2 || "reset" === d2) {
      a.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a, b2.type, c6) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
  }
  function db(a, b2, c6) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a._wrapperState.initialValue;
      c6 || b2 === a.value || (a.value = b2);
      a.defaultValue = b2;
    }
    c6 = a.name;
    "" !== c6 && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c6 && (a.name = c6);
  }
  function cb(a, b2, c6) {
    if ("number" !== b2 || Xa(a.ownerDocument) !== a) null == c6 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c6 && (a.defaultValue = "" + c6);
  }
  var eb = Array.isArray;
  function fb(a, b2, c6, d2) {
    a = a.options;
    if (b2) {
      b2 = {};
      for (var e3 = 0; e3 < c6.length; e3++) b2["$" + c6[e3]] = true;
      for (c6 = 0; c6 < a.length; c6++) e3 = b2.hasOwnProperty("$" + a[c6].value), a[c6].selected !== e3 && (a[c6].selected = e3), e3 && d2 && (a[c6].defaultSelected = true);
    } else {
      c6 = "" + Sa(c6);
      b2 = null;
      for (e3 = 0; e3 < a.length; e3++) {
        if (a[e3].value === c6) {
          a[e3].selected = true;
          d2 && (a[e3].defaultSelected = true);
          return;
        }
        null !== b2 || a[e3].disabled || (b2 = a[e3]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p$4(91));
    return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b2) {
    var c6 = b2.value;
    if (null == c6) {
      c6 = b2.children;
      b2 = b2.defaultValue;
      if (null != c6) {
        if (null != b2) throw Error(p$4(92));
        if (eb(c6)) {
          if (1 < c6.length) throw Error(p$4(93));
          c6 = c6[0];
        }
        b2 = c6;
      }
      null == b2 && (b2 = "");
      c6 = b2;
    }
    a._wrapperState = { initialValue: Sa(c6) };
  }
  function ib(a, b2) {
    var c6 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c6 && (c6 = "" + c6, c6 !== a.value && (a.value = c6), null == b2.defaultValue && a.defaultValue !== c6 && (a.defaultValue = c6));
    null != d2 && (a.defaultValue = "" + d2);
  }
  function jb(a) {
    var b2 = a.textContent;
    b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b2) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c6, d2, e3) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b2, c6, d2, e3);
      });
    } : a;
  }(function(a, b2) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b2.firstChild; ) a.appendChild(b2.firstChild);
    }
  });
  function ob(a, b2) {
    if (b2) {
      var c6 = a.firstChild;
      if (c6 && c6 === a.lastChild && 3 === c6.nodeType) {
        c6.nodeValue = b2;
        return;
      }
    }
    a.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b2) {
      b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b2] = pb[a];
    });
  });
  function rb(a, b2, c6) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c6 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a, b2) {
    a = a.style;
    for (var c6 in b2) if (b2.hasOwnProperty(c6)) {
      var d2 = 0 === c6.indexOf("--"), e3 = rb(c6, b2[c6], d2);
      "float" === c6 && (c6 = "cssFloat");
      d2 ? a.setProperty(c6, e3) : a[c6] = e3;
    }
  }
  var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b2) {
    if (b2) {
      if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$4(137, a));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p$4(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$4(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p$4(62));
    }
  }
  function vb(a, b2) {
    if (-1 === a.indexOf("-")) return "string" === typeof b2.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p$4(280));
      var b2 = a.stateNode;
      b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a);
      if (b2) for (a = 0; a < b2.length; a++) Bb(b2[a]);
    }
  }
  function Gb(a, b2) {
    return a(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b2, c6) {
    if (Ib) return a(b2, c6);
    Ib = true;
    try {
      return Gb(a, b2, c6);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b2) {
    var c6 = a.stateNode;
    if (null === c6) return null;
    var d2 = Db(c6);
    if (null === d2) return null;
    c6 = d2[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c6 && "function" !== typeof c6) throw Error(p$4(231, b2, typeof c6));
    return c6;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b2, c6, d2, e3, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c6, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b2, c6, d2, e3, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b2, c6, d2, e3, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p$4(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a) {
    var b2 = a, c6 = a;
    if (a.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a = b2;
      do
        b2 = a, 0 !== (b2.flags & 4098) && (c6 = b2.return), a = b2.return;
      while (a);
    }
    return 3 === b2.tag ? c6 : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b2 = a.memoizedState;
      null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p$4(188));
  }
  function Yb(a) {
    var b2 = a.alternate;
    if (!b2) {
      b2 = Vb(a);
      if (null === b2) throw Error(p$4(188));
      return b2 !== a ? null : a;
    }
    for (var c6 = a, d2 = b2; ; ) {
      var e3 = c6.return;
      if (null === e3) break;
      var f2 = e3.alternate;
      if (null === f2) {
        d2 = e3.return;
        if (null !== d2) {
          c6 = d2;
          continue;
        }
        break;
      }
      if (e3.child === f2.child) {
        for (f2 = e3.child; f2; ) {
          if (f2 === c6) return Xb(e3), a;
          if (f2 === d2) return Xb(e3), b2;
          f2 = f2.sibling;
        }
        throw Error(p$4(188));
      }
      if (c6.return !== d2.return) c6 = e3, d2 = f2;
      else {
        for (var g2 = false, h2 = e3.child; h2; ) {
          if (h2 === c6) {
            g2 = true;
            c6 = e3;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e3;
            c6 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c6) {
              g2 = true;
              c6 = f2;
              d2 = e3;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c6 = e3;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p$4(189));
        }
      }
      if (c6.alternate !== d2) throw Error(p$4(190));
    }
    if (3 !== c6.tag) throw Error(p$4(188));
    return c6.stateNode.current === c6 ? a : b2;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b2 = $b(a);
      if (null !== b2) return b2;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b2) {
    var c6 = a.pendingLanes;
    if (0 === c6) return 0;
    var d2 = 0, e3 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c6 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e3;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else g2 = c6 & ~e3, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2) return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240))) return b2;
    0 !== (d2 & 4) && (d2 |= c6 & 16);
    b2 = a.entangledLanes;
    if (0 !== b2) for (a = a.entanglements, b2 &= d2; 0 < b2; ) c6 = 31 - oc(b2), e3 = 1 << c6, d2 |= a[c6], b2 &= ~e3;
    return d2;
  }
  function vc(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b2) {
    for (var c6 = a.suspendedLanes, d2 = a.pingedLanes, e3 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e3[g2];
      if (-1 === k2) {
        if (0 === (h2 & c6) || 0 !== (h2 & d2)) e3[g2] = vc(h2, b2);
      } else k2 <= b2 && (a.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b2 = [], c6 = 0; 31 > c6; c6++) b2.push(a);
    return b2;
  }
  function Ac(a, b2, c6) {
    a.pendingLanes |= b2;
    536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b2 = 31 - oc(b2);
    a[b2] = c6;
  }
  function Bc(a, b2) {
    var c6 = a.pendingLanes & ~b2;
    a.pendingLanes = b2;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b2;
    a.mutableReadLanes &= b2;
    a.entangledLanes &= b2;
    b2 = a.entanglements;
    var d2 = a.eventTimes;
    for (a = a.expirationTimes; 0 < c6; ) {
      var e3 = 31 - oc(c6), f2 = 1 << e3;
      b2[e3] = 0;
      d2[e3] = -1;
      a[e3] = -1;
      c6 &= ~f2;
    }
  }
  function Cc(a, b2) {
    var c6 = a.entangledLanes |= b2;
    for (a = a.entanglements; c6; ) {
      var d2 = 31 - oc(c6), e3 = 1 << d2;
      e3 & b2 | a[d2] & b2 && (a[d2] |= b2);
      c6 &= ~e3;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b2) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a, b2, c6, d2, e3, f2) {
    if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b2, domEventName: c6, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
    a.eventSystemFlags |= d2;
    b2 = a.targetContainers;
    null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
    return a;
  }
  function Uc(a, b2, c6, d2, e3) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a, b2, c6, d2, e3), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b2, c6, d2, e3), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b2, c6, d2, e3), true;
      case "pointerover":
        var f2 = e3.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c6, d2, e3));
        return true;
      case "gotpointercapture":
        return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c6, d2, e3)), true;
    }
    return false;
  }
  function Vc(a) {
    var b2 = Wc(a.target);
    if (null !== b2) {
      var c6 = Vb(b2);
      if (null !== c6) {
        if (b2 = c6.tag, 13 === b2) {
          if (b2 = Wb(c6), null !== b2) {
            a.blockedOn = b2;
            Ic(a.priority, function() {
              Gc(c6);
            });
            return;
          }
        } else if (3 === b2 && c6.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c6.tag ? c6.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b2 = a.targetContainers; 0 < b2.length; ) {
      var c6 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
      if (null === c6) {
        c6 = a.nativeEvent;
        var d2 = new c6.constructor(c6.type, c6);
        wb = d2;
        c6.target.dispatchEvent(d2);
        wb = null;
      } else return b2 = Cb(c6), null !== b2 && Fc(b2), a.blockedOn = c6, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a, b2, c6) {
    Xc(a) && c6.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b2) {
    a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b2(b3) {
      return ad(b3, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c6 = 1; c6 < Kc.length; c6++) {
        var d2 = Kc[c6];
        d2.blockedOn === a && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c6 = 0; c6 < Qc.length; c6++) d2 = Qc[c6], d2.blockedOn === a && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c6 = Qc[0], null === c6.blockedOn); ) Vc(c6), null === c6.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b2, c6, d2) {
    var e3 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b2, c6, d2);
    } finally {
      C = e3, cd.transition = f2;
    }
  }
  function gd(a, b2, c6, d2) {
    var e3 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b2, c6, d2);
    } finally {
      C = e3, cd.transition = f2;
    }
  }
  function fd(a, b2, c6, d2) {
    if (dd) {
      var e3 = Yc(a, b2, c6, d2);
      if (null === e3) hd(a, b2, d2, id, c6), Sc(a, d2);
      else if (Uc(e3, a, b2, c6, d2)) d2.stopPropagation();
      else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e3; ) {
          var f2 = Cb(e3);
          null !== f2 && Ec(f2);
          f2 = Yc(a, b2, c6, d2);
          null === f2 && hd(a, b2, d2, id, c6);
          if (f2 === e3) break;
          e3 = f2;
        }
        null !== e3 && d2.stopPropagation();
      } else hd(a, b2, d2, null, c6);
    }
  }
  var id = null;
  function Yc(a, b2, c6, d2) {
    id = null;
    a = xb(d2);
    a = Wc(a);
    if (null !== a) if (b2 = Vb(a), null === b2) a = null;
    else if (c6 = b2.tag, 13 === c6) {
      a = Wb(b2);
      if (null !== a) return a;
      a = null;
    } else if (3 === c6) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else b2 !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b2 = ld, c6 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
    for (a = 0; a < c6 && b2[a] === e3[a]; a++) ;
    var g2 = c6 - a;
    for (d2 = 1; d2 <= g2 && b2[c6 - d2] === e3[f2 - d2]; d2++) ;
    return md = e3.slice(a, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a) {
    var b2 = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b2(b3, d2, e3, f2, g2) {
      this._reactName = b3;
      this._targetInst = e3;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c6 in a) a.hasOwnProperty(c6) && (b3 = a[c6], this[c6] = b3 ? b3(f2) : f2[c6]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A$1(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A$1({}, ud, { key: function(a) {
    if (a.key) {
      var b2 = Md[a.key] || a.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b2) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b2) {
    switch (a) {
      case "compositionend":
        return he(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b2.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b2) {
    if (ie) return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
  }
  function ne(a, b2, c6, d2) {
    Eb(d2);
    b2 = oe(b2, "onChange");
    0 < b2.length && (c6 = new td("onChange", "change", null, c6, d2), a.push({ event: c6, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re$1(a) {
    se(a, 0);
  }
  function te(a) {
    var b2 = ue(a);
    if (Wa(b2)) return a;
  }
  function ve(a, b2) {
    if ("change" === a) return b2;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a, xb(a));
      Jb(re$1, b2);
    }
  }
  function Ce(a, b2, c6) {
    "focusin" === a ? (Ae(), pe = b2, qe = c6, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b2) {
    if ("click" === a) return te(b2);
  }
  function Fe(a, b2) {
    if ("input" === a || "change" === a) return te(b2);
  }
  function Ge(a, b2) {
    return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b2) {
    if (He(a, b2)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2) return false;
    var c6 = Object.keys(a), d2 = Object.keys(b2);
    if (c6.length !== d2.length) return false;
    for (d2 = 0; d2 < c6.length; d2++) {
      var e3 = c6[d2];
      if (!ja.call(b2, e3) || !He(a[e3], b2[e3])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b2) {
    var c6 = Je(a);
    a = 0;
    for (var d2; c6; ) {
      if (3 === c6.nodeType) {
        d2 = a + c6.textContent.length;
        if (a <= b2 && d2 >= b2) return { node: c6, offset: b2 - a };
        a = d2;
      }
      a: {
        for (; c6; ) {
          if (c6.nextSibling) {
            c6 = c6.nextSibling;
            break a;
          }
          c6 = c6.parentNode;
        }
        c6 = void 0;
      }
      c6 = Je(c6);
    }
  }
  function Le(a, b2) {
    return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
      try {
        var c6 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c6 = false;
      }
      if (c6) a = b2.contentWindow;
      else break;
      b2 = Xa(a.document);
    }
    return b2;
  }
  function Ne(a) {
    var b2 = a && a.nodeName && a.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b2 = Me(), c6 = a.focusedElem, d2 = a.selectionRange;
    if (b2 !== c6 && c6 && c6.ownerDocument && Le(c6.ownerDocument.documentElement, c6)) {
      if (null !== d2 && Ne(c6)) {
        if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c6) c6.selectionStart = b2, c6.selectionEnd = Math.min(a, c6.value.length);
        else if (a = (b2 = c6.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e3 = c6.textContent.length, f2 = Math.min(d2.start, e3);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
          !a.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
          e3 = Ke(c6, f2);
          var g2 = Ke(
            c6,
            d2
          );
          e3 && g2 && (1 !== a.rangeCount || a.anchorNode !== e3.node || a.anchorOffset !== e3.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
        }
      }
      b2 = [];
      for (a = c6; a = a.parentNode; ) 1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c6.focus && c6.focus();
      for (c6 = 0; c6 < b2.length; c6++) a = b2[c6], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b2, c6) {
    var d2 = c6.window === c6 ? c6.document : 9 === c6.nodeType ? c6 : c6.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c6), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve(a, b2) {
    var c6 = {};
    c6[a.toLowerCase()] = b2.toLowerCase();
    c6["Webkit" + a] = "webkit" + b2;
    c6["Moz" + a] = "moz" + b2;
    return c6;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b2 = We[a], c6;
    for (c6 in b2) if (b2.hasOwnProperty(c6) && c6 in Ye) return Xe[a] = b2[c6];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b2) {
    df.set(a, b2);
    fa(b2, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b2, c6) {
    var d2 = a.type || "unknown-event";
    a.currentTarget = c6;
    Ub(d2, b2, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c6 = 0; c6 < a.length; c6++) {
      var d2 = a[c6], e3 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped()) break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped()) break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b2) {
    var c6 = b2[of];
    void 0 === c6 && (c6 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a + "__bubble";
    c6.has(d2) || (pf(b2, a, 2, false), c6.add(d2));
  }
  function qf(a, b2, c6) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c6, a, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
      });
      var b2 = 9 === a.nodeType ? a : a.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a, b2, c6, d2) {
    switch (jd(b2)) {
      case 1:
        var e3 = ed;
        break;
      case 4:
        e3 = gd;
        break;
      default:
        e3 = fd;
    }
    c6 = e3.bind(null, b2, c6, a);
    e3 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
    d2 ? void 0 !== e3 ? a.addEventListener(b2, c6, { capture: true, passive: e3 }) : a.addEventListener(b2, c6, true) : void 0 !== e3 ? a.addEventListener(b2, c6, { passive: e3 }) : a.addEventListener(b2, c6, false);
  }
  function hd(a, b2, c6, d2, e3) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e4 = xb(c6), g3 = [];
      a: {
        var h3 = df.get(a);
        if (void 0 !== h3) {
          var k3 = td, n2 = a;
          switch (a) {
            case "keypress":
              if (0 === od(c6)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c6.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c6, e4), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a || "pointerover" === a;
          k3 = "mouseout" === a || "pointerout" === a;
          if (h3 && c6 !== wb && (n2 = c6.relatedTarget || c6.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h3) {
            h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c6.relatedTarget || c6.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue(k3);
              u2 = null == n2 ? h3 : ue(n2);
              h3 = new t2(F2, w2 + "leave", k3, c6, e4);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c6, e4), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a, d3))) {
            ne(g3, na, c6, e4);
            break a;
          }
          xa && xa(a, h3, d3);
          "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c6, e4);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g3, c6, e4);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c6) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c6.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c6.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c6, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c6), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c6) : ke(a, c6)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c6, e4), g3.push({ event: e4, listeners: d3 }), e4.data = $a);
      }
      se(g3, b2);
    });
  }
  function tf(a, b2, c6) {
    return { instance: a, listener: b2, currentTarget: c6 };
  }
  function oe(a, b2) {
    for (var c6 = b2 + "Capture", d2 = []; null !== a; ) {
      var e3 = a, f2 = e3.stateNode;
      5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a, c6), null != f2 && d2.unshift(tf(a, f2, e3)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e3)));
      a = a.return;
    }
    return d2;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b2, c6, d2, e3) {
    for (var f2 = b2._reactName, g2 = []; null !== c6 && c6 !== d2; ) {
      var h2 = c6, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c6, f2), null != k2 && g2.unshift(tf(c6, k2, h2))) : e3 || (k2 = Kb(c6, f2), null != k2 && g2.push(tf(c6, k2, h2))));
      c6 = c6.return;
    }
    0 !== g2.length && a.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b2, c6) {
    b2 = zf(b2);
    if (zf(a) !== b2 && c6) throw Error(p$4(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b2) {
    return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b2) {
    var c6 = b2, d2 = 0;
    do {
      var e3 = c6.nextSibling;
      a.removeChild(c6);
      if (e3 && 8 === e3.nodeType) if (c6 = e3.data, "/$" === c6) {
        if (0 === d2) {
          a.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else "$" !== c6 && "$?" !== c6 && "$!" !== c6 || d2++;
      c6 = e3;
    } while (c6);
    bd(b2);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b2 = a.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b2 = 0; a; ) {
      if (8 === a.nodeType) {
        var c6 = a.data;
        if ("$" === c6 || "$!" === c6 || "$?" === c6) {
          if (0 === b2) return a;
          b2--;
        } else "/$" === c6 && b2++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b2 = a[Of];
    if (b2) return b2;
    for (var c6 = a.parentNode; c6; ) {
      if (b2 = c6[uf] || c6[Of]) {
        c6 = b2.alternate;
        if (null !== b2.child || null !== c6 && null !== c6.child) for (a = Mf(a); null !== a; ) {
          if (c6 = a[Of]) return c6;
          a = Mf(a);
        }
        return b2;
      }
      a = c6;
      c6 = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p$4(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b2) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b2;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b2) {
    var c6 = a.type.contextTypes;
    if (!c6) return Vf;
    var d2 = a.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
    var e3 = {}, f2;
    for (f2 in c6) e3[f2] = b2[f2];
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e3);
    return e3;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b2, c6) {
    if (H.current !== Vf) throw Error(p$4(168));
    G(H, b2);
    G(Wf, c6);
  }
  function bg(a, b2, c6) {
    var d2 = a.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c6;
    d2 = d2.getChildContext();
    for (var e3 in d2) if (!(e3 in b2)) throw Error(p$4(108, Ra(a) || "Unknown", e3));
    return A$1({}, c6, d2);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b2, c6) {
    var d2 = a.stateNode;
    if (!d2) throw Error(p$4(169));
    c6 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c6);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b2 = C;
      try {
        var c6 = eg;
        for (C = 1; a < c6.length; a++) {
          var d2 = c6[a];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e3) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e3;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b2;
  }
  function ug(a, b2, c6) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d2 = rg;
    a = sg;
    var e3 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e3);
    c6 += 1;
    var f2 = 32 - oc(b2) + e3;
    if (30 < f2) {
      var g2 = e3 - e3 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e3 -= g2;
      rg = 1 << 32 - oc(b2) + e3 | c6 << e3 | d2;
      sg = f2 + a;
    } else rg = 1 << f2 | c6 << e3 | d2, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b2) {
    var c6 = Bg(5, null, null, 0);
    c6.elementType = "DELETED";
    c6.stateNode = b2;
    c6.return = a;
    b2 = a.deletions;
    null === b2 ? (a.deletions = [c6], a.flags |= 16) : b2.push(c6);
  }
  function Cg(a, b2) {
    switch (a.tag) {
      case 5:
        var c6 = a.type;
        b2 = 1 !== b2.nodeType || c6.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c6 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c6, retryLane: 1073741824 }, c6 = Bg(18, null, null, 0), c6.stateNode = b2, c6.return = a, a.child = c6, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b2 = yg;
      if (b2) {
        var c6 = b2;
        if (!Cg(a, b2)) {
          if (Dg(a)) throw Error(p$4(418));
          b2 = Lf(c6.nextSibling);
          var d2 = xg;
          b2 && Cg(a, b2) ? Ag(d2, c6) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p$4(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b2;
    (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a)) throw Hg(), Error(p$4(418));
      for (; b2; ) Ag(a, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p$4(317));
      a: {
        a = a.nextSibling;
        for (b2 = 0; a; ) {
          if (8 === a.nodeType) {
            var c6 = a.data;
            if ("/$" === c6) {
              if (0 === b2) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c6 && "$!" !== c6 && "$?" !== c6 || b2++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b2, c6) {
    a = c6.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c6._owner) {
        c6 = c6._owner;
        if (c6) {
          if (1 !== c6.tag) throw Error(p$4(309));
          var d2 = c6.stateNode;
        }
        if (!d2) throw Error(p$4(147, a));
        var e3 = d2, f2 = "" + a;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a2) {
          var b3 = e3.refs;
          null === a2 ? delete b3[f2] : b3[f2] = a2;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a) throw Error(p$4(284));
      if (!c6._owner) throw Error(p$4(290, a));
    }
    return a;
  }
  function Mg(a, b2) {
    a = Object.prototype.toString.call(b2);
    throw Error(p$4(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b2 = a._init;
    return b2(a._payload);
  }
  function Og(a) {
    function b2(b3, c7) {
      if (a) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c7], b3.flags |= 16) : d3.push(c7);
      }
    }
    function c6(c7, d3) {
      if (!a) return null;
      for (; null !== d3; ) b2(c7, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a2, b3) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
      return a2;
    }
    function e3(a2, b3) {
      a2 = Pg(a2, b3);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f2(b3, c7, d3) {
      b3.index = d3;
      if (!a) return b3.flags |= 1048576, c7;
      d3 = b3.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c7 ? (b3.flags |= 2, c7) : d3;
      b3.flags |= 2;
      return c7;
    }
    function g2(b3) {
      a && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a2, b3, c7, d3) {
      if (null === b3 || 6 !== b3.tag) return b3 = Qg(c7, a2.mode, d3), b3.return = a2, b3;
      b3 = e3(b3, c7);
      b3.return = a2;
      return b3;
    }
    function k2(a2, b3, c7, d3) {
      var f3 = c7.type;
      if (f3 === ya) return m2(a2, b3, c7.props.children, d3, c7.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e3(b3, c7.props), d3.ref = Lg(a2, b3, c7), d3.return = a2, d3;
      d3 = Rg(c7.type, c7.key, c7.props, null, a2.mode, d3);
      d3.ref = Lg(a2, b3, c7);
      d3.return = a2;
      return d3;
    }
    function l2(a2, b3, c7, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c7.containerInfo || b3.stateNode.implementation !== c7.implementation) return b3 = Sg(c7, a2.mode, d3), b3.return = a2, b3;
      b3 = e3(b3, c7.children || []);
      b3.return = a2;
      return b3;
    }
    function m2(a2, b3, c7, d3, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Tg(c7, a2.mode, d3, f3), b3.return = a2, b3;
      b3 = e3(b3, c7);
      b3.return = a2;
      return b3;
    }
    function q2(a2, b3, c7) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a2.mode, c7), b3.return = a2, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c7 = Rg(b3.type, b3.key, b3.props, null, a2.mode, c7), c7.ref = Lg(a2, null, b3), c7.return = a2, c7;
          case wa:
            return b3 = Sg(b3, a2.mode, c7), b3.return = a2, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a2, d3(b3._payload), c7);
        }
        if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a2.mode, c7, null), b3.return = a2, b3;
        Mg(a2, b3);
      }
      return null;
    }
    function r2(a2, b3, c7, d3) {
      var e4 = null !== b3 ? b3.key : null;
      if ("string" === typeof c7 && "" !== c7 || "number" === typeof c7) return null !== e4 ? null : h2(a2, b3, "" + c7, d3);
      if ("object" === typeof c7 && null !== c7) {
        switch (c7.$$typeof) {
          case va:
            return c7.key === e4 ? k2(a2, b3, c7, d3) : null;
          case wa:
            return c7.key === e4 ? l2(a2, b3, c7, d3) : null;
          case Ha:
            return e4 = c7._init, r2(
              a2,
              b3,
              e4(c7._payload),
              d3
            );
        }
        if (eb(c7) || Ka(c7)) return null !== e4 ? null : m2(a2, b3, c7, d3, null);
        Mg(a2, c7);
      }
      return null;
    }
    function y2(a2, b3, c7, d3, e4) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c7) || null, h2(b3, a2, "" + d3, e4);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a2 = a2.get(null === d3.key ? c7 : d3.key) || null, k2(b3, a2, d3, e4);
          case wa:
            return a2 = a2.get(null === d3.key ? c7 : d3.key) || null, l2(b3, a2, d3, e4);
          case Ha:
            var f3 = d3._init;
            return y2(a2, b3, c7, f3(d3._payload), e4);
        }
        if (eb(d3) || Ka(d3)) return a2 = a2.get(c7) || null, m2(b3, a2, d3, e4, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e4, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e4, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a && u2 && null === n3.alternate && b2(e4, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length) return c6(e4, u2), I && tg(e4, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q2(e4, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e4, w2);
        return l3;
      }
      for (u2 = d2(e4, u2); w2 < h3.length; w2++) x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a && u2.forEach(function(a2) {
        return b2(e4, a2);
      });
      I && tg(e4, w2);
      return l3;
    }
    function t2(e4, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3) throw Error(p$4(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p$4(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e4, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a && m3 && null === t3.alternate && b2(e4, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c6(
        e4,
        m3
      ), I && tg(e4, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e4, w2);
        return l3;
      }
      for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a && m3.forEach(function(a2) {
        return b2(e4, a2);
      });
      I && tg(e4, w2);
      return l3;
    }
    function J2(a2, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c6(a2, l3.sibling);
                      d3 = e3(l3, f3.props.children);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c6(a2, l3.sibling);
                    d3 = e3(l3, f3.props);
                    d3.ref = Lg(a2, l3, f3);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                  c6(a2, l3);
                  break;
                } else b2(a2, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d3, f3), h3.return = a2, a2 = h3);
            }
            return g2(a2);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c6(a2, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c6(a2, d3);
                  break;
                }
                else b2(a2, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a2.mode, h3);
              d3.return = a2;
              a2 = d3;
            }
            return g2(a2);
          case Ha:
            return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
        }
        if (eb(f3)) return n2(a2, d3, f3, h3);
        if (Ka(f3)) return t2(a2, d3, f3, h3);
        Mg(a2, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c6(a2, d3.sibling), d3 = e3(d3, f3), d3.return = a2, a2 = d3) : (c6(a2, d3), d3 = Qg(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c6(a2, d3);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b2 = Wg.current;
    E(Wg);
    a._currentValue = b2;
  }
  function bh(a, b2, c6) {
    for (; null !== a; ) {
      var d2 = a.alternate;
      (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a === c6) break;
      a = a.return;
    }
  }
  function ch(a, b2) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b2 = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg) throw Error(p$4(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b2;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b2, c6, d2) {
    var e3 = b2.interleaved;
    null === e3 ? (c6.next = c6, gh(b2)) : (c6.next = e3.next, e3.next = c6);
    b2.interleaved = c6;
    return ih(a, d2);
  }
  function ih(a, b2) {
    a.lanes |= b2;
    var c6 = a.alternate;
    null !== c6 && (c6.lanes |= b2);
    c6 = a;
    for (a = a.return; null !== a; ) a.childLanes |= b2, c6 = a.alternate, null !== c6 && (c6.childLanes |= b2), c6 = a, a = a.return;
    return 3 === c6.tag ? c6.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b2) {
    a = a.updateQueue;
    b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b2) {
    return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b2, c6) {
    var d2 = a.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e3 = d2.pending;
      null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
      d2.pending = b2;
      return ih(a, c6);
    }
    e3 = d2.interleaved;
    null === e3 ? (b2.next = b2, gh(d2)) : (b2.next = e3.next, e3.next = b2);
    d2.interleaved = b2;
    return ih(a, c6);
  }
  function oh(a, b2, c6) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c6 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a.pendingLanes;
      c6 |= d2;
      b2.lanes = c6;
      Cc(a, c6);
    }
  }
  function ph(a, b2) {
    var c6 = a.updateQueue, d2 = a.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c6 === d2)) {
      var e3 = null, f2 = null;
      c6 = c6.firstBaseUpdate;
      if (null !== c6) {
        do {
          var g2 = { eventTime: c6.eventTime, lane: c6.lane, tag: c6.tag, payload: c6.payload, callback: c6.callback, next: null };
          null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
          c6 = c6.next;
        } while (null !== c6);
        null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
      } else e3 = f2 = b2;
      c6 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a.updateQueue = c6;
      return;
    }
    a = c6.lastBaseUpdate;
    null === a ? c6.firstBaseUpdate = b2 : a.next = b2;
    c6.lastBaseUpdate = b2;
  }
  function qh(a, b2, c6, d2) {
    var e3 = a.updateQueue;
    jh = false;
    var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
    if (null !== h2) {
      e3.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e3.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a, t2 = h2;
            r2 = b2;
            y2 = c6;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q2 = A$1({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e3.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e3.baseState = k2;
      e3.firstBaseUpdate = l2;
      e3.lastBaseUpdate = m2;
      b2 = e3.shared.interleaved;
      if (null !== b2) {
        e3 = b2;
        do
          g2 |= e3.lane, e3 = e3.next;
        while (e3 !== b2);
      } else null === f2 && (e3.shared.lanes = 0);
      rh |= g2;
      a.lanes = g2;
      a.memoizedState = q2;
    }
  }
  function sh(a, b2, c6) {
    a = b2.effects;
    b2.effects = null;
    if (null !== a) for (b2 = 0; b2 < a.length; b2++) {
      var d2 = a[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c6;
        if ("function" !== typeof e3) throw Error(p$4(191, e3));
        e3.call(d2);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p$4(174));
    return a;
  }
  function yh(a, b2) {
    G(wh, b2);
    G(vh, a);
    G(uh, th);
    a = b2.nodeType;
    switch (a) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
    }
    E(uh);
    G(uh, b2);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c6 = lb(b2, a.type);
    b2 !== c6 && (G(vh, a), G(uh, c6));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b2 = a; null !== b2; ) {
      if (13 === b2.tag) {
        var c6 = b2.memoizedState;
        if (null !== c6 && (c6 = c6.dehydrated, null === c6 || "$?" === c6.data || "$!" === c6.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p$4(321));
  }
  function Mh(a, b2) {
    if (null === b2) return false;
    for (var c6 = 0; c6 < b2.length && c6 < a.length; c6++) if (!He(a[c6], b2[c6])) return false;
    return true;
  }
  function Nh(a, b2, c6, d2, e3, f2) {
    Hh = f2;
    M = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c6(d2, e3);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p$4(301));
        f2 += 1;
        O = N = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a = c6(d2, e3);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b2) throw Error(p$4(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b2 = null === O ? M.memoizedState : O.next;
    if (null !== b2) O = b2, N = a;
    else {
      if (null === a) throw Error(p$4(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b2) {
    return "function" === typeof b2 ? b2(a) : b2;
  }
  function Wh(a) {
    var b2 = Uh(), c6 = b2.queue;
    if (null === c6) throw Error(p$4(311));
    c6.lastRenderedReducer = a;
    var d2 = N, e3 = d2.baseQueue, f2 = c6.pending;
    if (null !== f2) {
      if (null !== e3) {
        var g2 = e3.next;
        e3.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e3 = f2;
      c6.pending = null;
    }
    if (null !== e3) {
      f2 = e3.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c6.lastRenderedState = d2;
    }
    a = c6.interleaved;
    if (null !== a) {
      e3 = a;
      do
        f2 = e3.lane, M.lanes |= f2, rh |= f2, e3 = e3.next;
      while (e3 !== a);
    } else null === e3 && (c6.lanes = 0);
    return [b2.memoizedState, c6.dispatch];
  }
  function Xh(a) {
    var b2 = Uh(), c6 = b2.queue;
    if (null === c6) throw Error(p$4(311));
    c6.lastRenderedReducer = a;
    var d2 = c6.dispatch, e3 = c6.pending, f2 = b2.memoizedState;
    if (null !== e3) {
      c6.pending = null;
      var g2 = e3 = e3.next;
      do
        f2 = a(f2, g2.action), g2 = g2.next;
      while (g2 !== e3);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c6.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a, b2) {
    var c6 = M, d2 = Uh(), e3 = b2(), f2 = !He(d2.memoizedState, e3);
    f2 && (d2.memoizedState = e3, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c6, d2, a), [a]);
    if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
      c6.flags |= 2048;
      bi(9, ci.bind(null, c6, d2, e3, b2), void 0, null);
      if (null === Q) throw Error(p$4(349));
      0 !== (Hh & 30) || di(c6, b2, e3);
    }
    return e3;
  }
  function di(a, b2, c6) {
    a.flags |= 16384;
    a = { getSnapshot: b2, value: c6 };
    b2 = M.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.stores = [a]) : (c6 = b2.stores, null === c6 ? b2.stores = [a] : c6.push(a));
  }
  function ci(a, b2, c6, d2) {
    b2.value = c6;
    b2.getSnapshot = d2;
    ei(b2) && fi(a);
  }
  function ai(a, b2, c6) {
    return c6(function() {
      ei(b2) && fi(a);
    });
  }
  function ei(a) {
    var b2 = a.getSnapshot;
    a = a.value;
    try {
      var c6 = b2();
      return !He(a, c6);
    } catch (d2) {
      return true;
    }
  }
  function fi(a) {
    var b2 = ih(a, 1);
    null !== b2 && gi(b2, a, 1, -1);
  }
  function hi(a) {
    var b2 = Th();
    "function" === typeof a && (a = a());
    b2.memoizedState = b2.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b2.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b2.memoizedState, a];
  }
  function bi(a, b2, c6, d2) {
    a = { tag: a, create: b2, destroy: c6, deps: d2, next: null };
    b2 = M.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M.updateQueue = b2, b2.lastEffect = a.next = a) : (c6 = b2.lastEffect, null === c6 ? b2.lastEffect = a.next = a : (d2 = c6.next, c6.next = a, a.next = d2, b2.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b2, c6, d2) {
    var e3 = Th();
    M.flags |= a;
    e3.memoizedState = bi(1 | b2, c6, void 0, void 0 === d2 ? null : d2);
  }
  function li(a, b2, c6, d2) {
    var e3 = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N) {
      var g2 = N.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e3.memoizedState = bi(b2, c6, f2, d2);
        return;
      }
    }
    M.flags |= a;
    e3.memoizedState = bi(1 | b2, c6, f2, d2);
  }
  function mi(a, b2) {
    return ki(8390656, 8, a, b2);
  }
  function $h(a, b2) {
    return li(2048, 8, a, b2);
  }
  function ni(a, b2) {
    return li(4, 2, a, b2);
  }
  function oi(a, b2) {
    return li(4, 4, a, b2);
  }
  function pi$2(a, b2) {
    if ("function" === typeof b2) return a = a(), b2(a), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a = a(), b2.current = a, function() {
      b2.current = null;
    };
  }
  function qi(a, b2, c6) {
    c6 = null !== c6 && void 0 !== c6 ? c6.concat([a]) : null;
    return li(4, 4, pi$2.bind(null, b2, a), c6);
  }
  function ri() {
  }
  function si(a, b2) {
    var c6 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c6.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    c6.memoizedState = [a, b2];
    return a;
  }
  function ti(a, b2) {
    var c6 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c6.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    a = a();
    c6.memoizedState = [a, b2];
    return a;
  }
  function ui(a, b2, c6) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c6;
    He(c6, b2) || (c6 = yc(), M.lanes |= c6, rh |= c6, a.baseState = true);
    return b2;
  }
  function vi(a, b2) {
    var c6 = C;
    C = 0 !== c6 && 4 > c6 ? c6 : 4;
    a(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b2();
    } finally {
      C = c6, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b2, c6) {
    var d2 = yi(a);
    c6 = { lane: d2, action: c6, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b2, c6);
    else if (c6 = hh(a, b2, c6, d2), null !== c6) {
      var e3 = R();
      gi(c6, a, d2, e3);
      Bi(c6, b2, d2);
    }
  }
  function ii(a, b2, c6) {
    var d2 = yi(a), e3 = { lane: d2, action: c6, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b2, e3);
    else {
      var f2 = a.alternate;
      if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c6);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, gh(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c6 = hh(a, b2, e3, d2);
      null !== c6 && (e3 = R(), gi(c6, a, d2, e3), Bi(c6, b2, d2));
    }
  }
  function zi(a) {
    var b2 = a.alternate;
    return a === M || null !== b2 && b2 === M;
  }
  function Ai(a, b2) {
    Jh = Ih = true;
    var c6 = a.pending;
    null === c6 ? b2.next = b2 : (b2.next = c6.next, c6.next = b2);
    a.pending = b2;
  }
  function Bi(a, b2, c6) {
    if (0 !== (c6 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a.pendingLanes;
      c6 |= d2;
      b2.lanes = c6;
      Cc(a, c6);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b2) {
    Th().memoizedState = [a, void 0 === b2 ? null : b2];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b2, c6) {
    c6 = null !== c6 && void 0 !== c6 ? c6.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi$2.bind(null, b2, a),
      c6
    );
  }, useLayoutEffect: function(a, b2) {
    return ki(4194308, 4, a, b2);
  }, useInsertionEffect: function(a, b2) {
    return ki(4, 2, a, b2);
  }, useMemo: function(a, b2) {
    var c6 = Th();
    b2 = void 0 === b2 ? null : b2;
    a = a();
    c6.memoizedState = [a, b2];
    return a;
  }, useReducer: function(a, b2, c6) {
    var d2 = Th();
    b2 = void 0 !== c6 ? c6(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
    d2.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d2.memoizedState, a];
  }, useRef: function(a) {
    var b2 = Th();
    a = { current: a };
    return b2.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b2 = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b2, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b2, c6) {
    var d2 = M, e3 = Th();
    if (I) {
      if (void 0 === c6) throw Error(p$4(407));
      c6 = c6();
    } else {
      c6 = b2();
      if (null === Q) throw Error(p$4(349));
      0 !== (Hh & 30) || di(d2, b2, c6);
    }
    e3.memoizedState = c6;
    var f2 = { value: c6, getSnapshot: b2 };
    e3.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a
    ), [a]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c6, b2), void 0, null);
    return c6;
  }, useId: function() {
    var a = Th(), b2 = Q.identifierPrefix;
    if (I) {
      var c6 = sg;
      var d2 = rg;
      c6 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c6;
      b2 = ":" + b2 + "R" + c6;
      c6 = Kh++;
      0 < c6 && (b2 += "H" + c6.toString(32));
      b2 += ":";
    } else c6 = Lh++, b2 = ":" + b2 + "r" + c6.toString(32) + ":";
    return a.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b2 = Uh();
      return ui(b2, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b2 = Uh();
    return null === N ? b2.memoizedState = a : ui(b2, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b2) {
    if (a && a.defaultProps) {
      b2 = A$1({}, b2);
      a = a.defaultProps;
      for (var c6 in a) void 0 === b2[c6] && (b2[c6] = a[c6]);
      return b2;
    }
    return b2;
  }
  function Di(a, b2, c6, d2) {
    b2 = a.memoizedState;
    c6 = c6(d2, b2);
    c6 = null === c6 || void 0 === c6 ? b2 : A$1({}, b2, c6);
    a.memoizedState = c6;
    0 === a.lanes && (a.updateQueue.baseState = c6);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b2, c6) {
    a = a._reactInternals;
    var d2 = R(), e3 = yi(a), f2 = mh(d2, e3);
    f2.payload = b2;
    void 0 !== c6 && null !== c6 && (f2.callback = c6);
    b2 = nh(a, f2, e3);
    null !== b2 && (gi(b2, a, e3, d2), oh(b2, a, e3));
  }, enqueueReplaceState: function(a, b2, c6) {
    a = a._reactInternals;
    var d2 = R(), e3 = yi(a), f2 = mh(d2, e3);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c6 && null !== c6 && (f2.callback = c6);
    b2 = nh(a, f2, e3);
    null !== b2 && (gi(b2, a, e3, d2), oh(b2, a, e3));
  }, enqueueForceUpdate: function(a, b2) {
    a = a._reactInternals;
    var c6 = R(), d2 = yi(a), e3 = mh(c6, d2);
    e3.tag = 2;
    void 0 !== b2 && null !== b2 && (e3.callback = b2);
    b2 = nh(a, e3, d2);
    null !== b2 && (gi(b2, a, d2, c6), oh(b2, a, d2));
  } };
  function Fi(a, b2, c6, d2, e3, f2, g2) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c6, d2) || !Ie(e3, f2) : true;
  }
  function Gi(a, b2, c6) {
    var d2 = false, e3 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e3 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e3) : Vf);
    b2 = new b2(c6, f2);
    a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a.stateNode = b2;
    b2._reactInternals = a;
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e3, a.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a, b2, c6, d2) {
    a = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c6, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c6, d2);
    b2.state !== a && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a, b2, c6, d2) {
    var e3 = a.stateNode;
    e3.props = c6;
    e3.state = a.memoizedState;
    e3.refs = {};
    kh(a);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e3.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e3.context = Yf(a, f2));
    e3.state = a.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a, b2, f2, c6), e3.state = a.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && Ei.enqueueReplaceState(e3, e3.state, null), qh(a, c6, e3, d2), e3.state = a.memoizedState);
    "function" === typeof e3.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b2) {
    try {
      var c6 = "", d2 = b2;
      do
        c6 += Pa(d2), d2 = d2.return;
      while (d2);
      var e3 = c6;
    } catch (f2) {
      e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a, source: b2, stack: e3, digest: null };
  }
  function Ki(a, b2, c6) {
    return { value: a, source: null, stack: null != c6 ? c6 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a, b2) {
    try {
      console.error(b2.value);
    } catch (c6) {
      setTimeout(function() {
        throw c6;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b2, c6) {
    c6 = mh(-1, c6);
    c6.tag = 3;
    c6.payload = { element: null };
    var d2 = b2.value;
    c6.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a, b2);
    };
    return c6;
  }
  function Qi(a, b2, c6) {
    c6 = mh(-1, c6);
    c6.tag = 3;
    var d2 = a.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e3 = b2.value;
      c6.payload = function() {
        return d2(e3);
      };
      c6.callback = function() {
        Li(a, b2);
      };
    }
    var f2 = a.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c6.callback = function() {
      Li(a, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c7 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c7 ? c7 : "" });
    });
    return c6;
  }
  function Si(a, b2, c6) {
    var d2 = a.pingCache;
    if (null === d2) {
      d2 = a.pingCache = new Mi();
      var e3 = /* @__PURE__ */ new Set();
      d2.set(b2, e3);
    } else e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
    e3.has(c6) || (e3.add(c6), a = Ti.bind(null, a, b2, c6), b2.then(a, a));
  }
  function Ui(a) {
    do {
      var b2;
      if (b2 = 13 === a.tag) b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b2, c6, d2, e3) {
    if (0 === (a.mode & 1)) return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c6.flags |= 131072, c6.flags &= -52805, 1 === c6.tag && (null === c6.alternate ? c6.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c6, b2, 1))), c6.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e3;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b2, c6, d2) {
    b2.child = null === a ? Vg(b2, null, c6, d2) : Ug(b2, a.child, c6, d2);
  }
  function Yi(a, b2, c6, d2, e3) {
    c6 = c6.render;
    var f2 = b2.ref;
    ch(b2, e3);
    d2 = Nh(a, b2, c6, d2, f2, e3);
    c6 = Sh();
    if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e3, Zi(a, b2, e3);
    I && c6 && vg(b2);
    b2.flags |= 1;
    Xi(a, b2, d2, e3);
    return b2.child;
  }
  function $i(a, b2, c6, d2, e3) {
    if (null === a) {
      var f2 = c6.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c6.compare && void 0 === c6.defaultProps) return b2.tag = 15, b2.type = f2, bj(a, b2, f2, d2, e3);
      a = Rg(c6.type, null, d2, b2, b2.mode, e3);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    f2 = a.child;
    if (0 === (a.lanes & e3)) {
      var g2 = f2.memoizedProps;
      c6 = c6.compare;
      c6 = null !== c6 ? c6 : Ie;
      if (c6(g2, d2) && a.ref === b2.ref) return Zi(a, b2, e3);
    }
    b2.flags |= 1;
    a = Pg(f2, d2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  function bj(a, b2, c6, d2, e3) {
    if (null !== a) {
      var f2 = a.memoizedProps;
      if (Ie(f2, d2) && a.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e3)) 0 !== (a.flags & 131072) && (dh = true);
      else return b2.lanes = a.lanes, Zi(a, b2, e3);
    }
    return cj(a, b2, c6, d2, e3);
  }
  function dj(a, b2, c6) {
    var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a ? a.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c6;
    else {
      if (0 === (c6 & 1073741824)) return a = null !== f2 ? f2.baseLanes | c6 : c6, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c6;
      G(ej, fj);
      fj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c6, b2.memoizedState = null) : d2 = c6, G(ej, fj), fj |= d2;
    Xi(a, b2, e3, c6);
    return b2.child;
  }
  function gj(a, b2) {
    var c6 = b2.ref;
    if (null === a && null !== c6 || null !== a && a.ref !== c6) b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a, b2, c6, d2, e3) {
    var f2 = Zf(c6) ? Xf : H.current;
    f2 = Yf(b2, f2);
    ch(b2, e3);
    c6 = Nh(a, b2, c6, d2, f2, e3);
    d2 = Sh();
    if (null !== a && !dh) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e3, Zi(a, b2, e3);
    I && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a, b2, c6, e3);
    return b2.child;
  }
  function hj(a, b2, c6, d2, e3) {
    if (Zf(c6)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    ch(b2, e3);
    if (null === b2.stateNode) ij(a, b2), Gi(b2, c6, d2), Ii(b2, c6, d2, e3), d2 = true;
    else if (null === a) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c6.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c6) ? Xf : H.current, l2 = Yf(b2, l2));
      var m2 = c6.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e3);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c6, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c6, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c6.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c6) ? Xf : H.current, k2 = Yf(b2, k2));
      var y2 = c6.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e3);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c6, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c6, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a, b2, c6, d2, f2, e3);
  }
  function jj(a, b2, c6, d2, e3, f2) {
    gj(a, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2) return e3 && dg(b2, c6, false), Zi(a, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c6.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a && g2 ? (b2.child = Ug(b2, a.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a, b2, h2, f2);
    b2.memoizedState = d2.state;
    e3 && dg(b2, c6, true);
    return b2.child;
  }
  function kj(a) {
    var b2 = a.stateNode;
    b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
    yh(a, b2.containerInfo);
  }
  function lj(a, b2, c6, d2, e3) {
    Ig();
    Jg(e3);
    b2.flags |= 256;
    Xi(a, b2, c6, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b2, c6) {
    var d2 = b2.pendingProps, e3 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e3 & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a || null !== a.memoizedState) e3 |= 1;
    G(L, e3 & 1);
    if (null === a) {
      Eg(b2);
      a = b2.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a = Tg(a, d2, c6, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = nj(c6), b2.memoizedState = mj, a) : qj(b2, g2);
    }
    e3 = a.memoizedState;
    if (null !== e3 && (h2 = e3.dehydrated, null !== h2)) return rj(a, b2, g2, d2, h2, e3, c6);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e3 = a.child;
      h2 = e3.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c6, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a.child.memoizedState;
      g2 = null === g2 ? nj(c6) : { baseLanes: g2.baseLanes | c6, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a.childLanes & ~c6;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a.child;
    a = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c6);
    d2.return = b2;
    d2.sibling = null;
    null !== a && (c6 = b2.deletions, null === c6 ? (b2.deletions = [a], b2.flags |= 16) : c6.push(a));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a.mode, 0, null);
    b2.return = a;
    return a.child = b2;
  }
  function sj(a, b2, c6, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a.child, null, c6);
    a = qj(b2, b2.pendingProps.children);
    a.flags |= 2;
    b2.memoizedState = null;
    return a;
  }
  function rj(a, b2, c6, d2, e3, f2, g2) {
    if (c6) {
      if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$4(422))), sj(a, b2, g2, d2);
      if (null !== b2.memoizedState) return b2.child = a.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e3 = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e3, 0, null);
      f2 = Tg(f2, e3, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return sj(a, b2, g2, null);
    if ("$!" === e3.data) {
      d2 = e3.nextSibling && e3.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p$4(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a.childLanes);
    if (dh || h2) {
      d2 = Q;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e3 = 2;
            break;
          case 16:
            e3 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e3 = 32;
            break;
          case 536870912:
            e3 = 268435456;
            break;
          default:
            e3 = 0;
        }
        e3 = 0 !== (e3 & (d2.suspendedLanes | g2)) ? 0 : e3;
        0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, ih(a, e3), gi(d2, a, e3, -1));
      }
      tj();
      d2 = Ki(Error(p$4(421)));
      return sj(a, b2, g2, d2);
    }
    if ("$?" === e3.data) return b2.flags |= 128, b2.child = a.child, b2 = uj.bind(null, a), e3._reactRetry = b2, null;
    a = f2.treeContext;
    yg = Lf(e3.nextSibling);
    xg = b2;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a, b2, c6) {
    a.lanes |= b2;
    var d2 = a.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a.return, b2, c6);
  }
  function wj(a, b2, c6, d2, e3) {
    var f2 = a.memoizedState;
    null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c6, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c6, f2.tailMode = e3);
  }
  function xj(a, b2, c6) {
    var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
    Xi(a, b2, d2.children, c6);
    d2 = L.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b2.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c6, b2);
        else if (19 === a.tag) vj(a, c6, b2);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b2) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b2) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d2 &= 1;
    }
    G(L, d2);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e3) {
      case "forwards":
        c6 = b2.child;
        for (e3 = null; null !== c6; ) a = c6.alternate, null !== a && null === Ch(a) && (e3 = c6), c6 = c6.sibling;
        c6 = e3;
        null === c6 ? (e3 = b2.child, b2.child = null) : (e3 = c6.sibling, c6.sibling = null);
        wj(b2, false, e3, c6, f2);
        break;
      case "backwards":
        c6 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a = e3.alternate;
          if (null !== a && null === Ch(a)) {
            b2.child = e3;
            break;
          }
          a = e3.sibling;
          e3.sibling = c6;
          c6 = e3;
          e3 = a;
        }
        wj(b2, true, c6, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function ij(a, b2) {
    0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a, b2, c6) {
    null !== a && (b2.dependencies = a.dependencies);
    rh |= b2.lanes;
    if (0 === (c6 & b2.childLanes)) return null;
    if (null !== a && b2.child !== a.child) throw Error(p$4(153));
    if (null !== b2.child) {
      a = b2.child;
      c6 = Pg(a, a.pendingProps);
      b2.child = c6;
      for (c6.return = b2; null !== a.sibling; ) a = a.sibling, c6 = c6.sibling = Pg(a, a.pendingProps), c6.return = b2;
      c6.sibling = null;
    }
    return b2.child;
  }
  function yj(a, b2, c6) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e3 = b2.memoizedProps.value;
        G(Wg, d2._currentValue);
        d2._currentValue = e3;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
          if (0 !== (c6 & b2.child.childLanes)) return oj(a, b2, c6);
          G(L, L.current & 1);
          a = Zi(a, b2, c6);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d2 = 0 !== (c6 & b2.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d2) return xj(a, b2, c6);
          b2.flags |= 128;
        }
        e3 = b2.memoizedState;
        null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
        G(L, L.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a, b2, c6);
    }
    return Zi(a, b2, c6);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b2) {
    for (var c6 = b2.child; null !== c6; ) {
      if (5 === c6.tag || 6 === c6.tag) a.appendChild(c6.stateNode);
      else if (4 !== c6.tag && null !== c6.child) {
        c6.child.return = c6;
        c6 = c6.child;
        continue;
      }
      if (c6 === b2) break;
      for (; null === c6.sibling; ) {
        if (null === c6.return || c6.return === b2) return;
        c6 = c6.return;
      }
      c6.sibling.return = c6.return;
      c6 = c6.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b2, c6, d2) {
    var e3 = a.memoizedProps;
    if (e3 !== d2) {
      a = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c6) {
        case "input":
          e3 = Ya(a, e3);
          d2 = Ya(a, d2);
          f2 = [];
          break;
        case "select":
          e3 = A$1({}, e3, { value: void 0 });
          d2 = A$1({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e3 = gb(a, e3);
          d2 = gb(a, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
      }
      ub(c6, d2);
      var g2;
      c6 = null;
      for (l2 in e3) if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2]) if ("style" === l2) {
        var h2 = e3[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c6 || (c6 = {}), c6[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e3 ? e3[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c6 || (c6 = {}), c6[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c6 || (c6 = {}), c6[g2] = k2[g2]);
        } else c6 || (f2 || (f2 = []), f2.push(
          l2,
          c6
        )), c6 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c6 && (f2 = f2 || []).push("style", c6);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Cj = function(a, b2, c6, d2) {
    c6 !== d2 && (b2.flags |= 4);
  };
  function Dj(a, b2) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c6 = null; null !== b2; ) null !== b2.alternate && (c6 = b2), b2 = b2.sibling;
        null === c6 ? a.tail = null : c6.sibling = null;
        break;
      case "collapsed":
        c6 = a.tail;
        for (var d2 = null; null !== c6; ) null !== c6.alternate && (d2 = c6), c6 = c6.sibling;
        null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
  }
  function S(a) {
    var b2 = null !== a.alternate && a.alternate.child === a.child, c6 = 0, d2 = 0;
    if (b2) for (var e3 = a.child; null !== e3; ) c6 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a, e3 = e3.sibling;
    else for (e3 = a.child; null !== e3; ) c6 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a, e3 = e3.sibling;
    a.subtreeFlags |= d2;
    a.childLanes = c6;
    return b2;
  }
  function Ej(a, b2, c6) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a || null === a.child) Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b2);
        S(b2);
        return null;
      case 5:
        Bh(b2);
        var e3 = xh(wh.current);
        c6 = b2.type;
        if (null !== a && null != b2.stateNode) Bj(a, b2, c6, d2, e3), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode) throw Error(p$4(166));
            S(b2);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c6 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a = 0 !== (b2.mode & 1);
            switch (c6) {
              case "dialog":
                D("cancel", d2);
                D("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d2);
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], d2);
                break;
              case "source":
                D("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d2
                );
                D("load", d2);
                break;
              case "details":
                D("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D("invalid", d2);
            }
            ub(c6, f2);
            e3 = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a
              ), e3 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
            switch (c6) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e3;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c6));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c6 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c6, { is: d2.is }) : (a = g2.createElement(c6), "select" === c6 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c6);
            a[Of] = b2;
            a[Pf] = d2;
            zj(a, b2, false, false);
            b2.stateNode = a;
            a: {
              g2 = vb(c6, d2);
              switch (c6) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e3 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e3 = d2;
                  break;
                case "video":
                case "audio":
                  for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], a);
                  e3 = d2;
                  break;
                case "source":
                  D("error", a);
                  e3 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e3 = d2;
                  break;
                case "details":
                  D("toggle", a);
                  e3 = d2;
                  break;
                case "input":
                  Za(a, d2);
                  e3 = Ya(a, d2);
                  D("invalid", a);
                  break;
                case "option":
                  e3 = d2;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d2.multiple };
                  e3 = A$1({}, d2, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d2);
                  e3 = gb(a, d2);
                  D("invalid", a);
                  break;
                default:
                  e3 = d2;
              }
              ub(c6, e3);
              h2 = e3;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c6 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
              switch (c6) {
                case "input":
                  Va(a);
                  db(a, d2, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e3.onClick && (a.onclick = Bf);
              }
              switch (c6) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S(b2);
        return null;
      case 6:
        if (a && null != b2.stateNode) Cj(a, b2, a.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$4(166));
          c6 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c6 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c6) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c6, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c6, 0 !== (a.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d2 = (9 === c6.nodeType ? c6 : c6.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S(b2);
        return null;
      case 13:
        E(L);
        d2 = b2.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a) {
              if (!f2) throw Error(p$4(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p$4(317));
              f2[Of] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S(b2);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c6, b2;
        d2 = null !== d2;
        d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S(b2);
        return null;
      case 4:
        return zh(), Aj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
      case 10:
        return ah(b2.type._context), S(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S(b2), null;
      case 19:
        E(L);
        f2 = b2.memoizedState;
        if (null === f2) return S(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Dj(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b2.child; null !== a; ) {
            g2 = Ch(a);
            if (null !== g2) {
              b2.flags |= 128;
              Dj(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d2 = c6;
              for (c6 = b2.child; null !== c6; ) f2 = c6, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c6 = c6.sibling;
              G(L, L.current & 1 | 2);
              return b2.child;
            }
            a = a.sibling;
          }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d2) if (a = Ch(g2), null !== a) {
            if (b2.flags |= 128, d2 = true, c6 = a.updateQueue, null !== c6 && (b2.updateQueue = c6, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
          } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c6 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c6 = f2.last, null !== c6 ? c6.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c6 = L.current, G(L, d2 ? c6 & 1 | 2 : c6 & 1), b2;
        S(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p$4(156, b2.tag));
  }
  function Ij(a, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E(L);
        a = b2.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b2.alternate) throw Error(p$4(340));
          Ig();
        }
        a = b2.flags;
        return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b2) {
    var c6 = a.ref;
    if (null !== c6) if ("function" === typeof c6) try {
      c6(null);
    } catch (d2) {
      W(a, b2, d2);
    }
    else c6.current = null;
  }
  function Mj(a, b2, c6) {
    try {
      c6();
    } catch (d2) {
      W(a, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a, b2) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c6 = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c6 = (c6 = a.ownerDocument) && c6.defaultView || window;
        var d2 = c6.getSelection && c6.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c6 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c6.nodeType, f2.nodeType;
          } catch (F2) {
            c6 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c6 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g2 + e3);
              q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
              3 === q2.nodeType && (g2 += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a) break b;
              r2 === c6 && ++l2 === e3 && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c6 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c6 = null;
      }
      c6 = c6 || { start: 0, end: 0 };
    } else c6 = null;
    Df = { focusedElem: a, selectionRange: c6 };
    dd = false;
    for (V = b2; null !== V; ) if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a) a.return = b2, V = a;
    else for (; null !== V; ) {
      b2 = V;
      try {
        var n2 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p$4(163));
        }
      } catch (F2) {
        W(b2, b2.return, F2);
      }
      a = b2.sibling;
      if (null !== a) {
        a.return = b2.return;
        V = a;
        break;
      }
      V = b2.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a, b2, c6) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e3 = d2 = d2.next;
      do {
        if ((e3.tag & a) === a) {
          var f2 = e3.destroy;
          e3.destroy = void 0;
          void 0 !== f2 && Mj(b2, c6, f2);
        }
        e3 = e3.next;
      } while (e3 !== d2);
    }
  }
  function Qj(a, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c6 = b2 = b2.next;
      do {
        if ((c6.tag & a) === a) {
          var d2 = c6.create;
          c6.destroy = d2();
        }
        c6 = c6.next;
      } while (c6 !== b2);
    }
  }
  function Rj(a) {
    var b2 = a.ref;
    if (null !== b2) {
      var c6 = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c6;
          break;
        default:
          a = c6;
      }
      "function" === typeof b2 ? b2(a) : b2.current = a;
    }
  }
  function Sj(a) {
    var b2 = a.alternate;
    null !== b2 && (a.alternate = null, Sj(b2));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b2, c6) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? 8 === c6.nodeType ? c6.parentNode.insertBefore(a, b2) : c6.insertBefore(a, b2) : (8 === c6.nodeType ? (b2 = c6.parentNode, b2.insertBefore(a, c6)) : (b2 = c6, b2.appendChild(a)), c6 = c6._reactRootContainer, null !== c6 && void 0 !== c6 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a = a.child, null !== a)) for (Vj(a, b2, c6), a = a.sibling; null !== a; ) Vj(a, b2, c6), a = a.sibling;
  }
  function Wj(a, b2, c6) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? c6.insertBefore(a, b2) : c6.appendChild(a);
    else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b2, c6), a = a.sibling; null !== a; ) Wj(a, b2, c6), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b2, c6) {
    for (c6 = c6.child; null !== c6; ) Zj(a, b2, c6), c6 = c6.sibling;
  }
  function Zj(a, b2, c6) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c6);
    } catch (h2) {
    }
    switch (c6.tag) {
      case 5:
        U || Lj(c6, b2);
      case 6:
        var d2 = X, e3 = Xj;
        X = null;
        Yj(a, b2, c6);
        X = d2;
        Xj = e3;
        null !== X && (Xj ? (a = X, c6 = c6.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c6) : a.removeChild(c6)) : X.removeChild(c6.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c6 = c6.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c6) : 1 === a.nodeType && Kf(a, c6), bd(a)) : Kf(X, c6.stateNode));
        break;
      case 4:
        d2 = X;
        e3 = Xj;
        X = c6.stateNode.containerInfo;
        Xj = true;
        Yj(a, b2, c6);
        X = d2;
        Xj = e3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d2 = c6.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e3 = d2 = d2.next;
          do {
            var f2 = e3, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c6, b2, g2) : 0 !== (f2 & 4) && Mj(c6, b2, g2));
            e3 = e3.next;
          } while (e3 !== d2);
        }
        Yj(a, b2, c6);
        break;
      case 1:
        if (!U && (Lj(c6, b2), d2 = c6.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c6.memoizedProps, d2.state = c6.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c6, b2, h2);
        }
        Yj(a, b2, c6);
        break;
      case 21:
        Yj(a, b2, c6);
        break;
      case 22:
        c6.mode & 1 ? (U = (d2 = U) || null !== c6.memoizedState, Yj(a, b2, c6), U = d2) : Yj(a, b2, c6);
        break;
      default:
        Yj(a, b2, c6);
    }
  }
  function ak(a) {
    var b2 = a.updateQueue;
    if (null !== b2) {
      a.updateQueue = null;
      var c6 = a.stateNode;
      null === c6 && (c6 = a.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a, b3);
        c6.has(b3) || (c6.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a, b2) {
    var c6 = b2.deletions;
    if (null !== c6) for (var d2 = 0; d2 < c6.length; d2++) {
      var e3 = c6[d2];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X) throw Error(p$4(160));
        Zj(f2, g2, e3);
        X = null;
        Xj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W(e3, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a), b2 = b2.sibling;
  }
  function dk(a, b2) {
    var c6 = a.alternate, d2 = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a);
        ek(a);
        if (d2 & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t2) {
            W(a, a.return, t2);
          }
          try {
            Pj(5, a, a.return);
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a);
        ek(a);
        d2 & 512 && null !== c6 && Lj(c6, c6.return);
        break;
      case 5:
        ck(b2, a);
        ek(a);
        d2 & 512 && null !== c6 && Lj(c6, c6.return);
        if (a.flags & 32) {
          var e3 = a.stateNode;
          try {
            ob(e3, "");
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        if (d2 & 4 && (e3 = a.stateNode, null != e3)) {
          var f2 = a.memoizedProps, g2 = null !== c6 ? c6.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
          a.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 6:
        ck(b2, a);
        ek(a);
        if (d2 & 4) {
          if (null === a.stateNode) throw Error(p$4(162));
          e3 = a.stateNode;
          f2 = a.memoizedProps;
          try {
            e3.nodeValue = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a);
        ek(a);
        if (d2 & 4 && null !== c6 && c6.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
        break;
      case 4:
        ck(b2, a);
        ek(a);
        break;
      case 13:
        ck(b2, a);
        ek(a);
        e3 = a.child;
        e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (fk = B()));
        d2 & 4 && ak(a);
        break;
      case 22:
        m2 = null !== c6 && null !== c6.memoizedState;
        a.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a), U = l2) : ck(b2, a);
        ek(a);
        if (d2 & 8192) {
          l2 = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c6 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c6, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t2) {
                W(a, a.return, t2);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b2, a);
        ek(a);
        d2 & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b2 = a.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c6 = a.return; null !== c6; ) {
            if (Tj(c6)) {
              var d2 = c6;
              break a;
            }
            c6 = c6.return;
          }
          throw Error(p$4(160));
        }
        switch (d2.tag) {
          case 5:
            var e3 = d2.stateNode;
            d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
            var f2 = Uj(a);
            Wj(a, f2, e3);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a);
            Vj(a, h2, g2);
            break;
          default:
            throw Error(p$4(161));
        }
      } catch (k2) {
        W(a, a.return, k2);
      }
      a.flags &= -3;
    }
    b2 & 4096 && (a.flags &= -4097);
  }
  function hk(a, b2, c6) {
    V = a;
    ik(a);
  }
  function ik(a, b2, c6) {
    for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
      var e3 = V, f2 = e3.child;
      if (22 === e3.tag && d2) {
        var g2 = null !== e3.memoizedState || Jj;
        if (!g2) {
          var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l2 = U;
          Jj = g2;
          if ((U = k2) && !l2) for (V = e3; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e3) : null !== k2 ? (k2.return = g2, V = k2) : jk(e3);
          for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
          V = e3;
          Jj = h2;
          U = l2;
        }
        kk(a);
      } else 0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V = f2) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b2 = V;
      if (0 !== (b2.flags & 8772)) {
        var c6 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U) if (null === c6) d2.componentDidMount();
              else {
                var e3 = b2.elementType === b2.type ? c6.memoizedProps : Ci(b2.type, c6.memoizedProps);
                d2.componentDidUpdate(e3, c6.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c6 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c6 = b2.child.stateNode;
                    break;
                  case 1:
                    c6 = b2.child.stateNode;
                }
                sh(b2, g2, c6);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c6 && b2.flags & 4) {
                c6 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c6.focus();
                    break;
                  case "img":
                    k2.src && (c6.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$4(163));
          }
          U || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W(b2, b2.return, r2);
        }
      }
      if (b2 === a) {
        V = null;
        break;
      }
      c6 = b2.sibling;
      if (null !== c6) {
        c6.return = b2.return;
        V = c6;
        break;
      }
      V = b2.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b2 = V;
      if (b2 === a) {
        V = null;
        break;
      }
      var c6 = b2.sibling;
      if (null !== c6) {
        c6.return = b2.return;
        V = c6;
        break;
      }
      V = b2.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b2 = V;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c6 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W(b2, c6, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e3 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W(b2, e3, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, g2, k2);
            }
        }
      } catch (k2) {
        W(b2, b2.return, k2);
      }
      if (b2 === a) {
        V = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V = h2;
        break;
      }
      V = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b2, c6, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p$4(185));
    Ac(a, c6, d2);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c6), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c6 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b2) {
    var c6 = a.callbackNode;
    wc(a, b2);
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2) null !== c6 && bc(c6), a.callbackNode = null, a.callbackPriority = 0;
    else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
      null != c6 && bc(c6);
      if (1 === b2) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c6 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c6 = fc;
            break;
          case 4:
            c6 = gc;
            break;
          case 16:
            c6 = hc;
            break;
          case 536870912:
            c6 = jc;
            break;
          default:
            c6 = hc;
        }
        c6 = Fk(c6, Gk.bind(null, a));
      }
      a.callbackPriority = b2;
      a.callbackNode = c6;
    }
  }
  function Gk(a, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p$4(327));
    var c6 = a.callbackNode;
    if (Hk() && a.callbackNode !== c6) return null;
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2) b2 = Ik(a, d2);
    else {
      b2 = d2;
      var e3 = K;
      K |= 2;
      var f2 = Jk();
      if (Q !== a || Z !== b2) uk = null, Gj = B() + 500, Kk(a, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e3;
      null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
    }
    if (0 !== b2) {
      2 === b2 && (e3 = xc(a), 0 !== e3 && (d2 = e3, b2 = Nk(a, e3)));
      if (1 === b2) throw c6 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c6;
      if (6 === b2) Ck(a, d2);
      else {
        e3 = a.current.alternate;
        if (0 === (d2 & 30) && !Ok(e3) && (b2 = Ik(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Nk(a, f2))), 1 === b2)) throw c6 = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c6;
        a.finishedWork = e3;
        a.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p$4(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
              if (0 !== uc(a, 0)) break;
              e3 = a.suspendedLanes;
              if ((e3 & d2) !== d2) {
                R();
                a.pingedLanes |= a.suspendedLanes & e3;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b2);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d2);
            if ((d2 & 4194240) === d2) break;
            b2 = a.eventTimes;
            for (e3 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e3 && (e3 = g2);
              d2 &= ~f2;
            }
            d2 = e3;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p$4(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c6 ? Gk.bind(null, a) : null;
  }
  function Nk(a, b2) {
    var c6 = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b2).flags |= 256);
    a = Ik(a, b2);
    2 !== a && (b2 = tk, tk = c6, null !== b2 && Fj(b2));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b2 = a; ; ) {
      if (b2.flags & 16384) {
        var c6 = b2.updateQueue;
        if (null !== c6 && (c6 = c6.stores, null !== c6)) for (var d2 = 0; d2 < c6.length; d2++) {
          var e3 = c6[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He(f2(), e3)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c6 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c6) c6.return = b2, b2 = c6;
      else {
        if (b2 === a) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a.suspendedLanes |= b2;
    a.pingedLanes &= ~b2;
    for (a = a.expirationTimes; 0 < b2; ) {
      var c6 = 31 - oc(b2), d2 = 1 << c6;
      a[c6] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p$4(327));
    Hk();
    var b2 = uc(a, 0);
    if (0 === (b2 & 1)) return Dk(a, B()), null;
    var c6 = Ik(a, b2);
    if (0 !== a.tag && 2 === c6) {
      var d2 = xc(a);
      0 !== d2 && (b2 = d2, c6 = Nk(a, d2));
    }
    if (1 === c6) throw c6 = pk, Kk(a, 0), Ck(a, b2), Dk(a, B()), c6;
    if (6 === c6) throw Error(p$4(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b2;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b2) {
    var c6 = K;
    K |= 1;
    try {
      return a(b2);
    } finally {
      K = c6, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b2 = K;
    K |= 1;
    var c6 = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d2, ok.transition = c6, K = b2, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b2) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c6 = a.timeoutHandle;
    -1 !== c6 && (a.timeoutHandle = -1, Gf(c6));
    if (null !== Y) for (c6 = Y.return; null !== c6; ) {
      var d2 = c6;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c6 = c6.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b2;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++) if (c6 = fh[b2], d2 = c6.interleaved, null !== d2) {
        c6.interleaved = null;
        var e3 = d2.next, f2 = c6.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d2.next = g2;
        }
        c6.pending = d2;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b2) {
    do {
      var c6 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M.memoizedState; null !== d2; ) {
            var e3 = d2.queue;
            null !== e3 && (e3.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c6 || null === c6.return) {
          T = 1;
          pk = b2;
          Y = null;
          break;
        }
        a: {
          var f2 = a, g2 = c6.return, h2 = c6, k2 = b2;
          b2 = Z;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p$4(426));
            }
          } else if (I && h2.mode & 1) {
            var J2 = Ui(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T && (T = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F2 = Qi(f2, h2, b2);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c6);
      } catch (na) {
        b2 = na;
        Y === c6 && null !== c6 && (Y = c6 = c6.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b2) {
    var c6 = K;
    K |= 2;
    var d2 = Jk();
    if (Q !== a || Z !== b2) uk = null, Kk(a, b2);
    do
      try {
        Tk();
        break;
      } catch (e3) {
        Mk(a, e3);
      }
    while (1);
    $g();
    K = c6;
    mk.current = d2;
    if (null !== Y) throw Error(p$4(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b2 = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b2 ? Sk(a) : Y = b2;
    nk.current = null;
  }
  function Sk(a) {
    var b2 = a;
    do {
      var c6 = b2.alternate;
      a = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c6 = Ej(c6, b2, fj), null !== c6) {
          Y = c6;
          return;
        }
      } else {
        c6 = Ij(c6, b2);
        if (null !== c6) {
          c6.flags &= 32767;
          Y = c6;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y = b2;
        return;
      }
      Y = b2 = a;
    } while (null !== b2);
    0 === T && (T = 5);
  }
  function Pk(a, b2, c6) {
    var d2 = C, e3 = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b2, c6, d2);
    } finally {
      ok.transition = e3, C = d2;
    }
    return null;
  }
  function Wk(a, b2, c6, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p$4(327));
    c6 = a.finishedWork;
    var e3 = a.finishedLanes;
    if (null === c6) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c6 === a.current) throw Error(p$4(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f2 = c6.lanes | c6.childLanes;
    Bc(a, f2);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c6.subtreeFlags & 2064) && 0 === (c6.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c6.flags & 15990);
    if (0 !== (c6.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a, c6);
      dk(c6, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c6;
      hk(c6);
      dc();
      K = h2;
      C = g2;
      ok.transition = f2;
    } else a.current = c6;
    vk && (vk = false, wk = a, xk = e3);
    f2 = a.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c6.stateNode);
    Dk(a, B());
    if (null !== b2) for (d2 = a.onRecoverableError, c6 = 0; c6 < b2.length; c6++) e3 = b2[c6], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f2 = a.pendingLanes;
    0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b2 = ok.transition, c6 = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d2 = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p$4(331));
          var e3 = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f2 = V, g2 = f2.child;
            if (0 !== (V.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V = q2;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
            else b: for (; null !== V; ) {
              f2 = V;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V = x2;
                break b;
              }
              V = f2.return;
            }
          }
          var w2 = a.current;
          for (V = w2; null !== V; ) {
            g2 = V;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
            else b: for (g2 = w2; null !== V; ) {
              h2 = V;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W(h2, h2.return, na);
              }
              if (h2 === g2) {
                V = null;
                break b;
              }
              var F2 = h2.sibling;
              if (null !== F2) {
                F2.return = h2.return;
                V = F2;
                break b;
              }
              V = h2.return;
            }
          }
          K = e3;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c6, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a, b2, c6) {
    b2 = Ji(c6, b2);
    b2 = Ni(a, b2, 1);
    a = nh(a, b2, 1);
    b2 = R();
    null !== a && (Ac(a, 1, b2), Dk(a, b2));
  }
  function W(a, b2, c6) {
    if (3 === a.tag) Xk(a, a, c6);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a, c6);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a = Ji(c6, a);
          a = Qi(b2, a, 1);
          b2 = nh(b2, a, 1);
          a = R();
          null !== b2 && (Ac(b2, 1, a), Dk(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ti(a, b2, c6) {
    var d2 = a.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R();
    a.pingedLanes |= a.suspendedLanes & c6;
    Q === a && (Z & c6) === c6 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c6);
    Dk(a, b2);
  }
  function Yk(a, b2) {
    0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c6 = R();
    a = ih(a, b2);
    null !== a && (Ac(a, b2, c6), Dk(a, c6));
  }
  function uj(a) {
    var b2 = a.memoizedState, c6 = 0;
    null !== b2 && (c6 = b2.retryLane);
    Yk(a, c6);
  }
  function bk(a, b2) {
    var c6 = 0;
    switch (a.tag) {
      case 13:
        var d2 = a.stateNode;
        var e3 = a.memoizedState;
        null !== e3 && (c6 = e3.retryLane);
        break;
      case 19:
        d2 = a.stateNode;
        break;
      default:
        throw Error(p$4(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a, c6);
  }
  var Vk;
  Vk = function(a, b2, c6) {
    if (null !== a) if (a.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c6) && 0 === (b2.flags & 128)) return dh = false, yj(a, b2, c6);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a, b2);
        a = b2.pendingProps;
        var e3 = Yf(b2, H.current);
        ch(b2, c6);
        e3 = Nh(null, b2, d2, a, e3, c6);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, kh(b2), e3.updater = Ei, b2.stateNode = e3, e3._reactInternals = b2, Ii(b2, d2, a, c6), b2 = jj(null, b2, d2, true, f2, c6)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e3, c6), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a, b2);
          a = b2.pendingProps;
          e3 = d2._init;
          d2 = e3(d2._payload);
          b2.type = d2;
          e3 = b2.tag = Zk(d2);
          a = Ci(d2, a);
          switch (e3) {
            case 0:
              b2 = cj(null, b2, d2, a, c6);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a, c6);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a, c6);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a), c6);
              break a;
          }
          throw Error(p$4(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), cj(a, b2, d2, e3, c6);
      case 1:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), hj(a, b2, d2, e3, c6);
      case 3:
        a: {
          kj(b2);
          if (null === a) throw Error(p$4(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e3 = f2.element;
          lh(a, b2);
          qh(b2, d2, null, c6);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ji(Error(p$4(423)), b2);
            b2 = lj(a, b2, d2, c6, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ji(Error(p$4(424)), b2);
            b2 = lj(a, b2, d2, c6, e3);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c6 = Vg(b2, null, d2, c6), b2.child = c6; c6; ) c6.flags = c6.flags & -3 | 4096, c6 = c6.sibling;
          else {
            Ig();
            if (d2 === e3) {
              b2 = Zi(a, b2, c6);
              break a;
            }
            Xi(a, b2, d2, c6);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e3.children, Ef(d2, e3) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a, b2), Xi(a, b2, g2, c6), b2.child;
      case 6:
        return null === a && Eg(b2), null;
      case 13:
        return oj(a, b2, c6);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Ug(b2, null, d2, c6) : Xi(a, b2, d2, c6), b2.child;
      case 11:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), Yi(a, b2, d2, e3, c6);
      case 7:
        return Xi(a, b2, b2.pendingProps, c6), b2.child;
      case 8:
        return Xi(a, b2, b2.pendingProps.children, c6), b2.child;
      case 12:
        return Xi(a, b2, b2.pendingProps.children, c6), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e3 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e3.value;
          G(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = Zi(a, b2, c6);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c6 & -c6);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c6;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c6);
                  bh(
                    f2.return,
                    c6,
                    b2
                  );
                  h2.lanes |= c6;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p$4(341));
              g2.lanes |= c6;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c6);
              bh(g2, c6, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi(a, b2, e3.children, c6);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e3 = b2.type, d2 = b2.pendingProps.children, ch(b2, c6), e3 = eh(e3), d2 = d2(e3), b2.flags |= 1, Xi(a, b2, d2, c6), b2.child;
      case 14:
        return d2 = b2.type, e3 = Ci(d2, b2.pendingProps), e3 = Ci(d2.type, e3), $i(a, b2, d2, e3, c6);
      case 15:
        return bj(a, b2, b2.type, b2.pendingProps, c6);
      case 17:
        return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Ci(d2, e3), ij(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, ch(b2, c6), Gi(b2, d2, e3), Ii(b2, d2, e3, c6), jj(null, b2, d2, true, a, c6);
      case 19:
        return xj(a, b2, c6);
      case 22:
        return dj(a, b2, c6);
    }
    throw Error(p$4(156, b2.tag));
  };
  function Fk(a, b2) {
    return ac(a, b2);
  }
  function $k(a, b2, c6, d2) {
    this.tag = a;
    this.key = c6;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b2, c6, d2) {
    return new $k(a, b2, c6, d2);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b2) {
    var c6 = a.alternate;
    null === c6 ? (c6 = Bg(a.tag, b2, a.key, a.mode), c6.elementType = a.elementType, c6.type = a.type, c6.stateNode = a.stateNode, c6.alternate = a, a.alternate = c6) : (c6.pendingProps = b2, c6.type = a.type, c6.flags = 0, c6.subtreeFlags = 0, c6.deletions = null);
    c6.flags = a.flags & 14680064;
    c6.childLanes = a.childLanes;
    c6.lanes = a.lanes;
    c6.child = a.child;
    c6.memoizedProps = a.memoizedProps;
    c6.memoizedState = a.memoizedState;
    c6.updateQueue = a.updateQueue;
    b2 = a.dependencies;
    c6.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c6.sibling = a.sibling;
    c6.index = a.index;
    c6.ref = a.ref;
    return c6;
  }
  function Rg(a, b2, c6, d2, e3, f2) {
    var g2 = 2;
    d2 = a;
    if ("function" === typeof a) aj(a) && (g2 = 1);
    else if ("string" === typeof a) g2 = 5;
    else a: switch (a) {
      case ya:
        return Tg(c6.children, e3, f2, b2);
      case za:
        g2 = 8;
        e3 |= 8;
        break;
      case Aa:
        return a = Bg(12, c6, b2, e3 | 2), a.elementType = Aa, a.lanes = f2, a;
      case Ea:
        return a = Bg(13, c6, b2, e3), a.elementType = Ea, a.lanes = f2, a;
      case Fa:
        return a = Bg(19, c6, b2, e3), a.elementType = Fa, a.lanes = f2, a;
      case Ia:
        return pj(c6, e3, f2, b2);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p$4(130, null == a ? a : typeof a, ""));
    }
    b2 = Bg(g2, c6, b2, e3);
    b2.elementType = a;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a, b2, c6, d2) {
    a = Bg(7, a, d2, b2);
    a.lanes = c6;
    return a;
  }
  function pj(a, b2, c6, d2) {
    a = Bg(22, a, d2, b2);
    a.elementType = Ia;
    a.lanes = c6;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b2, c6) {
    a = Bg(6, a, null, b2);
    a.lanes = c6;
    return a;
  }
  function Sg(a, b2, c6) {
    b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
    b2.lanes = c6;
    b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b2;
  }
  function al(a, b2, c6, d2, e3) {
    this.tag = b2;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e3;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b2, c6, d2, e3, f2, g2, h2, k2) {
    a = new al(a, b2, c6, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a.current = f2;
    f2.stateNode = a;
    f2.memoizedState = { element: d2, isDehydrated: c6, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a;
  }
  function cl(a, b2, c6) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c6 };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p$4(170));
      var b2 = a;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p$4(171));
    }
    if (1 === a.tag) {
      var c6 = a.type;
      if (Zf(c6)) return bg(a, c6, b2);
    }
    return b2;
  }
  function el(a, b2, c6, d2, e3, f2, g2, h2, k2) {
    a = bl(c6, d2, true, a, e3, f2, g2, h2, k2);
    a.context = dl(null);
    c6 = a.current;
    d2 = R();
    e3 = yi(c6);
    f2 = mh(d2, e3);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c6, f2, e3);
    a.current.lanes = e3;
    Ac(a, e3, d2);
    Dk(a, d2);
    return a;
  }
  function fl(a, b2, c6, d2) {
    var e3 = b2.current, f2 = R(), g2 = yi(e3);
    c6 = dl(c6);
    null === b2.context ? b2.context = c6 : b2.pendingContext = c6;
    b2 = mh(f2, g2);
    b2.payload = { element: a };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a = nh(e3, b2, g2);
    null !== a && (gi(a, e3, g2, f2), oh(a, e3, g2));
    return g2;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b2) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c6 = a.retryLane;
      a.retryLane = 0 !== c6 && c6 < b2 ? c6 : b2;
    }
  }
  function il(a, b2) {
    hl(a, b2);
    (a = a.alternate) && hl(a, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p$4(409));
    fl(a, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b2 = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b2 = Hc();
      a = { blockedOn: null, target: a, priority: b2 };
      for (var c6 = 0; c6 < Qc.length && 0 !== b2 && b2 < Qc[c6].priority; c6++) ;
      Qc.splice(c6, 0, a);
      0 === c6 && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b2, c6, d2, e3) {
    if (e3) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a2 = gl(g2);
          f2.call(a2);
        };
      }
      var g2 = el(b2, d2, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g2;
      a[uf] = g2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g2;
    }
    for (; e3 = a.lastChild; ) a.removeChild(e3);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a2 = gl(k2);
        h2.call(a2);
      };
    }
    var k2 = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k2;
    a[uf] = k2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b2, k2, c6, d2);
    });
    return k2;
  }
  function rl(a, b2, c6, d2, e3) {
    var f2 = c6._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e3) {
        var h2 = e3;
        e3 = function() {
          var a2 = gl(g2);
          h2.call(a2);
        };
      }
      fl(b2, g2, a, e3);
    } else g2 = ql(c6, b2, a, e3, d2);
    return gl(g2);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b2 = a.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c6 = tc(b2.pendingLanes);
          0 !== c6 && (Cc(b2, c6 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a, 1);
          if (null !== b3) {
            var c7 = R();
            gi(b3, a, 1, c7);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b2 = ih(a, 134217728);
      if (null !== b2) {
        var c6 = R();
        gi(b2, a, 134217728, c6);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b2 = yi(a), c6 = ih(a, b2);
      if (null !== c6) {
        var d2 = R();
        gi(c6, a, b2, d2);
      }
      il(a, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b2) {
    var c6 = C;
    try {
      return C = a, b2();
    } finally {
      C = c6;
    }
  };
  yb = function(a, b2, c6) {
    switch (b2) {
      case "input":
        bb(a, c6);
        b2 = c6.name;
        if ("radio" === c6.type && null != b2) {
          for (c6 = a; c6.parentNode; ) c6 = c6.parentNode;
          c6 = c6.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c6.length; b2++) {
            var d2 = c6[b2];
            if (d2 !== a && d2.form === a.form) {
              var e3 = Db(d2);
              if (!e3) throw Error(p$4(90));
              Wa(d2);
              bb(d2, e3);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c6);
        break;
      case "select":
        b2 = c6.value, null != b2 && fb(a, !!c6.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b2) {
    var c6 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2)) throw Error(p$4(200));
    return cl(a, b2, null, c6);
  };
  reactDom_production_min.createRoot = function(a, b2) {
    if (!nl(a)) throw Error(p$4(299));
    var c6 = false, d2 = "", e3 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c6 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
    b2 = bl(a, 1, false, null, null, c6, false, d2, e3);
    a[uf] = b2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b2 = a._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a.render) throw Error(p$4(188));
      a = Object.keys(a).join(",");
      throw Error(p$4(268, a));
    }
    a = Zb(b2);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b2, c6) {
    if (!ol(b2)) throw Error(p$4(200));
    return rl(null, a, b2, true, c6);
  };
  reactDom_production_min.hydrateRoot = function(a, b2, c6) {
    if (!nl(a)) throw Error(p$4(405));
    var d2 = null != c6 && c6.hydratedSources || null, e3 = false, f2 = "", g2 = kl;
    null !== c6 && void 0 !== c6 && (true === c6.unstable_strictMode && (e3 = true), void 0 !== c6.identifierPrefix && (f2 = c6.identifierPrefix), void 0 !== c6.onRecoverableError && (g2 = c6.onRecoverableError));
    b2 = el(b2, null, a, 1, null != c6 ? c6 : null, e3, false, f2, g2);
    a[uf] = b2.current;
    sf(a);
    if (d2) for (a = 0; a < d2.length; a++) c6 = d2[a], e3 = c6._getVersion, e3 = e3(c6._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c6, e3] : b2.mutableSourceEagerHydrationData.push(
      c6,
      e3
    );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a, b2, c6) {
    if (!ol(b2)) throw Error(p$4(200));
    return rl(null, a, b2, false, c6);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p$4(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c6, d2) {
    if (!ol(c6)) throw Error(p$4(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p$4(38));
    return rl(a, b2, c6, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  var reactDomExports = reactDom.exports;
  var createRoot;
  var m$3 = reactDomExports;
  {
    createRoot = m$3.createRoot;
    m$3.hydrateRoot;
  }
  function r$2(e3) {
    var t2, f2, n2 = "";
    if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
    else if ("object" == typeof e3) if (Array.isArray(e3)) {
      var o = e3.length;
      for (t2 = 0; t2 < o; t2++) e3[t2] && (f2 = r$2(e3[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e3) e3[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e3, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e3 = arguments[f2]) && (t2 = r$2(e3)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function composeClasses(slots, getUtilityClass, classes = void 0) {
    const output = {};
    for (const slotName in slots) {
      const slot = slots[slotName];
      let buffer = "";
      let start2 = true;
      for (let i = 0; i < slot.length; i += 1) {
        const value = slot[i];
        if (value) {
          buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
          start2 = false;
          if (classes && classes[value]) {
            buffer += " " + classes[value];
          }
        }
      }
      output[slotName] = buffer;
    }
    return output;
  }
  function formatMuiErrorMessage(code, ...args) {
    const url = new URL(`https://mui.com/production-error/?code=${code}`);
    args.forEach((arg2) => url.searchParams.append("args[]", arg2));
    return `Minified MUI error #${code}; visit ${url} for the full message.`;
  }
  function clamp$1(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
    return Math.max(min2, Math.min(val, max2));
  }
  function clampWrapper(value, min2 = 0, max2 = 1) {
    return clamp$1(value, min2, max2);
  }
  function hexToRgb(color2) {
    color2 = color2.slice(1);
    const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors3 = color2.match(re2);
    if (colors3 && colors3[0].length === 1) {
      colors3 = colors3.map((n2) => n2 + n2);
    }
    return colors3 ? `rgb${colors3.length === 4 ? "a" : ""}(${colors3.map((n2, index) => {
      return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
    }).join(", ")})` : "";
  }
  function decomposeColor(color2) {
    if (color2.type) {
      return color2;
    }
    if (color2.charAt(0) === "#") {
      return decomposeColor(hexToRgb(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
      throw new Error(formatMuiErrorMessage(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
      values2 = values2.split(" ");
      colorSpace = values2.shift();
      if (values2.length === 4 && values2[3].charAt(0) === "/") {
        values2[3] = values2[3].slice(1);
      }
      if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
        throw new Error(formatMuiErrorMessage(10, colorSpace));
      }
    } else {
      values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
      type,
      values: values2,
      colorSpace
    };
  }
  const colorChannel = (color2) => {
    const decomposedColor = decomposeColor(color2);
    return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
  };
  const private_safeColorChannel = (color2, warning) => {
    try {
      return colorChannel(color2);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color2;
    }
  };
  function recomposeColor(color2) {
    const {
      type,
      colorSpace
    } = color2;
    let {
      values: values2
    } = color2;
    if (type.includes("rgb")) {
      values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
    } else if (type.includes("hsl")) {
      values2[1] = `${values2[1]}%`;
      values2[2] = `${values2[2]}%`;
    }
    if (type.includes("color")) {
      values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
      values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
  }
  function hslToRgb$1(color2) {
    color2 = decomposeColor(color2);
    const {
      values: values2
    } = color2;
    const h2 = values2[0];
    const s = values2[1] / 100;
    const l2 = values2[2] / 100;
    const a = s * Math.min(l2, 1 - l2);
    const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
    let type = "rgb";
    const rgb2 = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
    if (color2.type === "hsla") {
      type += "a";
      rgb2.push(values2[3]);
    }
    return recomposeColor({
      type,
      values: rgb2
    });
  }
  function getLuminance(color2) {
    color2 = decomposeColor(color2);
    let rgb2 = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb$1(color2)).values : color2.values;
    rgb2 = rgb2.map((val) => {
      if (color2.type !== "color") {
        val /= 255;
      }
      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb2[0] + 0.7152 * rgb2[1] + 0.0722 * rgb2[2]).toFixed(3));
  }
  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function alpha(color2, value) {
    color2 = decomposeColor(color2);
    value = clampWrapper(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
      color2.type += "a";
    }
    if (color2.type === "color") {
      color2.values[3] = `/${value}`;
    } else {
      color2.values[3] = value;
    }
    return recomposeColor(color2);
  }
  function private_safeAlpha(color2, value, warning) {
    try {
      return alpha(color2, value);
    } catch (error) {
      return color2;
    }
  }
  function darken(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clampWrapper(coefficient);
    if (color2.type.includes("hsl")) {
      color2.values[2] *= 1 - coefficient;
    } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor(color2);
  }
  function private_safeDarken(color2, coefficient, warning) {
    try {
      return darken(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function lighten(color2, coefficient) {
    color2 = decomposeColor(color2);
    coefficient = clampWrapper(coefficient);
    if (color2.type.includes("hsl")) {
      color2.values[2] += (100 - color2.values[2]) * coefficient;
    } else if (color2.type.includes("rgb")) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (255 - color2.values[i]) * coefficient;
      }
    } else if (color2.type.includes("color")) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (1 - color2.values[i]) * coefficient;
      }
    }
    return recomposeColor(color2);
  }
  function private_safeLighten(color2, coefficient, warning) {
    try {
      return lighten(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function emphasize(color2, coefficient = 0.15) {
    return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
  }
  function private_safeEmphasize(color2, coefficient, warning) {
    try {
      return emphasize(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function capitalize(string) {
    if (typeof string !== "string") {
      throw new Error(formatMuiErrorMessage(7));
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  function isPlainObject$2(item) {
    if (typeof item !== "object" || item === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(item);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
  }
  function deepClone(source) {
    if (!isPlainObject$2(source)) {
      return source;
    }
    const output = {};
    Object.keys(source).forEach((key) => {
      output[key] = deepClone(source[key]);
    });
    return output;
  }
  function deepmerge(target, source, options = {
    clone: true
  }) {
    const output = options.clone ? {
      ...target
    } : target;
    if (isPlainObject$2(target) && isPlainObject$2(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject$2(source[key]) && // Avoid prototype pollution
        Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$2(target[key])) {
          output[key] = deepmerge(target[key], source[key], options);
        } else if (options.clone) {
          output[key] = isPlainObject$2(source[key]) ? deepClone(source[key]) : source[key];
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }
  function merge(acc, item) {
    if (!item) {
      return acc;
    }
    return deepmerge(acc, item, {
      clone: false
      // No need to clone deep, it's way faster.
    });
  }
  function sortContainerQueries(theme, css2) {
    if (!theme.containerQueries) {
      return css2;
    }
    const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b2) => {
      var _a, _b;
      const regex = /min-width:\s*([0-9.]+)/;
      return +(((_a = a.match(regex)) == null ? void 0 : _a[1]) || 0) - +(((_b = b2.match(regex)) == null ? void 0 : _b[1]) || 0);
    });
    if (!sorted.length) {
      return css2;
    }
    return sorted.reduce((acc, key) => {
      const value = css2[key];
      delete acc[key];
      acc[key] = value;
      return acc;
    }, {
      ...css2
    });
  }
  function isCqShorthand(breakpointKeys, value) {
    return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
  }
  function getContainerQuery(theme, shorthand) {
    const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
    if (!matches) {
      return null;
    }
    const [, containerQuery, containerName] = matches;
    const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
    return theme.containerQueries(containerName).up(value);
  }
  function cssContainerQueries(themeInput) {
    const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
    function attachCq(node22, name) {
      node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
      node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
      node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
      node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
      node22.not = (...args) => {
        const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
        if (result.includes("not all and")) {
          return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
        }
        return result;
      };
    }
    const node2 = {};
    const containerQueries = (name) => {
      attachCq(node2, name);
      return node2;
    };
    attachCq(containerQueries);
    return {
      ...themeInput,
      containerQueries
    };
  }
  const values$1 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  };
  const defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (key) => `@media (min-width:${values$1[key]}px)`
  };
  const defaultContainerQueries = {
    containerQueries: (containerName) => ({
      up: (key) => {
        let result = typeof key === "number" ? key : values$1[key] || key;
        if (typeof result === "number") {
          result = `${result}px`;
        }
        return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
      }
    })
  };
  function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }
    if (typeof propValue === "object") {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
          const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
          if (containerKey) {
            acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          }
        } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
          const mediaKey = themeBreakpoints.up(breakpoint);
          acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        } else {
          const cssKey = breakpoint;
          acc[cssKey] = propValue[cssKey];
        }
        return acc;
      }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
  }
  function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _a;
    const breakpointsInOrder = (_a = breakpointsInput.keys) == null ? void 0 : _a.reduce((acc, key) => {
      const breakpointStyleKey = breakpointsInput.up(key);
      acc[breakpointStyleKey] = {};
      return acc;
    }, {});
    return breakpointsInOrder || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style2) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
      if (isBreakpointUnused) {
        delete acc[key];
      }
      return acc;
    }, style2);
  }
  function getPath(obj, path, checkVars = true) {
    if (!path || typeof path !== "string") {
      return null;
    }
    if (obj && obj.vars && checkVars) {
      const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
      if (val != null) {
        return val;
      }
    }
    return path.split(".").reduce((acc, item) => {
      if (acc && acc[item] != null) {
        return acc[item];
      }
      return null;
    }, obj);
  }
  function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;
    if (typeof themeMapping === "function") {
      value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
      value = themeMapping[propValueFinal] || userValue;
    } else {
      value = getPath(themeMapping, propValueFinal) || userValue;
    }
    if (transform) {
      value = transform(value, userValue, themeMapping);
    }
    return value;
  }
  function style$1(options) {
    const {
      prop,
      cssProperty = options.prop,
      themeKey,
      transform
    } = options;
    const fn = (props) => {
      if (props[prop] == null) {
        return null;
      }
      const propValue = props[prop];
      const theme = props.theme;
      const themeMapping = getPath(theme, themeKey) || {};
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn.propTypes = {};
    fn.filterProps = [prop];
    return fn;
  }
  function memoize$1(fn) {
    const cache = {};
    return (arg2) => {
      if (cache[arg2] === void 0) {
        cache[arg2] = fn(arg2);
      }
      return cache[arg2];
    };
  }
  const properties = {
    m: "margin",
    p: "padding"
  };
  const directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  };
  const aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  };
  const getCssProperties = memoize$1((prop) => {
    if (prop.length > 2) {
      if (aliases[prop]) {
        prop = aliases[prop];
      } else {
        return [prop];
      }
    }
    const [a, b2] = prop.split("");
    const property = properties[a];
    const direction = directions[b2] || "";
    return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
  });
  const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
  const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...marginKeys, ...paddingKeys];
  function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
    if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
      return (val) => {
        if (typeof val === "string") {
          return val;
        }
        if (typeof themeSpacing === "string") {
          return `calc(${val} * ${themeSpacing})`;
        }
        return themeSpacing * val;
      };
    }
    if (Array.isArray(themeSpacing)) {
      return (val) => {
        if (typeof val === "string") {
          return val;
        }
        const abs2 = Math.abs(val);
        const transformed = themeSpacing[abs2];
        if (val >= 0) {
          return transformed;
        }
        if (typeof transformed === "number") {
          return -transformed;
        }
        return `-${transformed}`;
      };
    }
    if (typeof themeSpacing === "function") {
      return themeSpacing;
    }
    return () => void 0;
  }
  function createUnarySpacing(theme) {
    return createUnaryUnit(theme, "spacing", 8);
  }
  function getValue(transformer2, propValue) {
    if (typeof propValue === "string" || propValue == null) {
      return propValue;
    }
    return transformer2(propValue);
  }
  function getStyleFromPropValue(cssProperties, transformer2) {
    return (propValue) => cssProperties.reduce((acc, cssProperty) => {
      acc[cssProperty] = getValue(transformer2, propValue);
      return acc;
    }, {});
  }
  function resolveCssProperty(props, keys, prop, transformer2) {
    if (!keys.includes(prop)) {
      return null;
    }
    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer2);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }
  function style(props, keys) {
    const transformer2 = createUnarySpacing(props.theme);
    return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer2)).reduce(merge, {});
  }
  function margin(props) {
    return style(props, marginKeys);
  }
  margin.propTypes = {};
  margin.filterProps = marginKeys;
  function padding(props) {
    return style(props, paddingKeys);
  }
  padding.propTypes = {};
  padding.filterProps = paddingKeys;
  function compose$1(...styles2) {
    const handlers = styles2.reduce((acc, style2) => {
      style2.filterProps.forEach((prop) => {
        acc[prop] = style2;
      });
      return acc;
    }, {});
    const fn = (props) => {
      return Object.keys(props).reduce((acc, prop) => {
        if (handlers[prop]) {
          return merge(acc, handlers[prop](props));
        }
        return acc;
      }, {});
    };
    fn.propTypes = {};
    fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
    return fn;
  }
  function borderTransform(value) {
    if (typeof value !== "number") {
      return value;
    }
    return `${value}px solid`;
  }
  function createBorderStyle(prop, transform) {
    return style$1({
      prop,
      themeKey: "borders",
      transform
    });
  }
  const border = createBorderStyle("border", borderTransform);
  const borderTop = createBorderStyle("borderTop", borderTransform);
  const borderRight = createBorderStyle("borderRight", borderTransform);
  const borderBottom = createBorderStyle("borderBottom", borderTransform);
  const borderLeft = createBorderStyle("borderLeft", borderTransform);
  const borderColor = createBorderStyle("borderColor");
  const borderTopColor = createBorderStyle("borderTopColor");
  const borderRightColor = createBorderStyle("borderRightColor");
  const borderBottomColor = createBorderStyle("borderBottomColor");
  const borderLeftColor = createBorderStyle("borderLeftColor");
  const outline = createBorderStyle("outline", borderTransform);
  const outlineColor = createBorderStyle("outlineColor");
  const borderRadius = (props) => {
    if (props.borderRadius !== void 0 && props.borderRadius !== null) {
      const transformer2 = createUnaryUnit(props.theme, "shape.borderRadius", 4);
      const styleFromPropValue = (propValue) => ({
        borderRadius: getValue(transformer2, propValue)
      });
      return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }
    return null;
  };
  borderRadius.propTypes = {};
  borderRadius.filterProps = ["borderRadius"];
  compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
  const gap = (props) => {
    if (props.gap !== void 0 && props.gap !== null) {
      const transformer2 = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        gap: getValue(transformer2, propValue)
      });
      return handleBreakpoints(props, props.gap, styleFromPropValue);
    }
    return null;
  };
  gap.propTypes = {};
  gap.filterProps = ["gap"];
  const columnGap = (props) => {
    if (props.columnGap !== void 0 && props.columnGap !== null) {
      const transformer2 = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        columnGap: getValue(transformer2, propValue)
      });
      return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }
    return null;
  };
  columnGap.propTypes = {};
  columnGap.filterProps = ["columnGap"];
  const rowGap = (props) => {
    if (props.rowGap !== void 0 && props.rowGap !== null) {
      const transformer2 = createUnaryUnit(props.theme, "spacing", 8);
      const styleFromPropValue = (propValue) => ({
        rowGap: getValue(transformer2, propValue)
      });
      return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }
    return null;
  };
  rowGap.propTypes = {};
  rowGap.filterProps = ["rowGap"];
  const gridColumn = style$1({
    prop: "gridColumn"
  });
  const gridRow = style$1({
    prop: "gridRow"
  });
  const gridAutoFlow = style$1({
    prop: "gridAutoFlow"
  });
  const gridAutoColumns = style$1({
    prop: "gridAutoColumns"
  });
  const gridAutoRows = style$1({
    prop: "gridAutoRows"
  });
  const gridTemplateColumns = style$1({
    prop: "gridTemplateColumns"
  });
  const gridTemplateRows = style$1({
    prop: "gridTemplateRows"
  });
  const gridTemplateAreas = style$1({
    prop: "gridTemplateAreas"
  });
  const gridArea = style$1({
    prop: "gridArea"
  });
  compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
  function paletteTransform(value, userValue) {
    if (userValue === "grey") {
      return userValue;
    }
    return value;
  }
  const color$1 = style$1({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
  });
  const bgcolor = style$1({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  const backgroundColor = style$1({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  compose$1(color$1, bgcolor, backgroundColor);
  function sizingTransform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
  }
  const width = style$1({
    prop: "width",
    transform: sizingTransform
  });
  const maxWidth = (props) => {
    if (props.maxWidth !== void 0 && props.maxWidth !== null) {
      const styleFromPropValue = (propValue) => {
        var _a, _b, _c, _d, _e;
        const breakpoint = ((_c = (_b = (_a = props.theme) == null ? void 0 : _a.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values$1[propValue];
        if (!breakpoint) {
          return {
            maxWidth: sizingTransform(propValue)
          };
        }
        if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
          return {
            maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
          };
        }
        return {
          maxWidth: breakpoint
        };
      };
      return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }
    return null;
  };
  maxWidth.filterProps = ["maxWidth"];
  const minWidth = style$1({
    prop: "minWidth",
    transform: sizingTransform
  });
  const height = style$1({
    prop: "height",
    transform: sizingTransform
  });
  const maxHeight = style$1({
    prop: "maxHeight",
    transform: sizingTransform
  });
  const minHeight = style$1({
    prop: "minHeight",
    transform: sizingTransform
  });
  style$1({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
  });
  style$1({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
  });
  const boxSizing = style$1({
    prop: "boxSizing"
  });
  compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
  const defaultSxConfig = {
    // borders
    border: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderTop: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderRight: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderBottom: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderLeft: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: borderTransform
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: borderRadius
    },
    // palette
    color: {
      themeKey: "palette",
      transform: paletteTransform
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: paletteTransform
    },
    backgroundColor: {
      themeKey: "palette",
      transform: paletteTransform
    },
    // spacing
    p: {
      style: padding
    },
    pt: {
      style: padding
    },
    pr: {
      style: padding
    },
    pb: {
      style: padding
    },
    pl: {
      style: padding
    },
    px: {
      style: padding
    },
    py: {
      style: padding
    },
    padding: {
      style: padding
    },
    paddingTop: {
      style: padding
    },
    paddingRight: {
      style: padding
    },
    paddingBottom: {
      style: padding
    },
    paddingLeft: {
      style: padding
    },
    paddingX: {
      style: padding
    },
    paddingY: {
      style: padding
    },
    paddingInline: {
      style: padding
    },
    paddingInlineStart: {
      style: padding
    },
    paddingInlineEnd: {
      style: padding
    },
    paddingBlock: {
      style: padding
    },
    paddingBlockStart: {
      style: padding
    },
    paddingBlockEnd: {
      style: padding
    },
    m: {
      style: margin
    },
    mt: {
      style: margin
    },
    mr: {
      style: margin
    },
    mb: {
      style: margin
    },
    ml: {
      style: margin
    },
    mx: {
      style: margin
    },
    my: {
      style: margin
    },
    margin: {
      style: margin
    },
    marginTop: {
      style: margin
    },
    marginRight: {
      style: margin
    },
    marginBottom: {
      style: margin
    },
    marginLeft: {
      style: margin
    },
    marginX: {
      style: margin
    },
    marginY: {
      style: margin
    },
    marginInline: {
      style: margin
    },
    marginInlineStart: {
      style: margin
    },
    marginInlineEnd: {
      style: margin
    },
    marginBlock: {
      style: margin
    },
    marginBlockStart: {
      style: margin
    },
    marginBlockEnd: {
      style: margin
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: gap
    },
    rowGap: {
      style: rowGap
    },
    columnGap: {
      style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: sizingTransform
    },
    maxWidth: {
      style: maxWidth
    },
    minWidth: {
      transform: sizingTransform
    },
    height: {
      transform: sizingTransform
    },
    maxHeight: {
      transform: sizingTransform
    },
    minHeight: {
      transform: sizingTransform
    },
    boxSizing: {},
    // typography
    font: {
      themeKey: "font"
    },
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  };
  function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object2) => keys.concat(Object.keys(object2)), []);
    const union = new Set(allKeys);
    return objects.every((object2) => union.size === Object.keys(object2).length);
  }
  function callIfFn(maybeFn, arg2) {
    return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
  }
  function unstable_createStyleFunctionSx() {
    function getThemeValue(prop, val, theme, config2) {
      const props = {
        [prop]: val,
        theme
      };
      const options = config2[prop];
      if (!options) {
        return {
          [prop]: val
        };
      }
      const {
        cssProperty = prop,
        themeKey,
        transform,
        style: style2
      } = options;
      if (val == null) {
        return null;
      }
      if (themeKey === "typography" && val === "inherit") {
        return {
          [prop]: val
        };
      }
      const themeMapping = getPath(theme, themeKey) || {};
      if (style2) {
        return style2(props);
      }
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, val, styleFromPropValue);
    }
    function styleFunctionSx2(props) {
      const {
        sx,
        theme = {}
      } = props || {};
      if (!sx) {
        return null;
      }
      const config2 = theme.unstable_sxConfig ?? defaultSxConfig;
      function traverse(sxInput) {
        let sxObject = sxInput;
        if (typeof sxInput === "function") {
          sxObject = sxInput(theme);
        } else if (typeof sxInput !== "object") {
          return sxInput;
        }
        if (!sxObject) {
          return null;
        }
        const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
        const breakpointsKeys = Object.keys(emptyBreakpoints);
        let css2 = emptyBreakpoints;
        Object.keys(sxObject).forEach((styleKey) => {
          const value = callIfFn(sxObject[styleKey], theme);
          if (value !== null && value !== void 0) {
            if (typeof value === "object") {
              if (config2[styleKey]) {
                css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
              } else {
                const breakpointsValues = handleBreakpoints({
                  theme
                }, value, (x2) => ({
                  [styleKey]: x2
                }));
                if (objectsHaveSameKeys(breakpointsValues, value)) {
                  css2[styleKey] = styleFunctionSx2({
                    sx: value,
                    theme
                  });
                } else {
                  css2 = merge(css2, breakpointsValues);
                }
              }
            } else {
              css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
            }
          }
        });
        return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
      }
      return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
    }
    return styleFunctionSx2;
  }
  const styleFunctionSx = unstable_createStyleFunctionSx();
  styleFunctionSx.filterProps = ["sx"];
  const splitProps = (props) => {
    var _a;
    const result = {
      systemProps: {},
      otherProps: {}
    };
    const config2 = ((_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.unstable_sxConfig) ?? defaultSxConfig;
    Object.keys(props).forEach((prop) => {
      if (config2[prop]) {
        result.systemProps[prop] = props[prop];
      } else {
        result.otherProps[prop] = props[prop];
      }
    });
    return result;
  };
  function extendSxProp$1(props) {
    const {
      sx: inSx,
      ...other
    } = props;
    const {
      systemProps,
      otherProps
    } = splitProps(other);
    let finalSx;
    if (Array.isArray(inSx)) {
      finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === "function") {
      finalSx = (...args) => {
        const result = inSx(...args);
        if (!isPlainObject$2(result)) {
          return systemProps;
        }
        return {
          ...systemProps,
          ...result
        };
      };
    } else {
      finalSx = {
        ...systemProps,
        ...inSx
      };
    }
    return {
      ...otherProps,
      sx: finalSx
    };
  }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var t2 = arguments[e3];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends.apply(null, arguments);
  }
  function memoize(fn) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg2) {
      if (cache[arg2] === void 0) cache[arg2] = fn(arg2);
      return cache[arg2];
    };
  }
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  var isDevelopment$2 = false;
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? !isDevelopment$2 : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e3) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs$1 = Math.abs;
  var from = String.fromCharCode;
  var assign$1 = Object.assign;
  function hash$2(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append$1(value, array2) {
    return array2.push(value), value;
  }
  function combine(array2, callback) {
    return array2.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy$2(root, props) {
    return assign$1(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek$1() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek$1())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek$1() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        case type:
          return position;
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek$1() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek$1()))
      next();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek$1()) {
            case 42:
            case 47:
              append$1(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset2:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append$1(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append$1(reference2 = ruleset(characters2, root, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append$1(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek$1() === 45)
                characters2 += delimit(next());
              atrule = peek$1(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index; ++i)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs$1(j = points[i])), z2 = value; x2 < size; ++x2)
        if (z2 = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z2;
    return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek$1();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek$1() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek$1() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k2 = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k2++) {
        element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix$1(value, length2) {
    switch (hash$2(value, length2)) {
      case 5103:
        return WEBKIT + "print-" + value + value;
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix$1(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      case 5936:
        switch (charat(value, length2 + 11)) {
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix$1(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$2(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy$2(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
              case "::placeholder":
                return serialize([copy$2(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy$2(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy$2(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize(compile(styles2), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };
  var reactIs$1 = { exports: {} };
  var reactIs_production_min$1 = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$2 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$2 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$1 ? Symbol.for("react.suspense") : 60113, q$3 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$2 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c$1:
          switch (a = a.type, a) {
            case l$2:
            case m$2:
            case e$1:
            case g$2:
            case f$2:
            case p$3:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k$2:
                case n$3:
                case t$2:
                case r$1:
                case h$1:
                  return a;
                default:
                  return u2;
              }
          }
        case d$1:
          return u2;
      }
    }
  }
  function A(a) {
    return z(a) === m$2;
  }
  reactIs_production_min$1.AsyncMode = l$2;
  reactIs_production_min$1.ConcurrentMode = m$2;
  reactIs_production_min$1.ContextConsumer = k$2;
  reactIs_production_min$1.ContextProvider = h$1;
  reactIs_production_min$1.Element = c$1;
  reactIs_production_min$1.ForwardRef = n$3;
  reactIs_production_min$1.Fragment = e$1;
  reactIs_production_min$1.Lazy = t$2;
  reactIs_production_min$1.Memo = r$1;
  reactIs_production_min$1.Portal = d$1;
  reactIs_production_min$1.Profiler = g$2;
  reactIs_production_min$1.StrictMode = f$2;
  reactIs_production_min$1.Suspense = p$3;
  reactIs_production_min$1.isAsyncMode = function(a) {
    return A(a) || z(a) === l$2;
  };
  reactIs_production_min$1.isConcurrentMode = A;
  reactIs_production_min$1.isContextConsumer = function(a) {
    return z(a) === k$2;
  };
  reactIs_production_min$1.isContextProvider = function(a) {
    return z(a) === h$1;
  };
  reactIs_production_min$1.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c$1;
  };
  reactIs_production_min$1.isForwardRef = function(a) {
    return z(a) === n$3;
  };
  reactIs_production_min$1.isFragment = function(a) {
    return z(a) === e$1;
  };
  reactIs_production_min$1.isLazy = function(a) {
    return z(a) === t$2;
  };
  reactIs_production_min$1.isMemo = function(a) {
    return z(a) === r$1;
  };
  reactIs_production_min$1.isPortal = function(a) {
    return z(a) === d$1;
  };
  reactIs_production_min$1.isProfiler = function(a) {
    return z(a) === g$2;
  };
  reactIs_production_min$1.isStrictMode = function(a) {
    return z(a) === f$2;
  };
  reactIs_production_min$1.isSuspense = function(a) {
    return z(a) === p$3;
  };
  reactIs_production_min$1.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$2 || a === g$2 || a === f$2 || a === p$3 || a === q$3 || "object" === typeof a && null !== a && (a.$$typeof === t$2 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k$2 || a.$$typeof === n$3 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$2);
  };
  reactIs_production_min$1.typeOf = z;
  {
    reactIs$1.exports = reactIs_production_min$1;
  }
  var reactIsExports = reactIs$1.exports;
  var reactIs = reactIsExports;
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag2 === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
    registerStyles(cache, serialized, isStringTag2);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current2 = serialized;
      do {
        cache.insert(serialized === current2 ? "." + className : "", current2, cache.sheet, true);
        current2 = current2.next;
      } while (current2 !== void 0);
    }
  };
  function murmur2(str) {
    var h2 = 0;
    var k2, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var isDevelopment$1 = false;
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = serializedStyles.styles + ";";
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles2 += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles2 += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
      name,
      styles: styles2,
      next: cursor
    };
  }
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = ReactOriginal["useInsertionEffect"] ? ReactOriginal["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var cache = reactExports.useContext(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var keyframes = function keyframes2() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  };
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var isDevelopment = false;
  var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag2);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag2);
    });
    return null;
  };
  var createStyled$1 = function createStyled2(tag, options) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles2.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles2.push.apply(styles2, args);
      } else {
        styles2.push(args[0][0]);
        var len = args.length;
        var i = 1;
        for (; i < len; i++) {
          styles2.push(args[i], args[0][i]);
        }
      }
      var Styled = withEmotionCache(function(props, cache, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = reactExports.useContext(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as") continue;
          if (finalShouldForwardProp(_key)) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        if (ref) {
          newProps.ref = ref;
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
          cache,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles2;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && isDevelopment) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles2);
      };
      return Styled;
    };
  };
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled$1.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n$2 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
  function q$2(c6, a, g2) {
    var b2, d2 = {}, e3 = null, h2 = null;
    void 0 !== g2 && (e3 = "" + g2);
    void 0 !== a.key && (e3 = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b2 in a) m$1.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c6 && c6.defaultProps) for (b2 in a = c6.defaultProps, a) void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: k$1, type: c6, key: e3, ref: h2, props: d2, _owner: n$2.current };
  }
  reactJsxRuntime_production_min.Fragment = l$1;
  reactJsxRuntime_production_min.jsx = q$2;
  reactJsxRuntime_production_min.jsxs = q$2;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  /**
   * @mui/styled-engine v6.1.6
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function styled$1(tag, options) {
    const stylesFactory = newStyled(tag, options);
    return stylesFactory;
  }
  function internal_mutateStyles(tag, processor) {
    if (Array.isArray(tag.__emotion_styles)) {
      tag.__emotion_styles = processor(tag.__emotion_styles);
    }
  }
  const wrapper = [];
  function internal_serializeStyles(styles2) {
    wrapper[0] = styles2;
    return serializeStyles(wrapper);
  }
  const sortBreakpointsValues = (values2) => {
    const breakpointsAsArray = Object.keys(values2).map((key) => ({
      key,
      val: values2[key]
    })) || [];
    breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
    return breakpointsAsArray.reduce((acc, obj) => {
      return {
        ...acc,
        [obj.key]: obj.val
      };
    }, {});
  };
  function createBreakpoints(breakpoints) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: values2 = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: unit2 = "px",
      step = 5,
      ...other
    } = breakpoints;
    const sortedValues = sortBreakpointsValues(values2);
    const keys = Object.keys(sortedValues);
    function up(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (min-width:${value}${unit2})`;
    }
    function down(key) {
      const value = typeof values2[key] === "number" ? values2[key] : key;
      return `@media (max-width:${value - step / 100}${unit2})`;
    }
    function between(start2, end2) {
      const endIndex = keys.indexOf(end2);
      return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit2}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit2})`;
    }
    function only(key) {
      if (keys.indexOf(key) + 1 < keys.length) {
        return between(key, keys[keys.indexOf(key) + 1]);
      }
      return up(key);
    }
    function not(key) {
      const keyIndex = keys.indexOf(key);
      if (keyIndex === 0) {
        return up(keys[1]);
      }
      if (keyIndex === keys.length - 1) {
        return down(keys[keyIndex]);
      }
      return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
    }
    return {
      keys,
      values: sortedValues,
      up,
      down,
      between,
      only,
      not,
      unit: unit2,
      ...other
    };
  }
  const shape = {
    borderRadius: 4
  };
  function createSpacing(spacingInput = 8, transform = createUnarySpacing({
    spacing: spacingInput
  })) {
    if (spacingInput.mui) {
      return spacingInput;
    }
    const spacing = (...argsInput) => {
      const args = argsInput.length === 0 ? [1] : argsInput;
      return args.map((argument) => {
        const output = transform(argument);
        return typeof output === "number" ? `${output}px` : output;
      }).join(" ");
    };
    spacing.mui = true;
    return spacing;
  }
  function applyStyles$2(key, styles2) {
    var _a;
    const theme = this;
    if (theme.vars) {
      if (!((_a = theme.colorSchemes) == null ? void 0 : _a[key]) || typeof theme.getColorSchemeSelector !== "function") {
        return {};
      }
      let selector = theme.getColorSchemeSelector(key);
      if (selector === "&") {
        return styles2;
      }
      if (selector.includes("data-") || selector.includes(".")) {
        selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
      }
      return {
        [selector]: styles2
      };
    }
    if (theme.palette.mode === key) {
      return styles2;
    }
    return {};
  }
  function createTheme$1(options = {}, ...args) {
    const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {},
      ...other
    } = options;
    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing = createSpacing(spacingInput);
    let muiTheme = deepmerge({
      breakpoints,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: {
        mode: "light",
        ...paletteInput
      },
      spacing,
      shape: {
        ...shape,
        ...shapeInput
      }
    }, other);
    muiTheme = cssContainerQueries(muiTheme);
    muiTheme.applyStyles = applyStyles$2;
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = {
      ...defaultSxConfig,
      ...other == null ? void 0 : other.unstable_sxConfig
    };
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  function isObjectEmpty$1(obj) {
    return Object.keys(obj).length === 0;
  }
  function useTheme$2(defaultTheme2 = null) {
    const contextTheme = reactExports.useContext(ThemeContext);
    return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
  }
  const systemDefaultTheme$1 = createTheme$1();
  function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
    return useTheme$2(defaultTheme2);
  }
  const defaultGenerator = (componentName) => componentName;
  const createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
      configure(generator) {
        generate = generator;
      },
      generate(componentName) {
        return generate(componentName);
      },
      reset() {
        generate = defaultGenerator;
      }
    };
  };
  const ClassNameGenerator = createClassNameGenerator();
  const globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClasses[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
  }
  function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
      result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
    });
    return result;
  }
  var reactIs_production_min = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g$1 = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$1 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
  u$1 = Symbol.for("react.module.reference");
  function v$1(a) {
    if ("object" === typeof a && null !== a) {
      var r2 = a.$$typeof;
      switch (r2) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e:
            case m:
            case n$1:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q$1:
                case p$1:
                case g$1:
                  return a;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g$1;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q$1;
  reactIs_production_min.Memo = p$1;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m;
  reactIs_production_min.SuspenseList = n$1;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a) {
    return v$1(a) === h;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return v$1(a) === g$1;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return v$1(a) === l;
  };
  reactIs_production_min.isFragment = function(a) {
    return v$1(a) === d;
  };
  reactIs_production_min.isLazy = function(a) {
    return v$1(a) === q$1;
  };
  reactIs_production_min.isMemo = function(a) {
    return v$1(a) === p$1;
  };
  reactIs_production_min.isPortal = function(a) {
    return v$1(a) === c;
  };
  reactIs_production_min.isProfiler = function(a) {
    return v$1(a) === f;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return v$1(a) === e;
  };
  reactIs_production_min.isSuspense = function(a) {
    return v$1(a) === m;
  };
  reactIs_production_min.isSuspenseList = function(a) {
    return v$1(a) === n$1;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n$1 || a === t$1 || "object" === typeof a && null !== a && (a.$$typeof === q$1 || a.$$typeof === p$1 || a.$$typeof === g$1 || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u$1 || void 0 !== a.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v$1;
  function preprocessStyles(input) {
    const {
      variants,
      ...style2
    } = input;
    const result = {
      variants,
      style: internal_serializeStyles(style2),
      isProcessed: true
    };
    if (result.style === style2) {
      return result;
    }
    if (variants) {
      variants.forEach((variant) => {
        if (typeof variant.style !== "function") {
          variant.style = internal_serializeStyles(variant.style);
        }
      });
    }
    return result;
  }
  const systemDefaultTheme = createTheme$1();
  function shouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  function defaultOverridesResolver(slot) {
    if (!slot) {
      return null;
    }
    return (_props, styles2) => styles2[slot];
  }
  function attachTheme(props, themeId, defaultTheme2) {
    props.theme = isObjectEmpty(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
  }
  function processStyle(props, style2) {
    const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
    if (Array.isArray(resolvedStyle)) {
      return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
    }
    if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
      let rootStyle;
      if (resolvedStyle.isProcessed) {
        rootStyle = resolvedStyle.style;
      } else {
        const {
          variants,
          ...otherStyles
        } = resolvedStyle;
        rootStyle = otherStyles;
      }
      return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
    }
    if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
      return resolvedStyle.style;
    }
    return resolvedStyle;
  }
  function processStyleVariants(props, variants, results = []) {
    var _a;
    let mergedState;
    variantLoop: for (let i = 0; i < variants.length; i += 1) {
      const variant = variants[i];
      if (typeof variant.props === "function") {
        mergedState ?? (mergedState = {
          ...props,
          ...props.ownerState,
          ownerState: props.ownerState
        });
        if (!variant.props(mergedState)) {
          continue;
        }
      } else {
        for (const key in variant.props) {
          if (props[key] !== variant.props[key] && ((_a = props.ownerState) == null ? void 0 : _a[key]) !== variant.props[key]) {
            continue variantLoop;
          }
        }
      }
      if (typeof variant.style === "function") {
        mergedState ?? (mergedState = {
          ...props,
          ...props.ownerState,
          ownerState: props.ownerState
        });
        results.push(variant.style(mergedState));
      } else {
        results.push(variant.style);
      }
    }
    return results;
  }
  function createStyled(input = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme2 = systemDefaultTheme,
      rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
      slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
    } = input;
    function styleAttachTheme(props) {
      attachTheme(props, themeId, defaultTheme2);
    }
    const styled2 = (tag, inputOptions = {}) => {
      internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
      const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
        ...options
      } = inputOptions;
      const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
      );
      const skipSx = inputSkipSx || false;
      let shouldForwardPropOption = shouldForwardProp;
      if (componentSlot === "Root" || componentSlot === "root") {
        shouldForwardPropOption = rootShouldForwardProp2;
      } else if (componentSlot) {
        shouldForwardPropOption = slotShouldForwardProp2;
      } else if (isStringTag(tag)) {
        shouldForwardPropOption = void 0;
      }
      const defaultStyledResolver = styled$1(tag, {
        shouldForwardProp: shouldForwardPropOption,
        label: generateStyledLabel(),
        ...options
      });
      const transformStyle = (style2) => {
        if (typeof style2 === "function" && style2.__emotion_real !== style2) {
          return function styleFunctionProcessor(props) {
            return processStyle(props, style2);
          };
        }
        if (isPlainObject$2(style2)) {
          const serialized = preprocessStyles(style2);
          if (!serialized.variants) {
            return serialized.style;
          }
          return function styleObjectProcessor(props) {
            return processStyle(props, serialized);
          };
        }
        return style2;
      };
      const muiStyledResolver = (...expressionsInput) => {
        const expressionsHead = [];
        const expressionsBody = expressionsInput.map(transformStyle);
        const expressionsTail = [];
        expressionsHead.push(styleAttachTheme);
        if (componentName && overridesResolver) {
          expressionsTail.push(function styleThemeOverrides(props) {
            var _a, _b;
            const theme = props.theme;
            const styleOverrides = (_b = (_a = theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.styleOverrides;
            if (!styleOverrides) {
              return null;
            }
            const resolvedStyleOverrides = {};
            for (const slotKey in styleOverrides) {
              resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
            }
            return overridesResolver(props, resolvedStyleOverrides);
          });
        }
        if (componentName && !skipVariantsResolver) {
          expressionsTail.push(function styleThemeVariants(props) {
            var _a, _b;
            const theme = props.theme;
            const themeVariants = (_b = (_a = theme == null ? void 0 : theme.components) == null ? void 0 : _a[componentName]) == null ? void 0 : _b.variants;
            if (!themeVariants) {
              return null;
            }
            return processStyleVariants(props, themeVariants);
          });
        }
        if (!skipSx) {
          expressionsTail.push(styleFunctionSx);
        }
        if (Array.isArray(expressionsBody[0])) {
          const inputStrings = expressionsBody.shift();
          const placeholdersHead = new Array(expressionsHead.length).fill("");
          const placeholdersTail = new Array(expressionsTail.length).fill("");
          let outputStrings;
          {
            outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
            outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
          }
          expressionsHead.unshift(outputStrings);
        }
        const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
        const Component = defaultStyledResolver(...expressions);
        if (tag.muiName) {
          Component.muiName = tag.muiName;
        }
        return Component;
      };
      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }
      return muiStyledResolver;
    };
    return styled2;
  }
  function generateStyledLabel(componentName, componentSlot) {
    let label;
    return label;
  }
  function isObjectEmpty(object2) {
    for (const _ in object2) {
      return false;
    }
    return true;
  }
  function isStringTag(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96;
  }
  function lowercaseFirstLetter(string) {
    if (!string) {
      return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
  }
  function resolveProps(defaultProps2, props) {
    const output = {
      ...props
    };
    for (const key in defaultProps2) {
      if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
        const propName = key;
        if (propName === "components" || propName === "slots") {
          output[propName] = {
            ...defaultProps2[propName],
            ...output[propName]
          };
        } else if (propName === "componentsProps" || propName === "slotProps") {
          const defaultSlotProps = defaultProps2[propName];
          const slotProps = props[propName];
          if (!slotProps) {
            output[propName] = defaultSlotProps || {};
          } else if (!defaultSlotProps) {
            output[propName] = slotProps;
          } else {
            output[propName] = {
              ...slotProps
            };
            for (const slotKey in defaultSlotProps) {
              if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
                const slotPropName = slotKey;
                output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
              }
            }
          }
        } else if (output[propName] === void 0) {
          output[propName] = defaultProps2[propName];
        }
      }
    }
    return output;
  }
  function getThemeProps$1(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
      return props;
    }
    return resolveProps(theme.components[name].defaultProps, props);
  }
  function useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme2,
    themeId
  }) {
    let theme = useTheme$1(defaultTheme2);
    if (themeId) {
      theme = theme[themeId] || theme;
    }
    return getThemeProps$1({
      theme,
      name,
      props
    });
  }
  const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function debounce$1(func, wait = 166) {
    let timeout;
    function debounced(...args) {
      const later = () => {
        func.apply(this, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }
    debounced.clear = () => {
      clearTimeout(timeout);
    };
    return debounced;
  }
  function ownerDocument(node2) {
    return node2 && node2.ownerDocument || document;
  }
  function ownerWindow(node2) {
    const doc = ownerDocument(node2);
    return doc.defaultView || window;
  }
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }
  let globalId = 0;
  function useGlobalId(idOverride) {
    const [defaultId, setDefaultId] = reactExports.useState(idOverride);
    const id2 = defaultId;
    reactExports.useEffect(() => {
      if (defaultId == null) {
        globalId += 1;
        setDefaultId(`mui-${globalId}`);
      }
    }, [defaultId]);
    return id2;
  }
  const safeReact = {
    ...ReactOriginal
  };
  const maybeReactUseId = safeReact.useId;
  function useId(idOverride) {
    if (maybeReactUseId !== void 0) {
      const reactId = maybeReactUseId();
      return reactId;
    }
    return useGlobalId(idOverride);
  }
  function useControlled({
    controlled,
    default: defaultProp,
    name,
    state = "value"
  }) {
    const {
      current: isControlled
    } = reactExports.useRef(controlled !== void 0);
    const [valueState, setValue] = reactExports.useState(defaultProp);
    const value = isControlled ? controlled : valueState;
    const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }
  function useEventCallback(fn) {
    const ref = reactExports.useRef(fn);
    useEnhancedEffect(() => {
      ref.current = fn;
    });
    return reactExports.useRef((...args) => (
      // @ts-expect-error hide `this`
      (0, ref.current)(...args)
    )).current;
  }
  function useForkRef(...refs) {
    return reactExports.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (instance2) => {
        refs.forEach((ref) => {
          setRef(ref, instance2);
        });
      };
    }, refs);
  }
  const UNINITIALIZED = {};
  function useLazyRef(init, initArg) {
    const ref = reactExports.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = init(initArg);
    }
    return ref;
  }
  const EMPTY = [];
  function useOnMount(fn) {
    reactExports.useEffect(fn, EMPTY);
  }
  class Timeout {
    constructor() {
      __publicField(this, "currentId", null);
      __publicField(this, "clear", () => {
        if (this.currentId !== null) {
          clearTimeout(this.currentId);
          this.currentId = null;
        }
      });
      __publicField(this, "disposeEffect", () => {
        return this.clear;
      });
    }
    static create() {
      return new Timeout();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(delay, fn) {
      this.clear();
      this.currentId = setTimeout(() => {
        this.currentId = null;
        fn();
      }, delay);
    }
  }
  function useTimeout() {
    const timeout = useLazyRef(Timeout.create).current;
    useOnMount(timeout.disposeEffect);
    return timeout;
  }
  function isFocusVisible(element) {
    try {
      return element.matches(":focus-visible");
    } catch (error) {
    }
    return false;
  }
  function isHostComponent(element) {
    return typeof element === "string";
  }
  function appendOwnerState(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent(elementType)) {
      return otherProps;
    }
    return {
      ...otherProps,
      ownerState: {
        ...otherProps.ownerState,
        ...ownerState
      }
    };
  }
  function extractEventHandlers(object2, excludeKeys = []) {
    if (object2 === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object2).filter((prop) => prop.match(/^on[A-Z]/) && typeof object2[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
      result[prop] = object2[prop];
    });
    return result;
  }
  function omitEventHandlers(object2) {
    if (object2 === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object2).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object2[prop] === "function")).forEach((prop) => {
      result[prop] = object2[prop];
    });
    return result;
  }
  function mergeSlotProps(parameters) {
    const {
      getSlotProps,
      additionalProps,
      externalSlotProps,
      externalForwardedProps,
      className
    } = parameters;
    if (!getSlotProps) {
      const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle2 = {
        ...additionalProps == null ? void 0 : additionalProps.style,
        ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
        ...externalSlotProps == null ? void 0 : externalSlotProps.style
      };
      const props2 = {
        ...additionalProps,
        ...externalForwardedProps,
        ...externalSlotProps
      };
      if (joinedClasses2.length > 0) {
        props2.className = joinedClasses2;
      }
      if (Object.keys(mergedStyle2).length > 0) {
        props2.style = mergedStyle2;
      }
      return {
        props: props2,
        internalRef: void 0
      };
    }
    const eventHandlers = extractEventHandlers({
      ...externalForwardedProps,
      ...externalSlotProps
    });
    const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle = {
      ...internalSlotProps == null ? void 0 : internalSlotProps.style,
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props = {
      ...internalSlotProps,
      ...additionalProps,
      ...otherPropsWithoutEventHandlers,
      ...componentsPropsWithoutEventHandlers
    };
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: internalSlotProps.ref
    };
  }
  function resolveComponentProps(componentProps, ownerState, slotState) {
    if (typeof componentProps === "function") {
      return componentProps(ownerState, slotState);
    }
    return componentProps;
  }
  function useSlotProps(parameters) {
    var _a;
    const {
      elementType,
      externalSlotProps,
      ownerState,
      skipResolvingSlotProps = false,
      ...other
    } = parameters;
    const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
    const {
      props: mergedProps,
      internalRef
    } = mergeSlotProps({
      ...other,
      externalSlotProps: resolvedComponentsProps
    });
    const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a = parameters.additionalProps) == null ? void 0 : _a.ref);
    const props = appendOwnerState(elementType, {
      ...mergedProps,
      ref
    }, ownerState);
    return props;
  }
  function getReactElementRef(element) {
    var _a;
    if (parseInt(reactExports.version, 10) >= 19) {
      return ((_a = element == null ? void 0 : element.props) == null ? void 0 : _a.ref) || null;
    }
    return (element == null ? void 0 : element.ref) || null;
  }
  const RtlContext = /* @__PURE__ */ reactExports.createContext();
  const useRtl = () => {
    const value = reactExports.useContext(RtlContext);
    return value ?? false;
  };
  const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
  function getThemeProps(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name]) {
      return props;
    }
    const config2 = theme.components[name];
    if (config2.defaultProps) {
      return resolveProps(config2.defaultProps, props);
    }
    if (!config2.styleOverrides && !config2.variants) {
      return resolveProps(config2, props);
    }
    return props;
  }
  function useDefaultProps$1({
    props,
    name
  }) {
    const ctx2 = reactExports.useContext(PropsContext);
    return getThemeProps({
      props,
      name,
      theme: {
        components: ctx2
      }
    });
  }
  const arg = {
    theme: void 0
  };
  function unstable_memoTheme(styleFn) {
    let lastValue;
    let lastTheme;
    return function styleMemoized(props) {
      let value = lastValue;
      if (value === void 0 || props.theme !== lastTheme) {
        arg.theme = props.theme;
        value = preprocessStyles(styleFn(arg));
        lastValue = value;
        lastTheme = props.theme;
      }
      return value;
    };
  }
  function createGetCssVar$1(prefix2 = "") {
    function appendVar(...vars) {
      if (!vars.length) {
        return "";
      }
      const value = vars[0];
      if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
        return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
      }
      return `, ${value}`;
    }
    const getCssVar = (field, ...fallbacks) => {
      return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
    };
    return getCssVar;
  }
  const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
    let temp = obj;
    keys.forEach((k2, index) => {
      if (index === keys.length - 1) {
        if (Array.isArray(temp)) {
          temp[Number(k2)] = value;
        } else if (temp && typeof temp === "object") {
          temp[k2] = value;
        }
      } else if (temp && typeof temp === "object") {
        if (!temp[k2]) {
          temp[k2] = arrayKeys.includes(k2) ? [] : {};
        }
        temp = temp[k2];
      }
    });
  };
  const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
    function recurse(object2, parentKeys = [], arrayKeys = []) {
      Object.entries(object2).forEach(([key, value]) => {
        if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
          if (value !== void 0 && value !== null) {
            if (typeof value === "object" && Object.keys(value).length > 0) {
              recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
            } else {
              callback([...parentKeys, key], value, arrayKeys);
            }
          }
        }
      });
    }
    recurse(obj);
  };
  const getCssValue = (keys, value) => {
    if (typeof value === "number") {
      if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
        return value;
      }
      const lastKey = keys[keys.length - 1];
      if (lastKey.toLowerCase().includes("opacity")) {
        return value;
      }
      return `${value}px`;
    }
    return value;
  };
  function cssVarsParser(theme, options) {
    const {
      prefix: prefix2,
      shouldSkipGeneratingVar: shouldSkipGeneratingVar2
    } = options || {};
    const css2 = {};
    const vars = {};
    const varsWithDefaults = {};
    walkObjectDeep(
      theme,
      (keys, value, arrayKeys) => {
        if (typeof value === "string" || typeof value === "number") {
          if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
            const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
            const resolvedValue = getCssValue(keys, value);
            Object.assign(css2, {
              [cssVar]: resolvedValue
            });
            assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
            assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
          }
        }
      },
      (keys) => keys[0] === "vars"
      // skip 'vars/*' paths
    );
    return {
      css: css2,
      vars,
      varsWithDefaults
    };
  }
  function prepareCssVars(theme, parserConfig = {}) {
    const {
      getSelector = defaultGetSelector2,
      disableCssColorScheme,
      colorSchemeSelector: selector
    } = parserConfig;
    const {
      colorSchemes = {},
      components,
      defaultColorScheme = "light",
      ...otherTheme
    } = theme;
    const {
      vars: rootVars,
      css: rootCss,
      varsWithDefaults: rootVarsWithDefaults
    } = cssVarsParser(otherTheme, parserConfig);
    let themeVars = rootVarsWithDefaults;
    const colorSchemesMap = {};
    const {
      [defaultColorScheme]: defaultScheme,
      ...otherColorSchemes
    } = colorSchemes;
    Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
      const {
        vars,
        css: css2,
        varsWithDefaults
      } = cssVarsParser(scheme, parserConfig);
      themeVars = deepmerge(themeVars, varsWithDefaults);
      colorSchemesMap[key] = {
        css: css2,
        vars
      };
    });
    if (defaultScheme) {
      const {
        css: css2,
        vars,
        varsWithDefaults
      } = cssVarsParser(defaultScheme, parserConfig);
      themeVars = deepmerge(themeVars, varsWithDefaults);
      colorSchemesMap[defaultColorScheme] = {
        css: css2,
        vars
      };
    }
    function defaultGetSelector2(colorScheme, cssObject) {
      var _a, _b;
      let rule = selector;
      if (selector === "class") {
        rule = ".%s";
      }
      if (selector === "data") {
        rule = "[data-%s]";
      }
      if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
        rule = `[${selector}="%s"]`;
      }
      if (colorScheme) {
        if (rule === "media") {
          if (theme.defaultColorScheme === colorScheme) {
            return ":root";
          }
          const mode = ((_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || colorScheme;
          return {
            [`@media (prefers-color-scheme: ${mode})`]: {
              ":root": cssObject
            }
          };
        }
        if (rule) {
          if (theme.defaultColorScheme === colorScheme) {
            return `:root, ${rule.replace("%s", String(colorScheme))}`;
          }
          return rule.replace("%s", String(colorScheme));
        }
      }
      return ":root";
    }
    const generateThemeVars = () => {
      let vars = {
        ...rootVars
      };
      Object.entries(colorSchemesMap).forEach(([, {
        vars: schemeVars
      }]) => {
        vars = deepmerge(vars, schemeVars);
      });
      return vars;
    };
    const generateStyleSheets = () => {
      var _a, _b;
      const stylesheets = [];
      const colorScheme = theme.defaultColorScheme || "light";
      function insertStyleSheet(key, css2) {
        if (Object.keys(css2).length) {
          stylesheets.push(typeof key === "string" ? {
            [key]: {
              ...css2
            }
          } : key);
        }
      }
      insertStyleSheet(getSelector(void 0, {
        ...rootCss
      }), rootCss);
      const {
        [colorScheme]: defaultSchemeVal,
        ...other
      } = colorSchemesMap;
      if (defaultSchemeVal) {
        const {
          css: css2
        } = defaultSchemeVal;
        const cssColorSheme = (_b = (_a = colorSchemes[colorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode;
        const finalCss = !disableCssColorScheme && cssColorSheme ? {
          colorScheme: cssColorSheme,
          ...css2
        } : {
          ...css2
        };
        insertStyleSheet(getSelector(colorScheme, {
          ...finalCss
        }), finalCss);
      }
      Object.entries(other).forEach(([key, {
        css: css2
      }]) => {
        var _a2, _b2;
        const cssColorSheme = (_b2 = (_a2 = colorSchemes[key]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode;
        const finalCss = !disableCssColorScheme && cssColorSheme ? {
          colorScheme: cssColorSheme,
          ...css2
        } : {
          ...css2
        };
        insertStyleSheet(getSelector(key, {
          ...finalCss
        }), finalCss);
      });
      return stylesheets;
    };
    return {
      vars: themeVars,
      generateThemeVars,
      generateStyleSheets
    };
  }
  function createGetColorSchemeSelector(selector) {
    return function getColorSchemeSelector(colorScheme) {
      if (selector === "media") {
        return `@media (prefers-color-scheme: ${colorScheme})`;
      }
      if (selector) {
        if (selector.startsWith("data-") && !selector.includes("%s")) {
          return `[${selector}="${colorScheme}"] &`;
        }
        if (selector === "class") {
          return `.${colorScheme} &`;
        }
        if (selector === "data") {
          return `[data-${colorScheme}] &`;
        }
        return `${selector.replace("%s", colorScheme)} &`;
      }
      return "&";
    };
  }
  const common = {
    black: "#000",
    white: "#fff"
  };
  const grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  };
  const purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  };
  const red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  };
  const orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  };
  const blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  };
  const lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  };
  const green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  };
  function getLight() {
    return {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common.white,
        default: common.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
  }
  const light = getLight();
  function getDark() {
    return {
      text: {
        primary: common.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
  const dark = getDark();
  function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === "light") {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === "dark") {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }
  function getDefaultPrimary(mode = "light") {
    if (mode === "dark") {
      return {
        main: blue[200],
        light: blue[50],
        dark: blue[400]
      };
    }
    return {
      main: blue[700],
      light: blue[400],
      dark: blue[800]
    };
  }
  function getDefaultSecondary(mode = "light") {
    if (mode === "dark") {
      return {
        main: purple[200],
        light: purple[50],
        dark: purple[400]
      };
    }
    return {
      main: purple[500],
      light: purple[300],
      dark: purple[700]
    };
  }
  function getDefaultError(mode = "light") {
    if (mode === "dark") {
      return {
        main: red[500],
        light: red[300],
        dark: red[700]
      };
    }
    return {
      main: red[700],
      light: red[400],
      dark: red[800]
    };
  }
  function getDefaultInfo(mode = "light") {
    if (mode === "dark") {
      return {
        main: lightBlue[400],
        light: lightBlue[300],
        dark: lightBlue[700]
      };
    }
    return {
      main: lightBlue[700],
      light: lightBlue[500],
      dark: lightBlue[900]
    };
  }
  function getDefaultSuccess(mode = "light") {
    if (mode === "dark") {
      return {
        main: green[400],
        light: green[300],
        dark: green[700]
      };
    }
    return {
      main: green[800],
      light: green[500],
      dark: green[900]
    };
  }
  function getDefaultWarning(mode = "light") {
    if (mode === "dark") {
      return {
        main: orange[400],
        light: orange[300],
        dark: orange[700]
      };
    }
    return {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: orange[500],
      dark: orange[900]
    };
  }
  function createPalette(palette) {
    const {
      mode = "light",
      contrastThreshold = 3,
      tonalOffset = 0.2,
      ...other
    } = palette;
    const primary = palette.primary || getDefaultPrimary(mode);
    const secondary = palette.secondary || getDefaultSecondary(mode);
    const error = palette.error || getDefaultError(mode);
    const info = palette.info || getDefaultInfo(mode);
    const success = palette.success || getDefaultSuccess(mode);
    const warning = palette.warning || getDefaultWarning(mode);
    function getContrastText(background) {
      const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
      return contrastText;
    }
    const augmentColor = ({
      color: color2,
      name,
      mainShade = 500,
      lightShade = 300,
      darkShade = 700
    }) => {
      color2 = {
        ...color2
      };
      if (!color2.main && color2[mainShade]) {
        color2.main = color2[mainShade];
      }
      if (!color2.hasOwnProperty("main")) {
        throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
      }
      if (typeof color2.main !== "string") {
        throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
      }
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
      if (!color2.contrastText) {
        color2.contrastText = getContrastText(color2.main);
      }
      return color2;
    };
    let modeHydrated;
    if (mode === "light") {
      modeHydrated = getLight();
    } else if (mode === "dark") {
      modeHydrated = getDark();
    }
    const paletteOutput = deepmerge({
      // A collection of common colors.
      common: {
        ...common
      },
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor({
        color: primary,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor({
        color: secondary,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor({
        color: error,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor({
        color: warning,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor({
        color: info,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor({
        color: success,
        name: "success"
      }),
      // The grey colors.
      grey,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset,
      // The light and dark mode object.
      ...modeHydrated
    }, other);
    return paletteOutput;
  }
  function prepareTypographyVars(typography) {
    const vars = {};
    const entries = Object.entries(typography);
    entries.forEach((entry) => {
      const [key, value] = entry;
      if (typeof value === "object") {
        vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
      }
    });
    return vars;
  }
  function createMixins(breakpoints, mixins) {
    return {
      toolbar: {
        minHeight: 56,
        [breakpoints.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [breakpoints.up("sm")]: {
          minHeight: 64
        }
      },
      ...mixins
    };
  }
  function round$1(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  const caseAllCaps = {
    textTransform: "uppercase"
  };
  const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  function createTypography(palette, typography) {
    const {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2,
      ...other
    } = typeof typography === "function" ? typography(palette) : typography;
    const coef = fontSize / 14;
    const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight,
      // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
      // across font-families can cause issues with the kerning.
      ...fontFamily === defaultFontFamily ? {
        letterSpacing: `${round$1(letterSpacing / size)}em`
      } : {},
      ...casing,
      ...allVariants
    });
    const variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return deepmerge({
      htmlFontSize,
      pxToRem,
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold,
      ...variants
    }, other, {
      clone: false
      // No need to clone deep
    });
  }
  const shadowKeyUmbraOpacity = 0.2;
  const shadowKeyPenumbraOpacity = 0.14;
  const shadowAmbientShadowOpacity = 0.12;
  function createShadow(...px) {
    return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
  }
  const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  const easing = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  };
  const duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function formatMs(milliseconds) {
    return `${Math.round(milliseconds)}ms`;
  }
  function getAutoHeightDuration(height2) {
    if (!height2) {
      return 0;
    }
    const constant2 = height2 / 36;
    return Math.min(Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10), 3e3);
  }
  function createTransitions(inputTransitions) {
    const mergedEasing = {
      ...easing,
      ...inputTransitions.easing
    };
    const mergedDuration = {
      ...duration,
      ...inputTransitions.duration
    };
    const create = (props = ["all"], options = {}) => {
      const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0,
        ...other
      } = options;
      return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
    };
    return {
      getAutoHeightDuration,
      create,
      ...inputTransitions,
      easing: mergedEasing,
      duration: mergedDuration
    };
  }
  const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  function isSerializable(val) {
    return isPlainObject$2(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
  }
  function stringifyTheme(baseTheme = {}) {
    const serializableTheme = {
      ...baseTheme
    };
    function serializeTheme(object2) {
      const array2 = Object.entries(object2);
      for (let index = 0; index < array2.length; index++) {
        const [key, value] = array2[index];
        if (!isSerializable(value) || key.startsWith("unstable_")) {
          delete object2[key];
        } else if (isPlainObject$2(value)) {
          object2[key] = {
            ...value
          };
          serializeTheme(object2[key]);
        }
      }
    }
    serializeTheme(serializableTheme);
    return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
  }
  function createThemeNoVars(options = {}, ...args) {
    const {
      breakpoints: breakpointsInput,
      mixins: mixinsInput = {},
      spacing: spacingInput,
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {},
      shape: shapeInput,
      ...other
    } = options;
    if (options.vars) {
      throw new Error(formatMuiErrorMessage(20));
    }
    const palette = createPalette(paletteInput);
    const systemTheme = createTheme$1(options);
    let muiTheme = deepmerge(systemTheme, {
      mixins: createMixins(systemTheme.breakpoints, mixinsInput),
      palette,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: shadows.slice(),
      typography: createTypography(palette, typographyInput),
      transitions: createTransitions(transitionsInput),
      zIndex: {
        ...zIndex
      }
    });
    muiTheme = deepmerge(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = {
      ...defaultSxConfig,
      ...other == null ? void 0 : other.unstable_sxConfig
    };
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    muiTheme.toRuntimeSource = stringifyTheme;
    return muiTheme;
  }
  function getOverlayAlpha(elevation) {
    let alphaValue;
    if (elevation < 1) {
      alphaValue = 5.11916 * elevation ** 2;
    } else {
      alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }
    return Math.round(alphaValue * 10) / 1e3;
  }
  const defaultDarkOverlays = [...Array(25)].map((_, index) => {
    if (index === 0) {
      return "none";
    }
    const overlay = getOverlayAlpha(index);
    return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
  });
  function getOpacity(mode) {
    return {
      inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
      inputUnderline: mode === "dark" ? 0.7 : 0.42,
      switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
      switchTrack: mode === "dark" ? 0.3 : 0.38
    };
  }
  function getOverlays(mode) {
    return mode === "dark" ? defaultDarkOverlays : [];
  }
  function createColorScheme(options) {
    const {
      palette: paletteInput = {
        mode: "light"
      },
      // need to cast to avoid module augmentation test
      opacity,
      overlays,
      ...rest
    } = options;
    const palette = createPalette(paletteInput);
    return {
      palette,
      opacity: {
        ...getOpacity(palette.mode),
        ...opacity
      },
      overlays: overlays || getOverlays(palette.mode),
      ...rest
    };
  }
  function shouldSkipGeneratingVar(keys) {
    var _a;
    return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
    keys[0] === "palette" && !!((_a = keys[1]) == null ? void 0 : _a.match(/(mode|contrastThreshold|tonalOffset)/));
  }
  const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
  const defaultGetSelector = (theme) => (colorScheme, css2) => {
    const root = theme.rootSelector || ":root";
    const selector = theme.colorSchemeSelector;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (theme.defaultColorScheme === colorScheme) {
      if (colorScheme === "dark") {
        const excludedVariables = {};
        excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
          excludedVariables[cssVar] = css2[cssVar];
          delete css2[cssVar];
        });
        if (rule === "media") {
          return {
            [root]: css2,
            [`@media (prefers-color-scheme: dark)`]: {
              [root]: excludedVariables
            }
          };
        }
        if (rule) {
          return {
            [rule.replace("%s", colorScheme)]: excludedVariables,
            [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
          };
        }
        return {
          [root]: {
            ...css2,
            ...excludedVariables
          }
        };
      }
      if (rule && rule !== "media") {
        return `${root}, ${rule.replace("%s", String(colorScheme))}`;
      }
    } else if (colorScheme) {
      if (rule === "media") {
        return {
          [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
            [root]: css2
          }
        };
      }
      if (rule) {
        return rule.replace("%s", String(colorScheme));
      }
    }
    return root;
  };
  function assignNode(obj, keys) {
    keys.forEach((k2) => {
      if (!obj[k2]) {
        obj[k2] = {};
      }
    });
  }
  function setColor(obj, key, defaultValue) {
    if (!obj[key] && defaultValue) {
      obj[key] = defaultValue;
    }
  }
  function toRgb(color2) {
    if (!color2 || !color2.startsWith("hsl")) {
      return color2;
    }
    return hslToRgb$1(color2);
  }
  function setColorChannel(obj, key) {
    if (!(`${key}Channel` in obj)) {
      obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
    }
  }
  function getSpacingVal(spacingInput) {
    if (typeof spacingInput === "number") {
      return `${spacingInput}px`;
    }
    if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
      return spacingInput;
    }
    return "8px";
  }
  const silent = (fn) => {
    try {
      return fn();
    } catch (error) {
    }
    return void 0;
  };
  const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
  function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
    if (!scheme) {
      return void 0;
    }
    scheme = scheme === true ? {} : scheme;
    const mode = colorScheme === "dark" ? "dark" : "light";
    if (!restTheme) {
      colorSchemes[colorScheme] = createColorScheme({
        ...scheme,
        palette: {
          mode,
          ...scheme == null ? void 0 : scheme.palette
        }
      });
      return void 0;
    }
    const {
      palette,
      ...muiTheme
    } = createThemeNoVars({
      ...restTheme,
      palette: {
        mode,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    colorSchemes[colorScheme] = {
      ...scheme,
      palette,
      opacity: {
        ...getOpacity(mode),
        ...scheme == null ? void 0 : scheme.opacity
      },
      overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
    };
    return muiTheme;
  }
  function createThemeWithVars(options = {}, ...args) {
    const {
      colorSchemes: colorSchemesInput = {
        light: true
      },
      defaultColorScheme: defaultColorSchemeInput,
      disableCssColorScheme = false,
      cssVarPrefix = "mui",
      shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
      colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
      rootSelector = ":root",
      ...input
    } = options;
    const firstColorScheme = Object.keys(colorSchemesInput)[0];
    const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
    const getCssVar = createGetCssVar(cssVarPrefix);
    const {
      [defaultColorScheme]: defaultSchemeInput,
      light: builtInLight,
      dark: builtInDark,
      ...customColorSchemes
    } = colorSchemesInput;
    const colorSchemes = {
      ...customColorSchemes
    };
    let defaultScheme = defaultSchemeInput;
    if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
      defaultScheme = true;
    }
    if (!defaultScheme) {
      throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
    }
    const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
    if (builtInLight && !colorSchemes.light) {
      attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
    }
    if (builtInDark && !colorSchemes.dark) {
      attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
    }
    let theme = {
      defaultColorScheme,
      ...muiTheme,
      cssVarPrefix,
      colorSchemeSelector: selector,
      rootSelector,
      getCssVar,
      colorSchemes,
      font: {
        ...prepareTypographyVars(muiTheme.typography),
        ...muiTheme.font
      },
      spacing: getSpacingVal(input.spacing)
    };
    Object.keys(theme.colorSchemes).forEach((key) => {
      const palette = theme.colorSchemes[key].palette;
      const setCssVarColor = (cssVar) => {
        const tokens = cssVar.split("-");
        const color2 = tokens[1];
        const colorToken = tokens[2];
        return getCssVar(cssVar, palette[color2][colorToken]);
      };
      if (palette.mode === "light") {
        setColor(palette.common, "background", "#fff");
        setColor(palette.common, "onBackground", "#000");
      }
      if (palette.mode === "dark") {
        setColor(palette.common, "background", "#000");
        setColor(palette.common, "onBackground", "#fff");
      }
      assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
      if (palette.mode === "light") {
        setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
        setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
        setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
        setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
        setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
        setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
        setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
        setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
        setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
        setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
        setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
        setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
        setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
        setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
        setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
        setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
        setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
        setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
        setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
        setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
        setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
        setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
        setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
        setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
        setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
        setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
        setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
        setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
        setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
        setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
        setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
        setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
        setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
        setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
        setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
        setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
        setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
        setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
        setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
        setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
        setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
        setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
        setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
        const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
        setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
        setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
        setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
        setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
        setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
        setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
        setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
        setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
        setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
        setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
        setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
        setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
        setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
        setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
        setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
      }
      if (palette.mode === "dark") {
        setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
        setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
        setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
        setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
        setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
        setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
        setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
        setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
        setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
        setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
        setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
        setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
        setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
        setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
        setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
        setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
        setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
        setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
        setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
        setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
        setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
        setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
        setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
        setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
        setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
        setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
        setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
        setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
        setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
        setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
        setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
        setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
        setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
        setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
        setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
        setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
        setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
        setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
        setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
        setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
        setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
        setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
        setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
        setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
        setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
        const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
        setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
        setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
        setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
        setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
        setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
        setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
        setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
        setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
        setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
        setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
        setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
        setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
        setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
        setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
        setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
      }
      setColorChannel(palette.background, "default");
      setColorChannel(palette.background, "paper");
      setColorChannel(palette.common, "background");
      setColorChannel(palette.common, "onBackground");
      setColorChannel(palette, "divider");
      Object.keys(palette).forEach((color2) => {
        const colors3 = palette[color2];
        if (colors3 && typeof colors3 === "object") {
          if (colors3.main) {
            setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors3.main)));
          }
          if (colors3.light) {
            setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors3.light)));
          }
          if (colors3.dark) {
            setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors3.dark)));
          }
          if (colors3.contrastText) {
            setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors3.contrastText)));
          }
          if (color2 === "text") {
            setColorChannel(palette[color2], "primary");
            setColorChannel(palette[color2], "secondary");
          }
          if (color2 === "action") {
            if (colors3.active) {
              setColorChannel(palette[color2], "active");
            }
            if (colors3.selected) {
              setColorChannel(palette[color2], "selected");
            }
          }
        }
      });
    });
    theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
    const parserConfig = {
      prefix: cssVarPrefix,
      disableCssColorScheme,
      shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
      getSelector: defaultGetSelector(theme)
    };
    const {
      vars,
      generateThemeVars,
      generateStyleSheets
    } = prepareCssVars(theme, parserConfig);
    theme.vars = vars;
    Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
      theme[key] = value;
    });
    theme.generateThemeVars = generateThemeVars;
    theme.generateStyleSheets = generateStyleSheets;
    theme.generateSpacing = function generateSpacing() {
      return createSpacing(input.spacing, createUnarySpacing(this));
    };
    theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
    theme.spacing = theme.generateSpacing();
    theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
    theme.unstable_sxConfig = {
      ...defaultSxConfig,
      ...input == null ? void 0 : input.unstable_sxConfig
    };
    theme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    theme.toRuntimeSource = stringifyTheme;
    return theme;
  }
  function attachColorScheme(theme, scheme, colorScheme) {
    if (!theme.colorSchemes) {
      return void 0;
    }
    if (colorScheme) {
      theme.colorSchemes[scheme] = {
        ...colorScheme !== true && colorScheme,
        palette: createPalette({
          ...colorScheme === true ? {} : colorScheme.palette,
          mode: scheme
        })
        // cast type to skip module augmentation test
      };
    }
  }
  function createTheme(options = {}, ...args) {
    const {
      palette,
      cssVariables = false,
      colorSchemes: initialColorSchemes = !palette ? {
        light: true
      } : void 0,
      defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
      ...rest
    } = options;
    const defaultColorSchemeInput = initialDefaultColorScheme || "light";
    const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
    const colorSchemesInput = {
      ...initialColorSchemes,
      ...palette ? {
        [defaultColorSchemeInput]: {
          ...typeof defaultScheme !== "boolean" && defaultScheme,
          palette
        }
      } : void 0
    };
    if (cssVariables === false) {
      if (!("colorSchemes" in options)) {
        return createThemeNoVars(options, ...args);
      }
      let paletteOptions = palette;
      if (!("palette" in options)) {
        if (colorSchemesInput[defaultColorSchemeInput]) {
          if (colorSchemesInput[defaultColorSchemeInput] !== true) {
            paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
          } else if (defaultColorSchemeInput === "dark") {
            paletteOptions = {
              mode: "dark"
            };
          }
        }
      }
      const theme = createThemeNoVars({
        ...options,
        palette: paletteOptions
      }, ...args);
      theme.defaultColorScheme = defaultColorSchemeInput;
      theme.colorSchemes = colorSchemesInput;
      if (theme.palette.mode === "light") {
        theme.colorSchemes.light = {
          ...colorSchemesInput.light !== true && colorSchemesInput.light,
          palette: theme.palette
        };
        attachColorScheme(theme, "dark", colorSchemesInput.dark);
      }
      if (theme.palette.mode === "dark") {
        theme.colorSchemes.dark = {
          ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
          palette: theme.palette
        };
        attachColorScheme(theme, "light", colorSchemesInput.light);
      }
      return theme;
    }
    if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
      colorSchemesInput.light = true;
    }
    return createThemeWithVars({
      ...rest,
      colorSchemes: colorSchemesInput,
      defaultColorScheme: defaultColorSchemeInput,
      ...typeof cssVariables !== "boolean" && cssVariables
    }, ...args);
  }
  const defaultTheme = createTheme();
  const THEME_ID = "$$material";
  function useTheme() {
    const theme = useTheme$1(defaultTheme);
    return theme[THEME_ID] || theme;
  }
  function slotShouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
  const styled = createStyled({
    themeId: THEME_ID,
    defaultTheme,
    rootShouldForwardProp
  });
  function internal_createExtendSxProp() {
    return extendSxProp$1;
  }
  const memoTheme = unstable_memoTheme;
  function useDefaultProps(params) {
    return useDefaultProps$1(params);
  }
  function getDividerUtilityClass(slot) {
    return generateUtilityClass("MuiDivider", slot);
  }
  generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
  const useUtilityClasses$p = (ownerState) => {
    const {
      absolute,
      children,
      classes,
      flexItem,
      light: light2,
      orientation,
      textAlign,
      variant
    } = ownerState;
    const slots = {
      root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
    };
    return composeClasses(slots, getDividerUtilityClass, classes);
  };
  const DividerRoot = styled("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
    }
  })(memoTheme(({
    theme
  }) => ({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (theme.vars || theme).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
      props: {
        absolute: true
      },
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        width: "100%"
      }
    }, {
      props: {
        light: true
      },
      style: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)
      }
    }, {
      props: {
        variant: "inset"
      },
      style: {
        marginLeft: 72
      }
    }, {
      props: {
        variant: "middle",
        orientation: "horizontal"
      },
      style: {
        marginLeft: theme.spacing(2),
        marginRight: theme.spacing(2)
      }
    }, {
      props: {
        variant: "middle",
        orientation: "vertical"
      },
      style: {
        marginTop: theme.spacing(1),
        marginBottom: theme.spacing(1)
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        borderBottomWidth: 0,
        borderRightWidth: "thin"
      }
    }, {
      props: {
        flexItem: true
      },
      style: {
        alignSelf: "stretch",
        height: "auto"
      }
    }, {
      props: ({
        ownerState
      }) => !!ownerState.children,
      style: {
        display: "flex",
        textAlign: "center",
        border: 0,
        borderTopStyle: "solid",
        borderLeftStyle: "solid",
        "&::before, &::after": {
          content: '""',
          alignSelf: "center"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.children && ownerState.orientation !== "vertical",
      style: {
        "&::before, &::after": {
          width: "100%",
          borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
          borderTopStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.orientation === "vertical" && ownerState.children,
      style: {
        flexDirection: "column",
        "&::before, &::after": {
          height: "100%",
          borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
          borderLeftStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
      style: {
        "&::before": {
          width: "90%"
        },
        "&::after": {
          width: "10%"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
      style: {
        "&::before": {
          width: "10%"
        },
        "&::after": {
          width: "90%"
        }
      }
    }]
  })));
  const DividerWrapper = styled("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
    }
  })(memoTheme(({
    theme
  }) => ({
    display: "inline-block",
    paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
    paddingRight: `calc(${theme.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "vertical"
      },
      style: {
        paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
      }
    }]
  })));
  const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiDivider"
    });
    const {
      absolute = false,
      children,
      className,
      orientation = "horizontal",
      component = children || orientation === "vertical" ? "div" : "hr",
      flexItem = false,
      light: light2 = false,
      role = component !== "hr" ? "separator" : void 0,
      textAlign = "center",
      variant = "fullWidth",
      ...other
    } = props;
    const ownerState = {
      ...props,
      absolute,
      component,
      flexItem,
      light: light2,
      orientation,
      role,
      textAlign,
      variant
    };
    const classes = useUtilityClasses$p(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, {
      as: component,
      className: clsx(classes.root, className),
      role,
      ref,
      ownerState,
      "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0,
      ...other,
      children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
        className: classes.wrapper,
        ownerState,
        children
      }) : null
    });
  });
  if (Divider) {
    Divider.muiSkipListHighlight = true;
  }
  function getUnit(input) {
    return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
  }
  function toUnitless(length2) {
    return parseFloat(length2);
  }
  function useThemeProps({
    props,
    name
  }) {
    return useThemeProps$1({
      props,
      name,
      defaultTheme,
      themeId: THEME_ID
    });
  }
  function getSvgIconUtilityClass(slot) {
    return generateUtilityClass("MuiSvgIcon", slot);
  }
  generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const useUtilityClasses$o = (ownerState) => {
    const {
      color: color2,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
  };
  const SvgIconRoot = styled("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
    }
  })(memoTheme(({
    theme
  }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      flexShrink: 0,
      transition: (_d = (_a = theme.transitions) == null ? void 0 : _a.create) == null ? void 0 : _d.call(_a, "fill", {
        duration: (_c = (_b = (theme.vars ?? theme).transitions) == null ? void 0 : _b.duration) == null ? void 0 : _c.shorter
      }),
      variants: [
        {
          props: (props) => !props.hasSvgAsChild,
          style: {
            // the <svg> will define the property that has `currentColor`
            // for example heroicons uses fill="none" and stroke="currentColor"
            fill: "currentColor"
          }
        },
        {
          props: {
            fontSize: "inherit"
          },
          style: {
            fontSize: "inherit"
          }
        },
        {
          props: {
            fontSize: "small"
          },
          style: {
            fontSize: ((_f = (_e = theme.typography) == null ? void 0 : _e.pxToRem) == null ? void 0 : _f.call(_e, 20)) || "1.25rem"
          }
        },
        {
          props: {
            fontSize: "medium"
          },
          style: {
            fontSize: ((_h = (_g = theme.typography) == null ? void 0 : _g.pxToRem) == null ? void 0 : _h.call(_g, 24)) || "1.5rem"
          }
        },
        {
          props: {
            fontSize: "large"
          },
          style: {
            fontSize: ((_j = (_i = theme.typography) == null ? void 0 : _i.pxToRem) == null ? void 0 : _j.call(_i, 35)) || "2.1875rem"
          }
        },
        // TODO v5 deprecate color prop, v6 remove for sx
        ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color2]) => {
          var _a2, _b2;
          return {
            props: {
              color: color2
            },
            style: {
              color: (_b2 = (_a2 = (theme.vars ?? theme).palette) == null ? void 0 : _a2[color2]) == null ? void 0 : _b2.main
            }
          };
        }),
        {
          props: {
            color: "action"
          },
          style: {
            color: (_l = (_k = (theme.vars ?? theme).palette) == null ? void 0 : _k.action) == null ? void 0 : _l.active
          }
        },
        {
          props: {
            color: "disabled"
          },
          style: {
            color: (_n = (_m = (theme.vars ?? theme).palette) == null ? void 0 : _m.action) == null ? void 0 : _n.disabled
          }
        },
        {
          props: {
            color: "inherit"
          },
          style: {
            color: void 0
          }
        }
      ]
    };
  }));
  const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiSvgIcon"
    });
    const {
      children,
      className,
      color: color2 = "inherit",
      component = "svg",
      fontSize = "medium",
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = "0 0 24 24",
      ...other
    } = props;
    const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
    const ownerState = {
      ...props,
      color: color2,
      component,
      fontSize,
      instanceFontSize: inProps.fontSize,
      inheritViewBox,
      viewBox,
      hasSvgAsChild
    };
    const more = {};
    if (!inheritViewBox) {
      more.viewBox = viewBox;
    }
    const classes = useUtilityClasses$o(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
      as: component,
      className: clsx(classes.root, className),
      focusable: "false",
      color: htmlColor,
      "aria-hidden": titleAccess ? void 0 : true,
      role: titleAccess ? "img" : void 0,
      ref,
      ...more,
      ...other,
      ...hasSvgAsChild && children.props,
      ownerState,
      children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
        children: titleAccess
      }) : null]
    });
  });
  if (SvgIcon) {
    SvgIcon.muiName = "SvgIcon";
  }
  function createSvgIcon(path, displayName) {
    function Component(props, ref) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
        "data-testid": `${displayName}Icon`,
        ref,
        ...props,
        children: path
      });
    }
    Component.muiName = SvgIcon.muiName;
    return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
  }
  function _objectWithoutPropertiesLoose(r2, e3) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (e3.includes(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }
  function _setPrototypeOf(t2, e3) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e4) {
      return t3.__proto__ = e4, t3;
    }, _setPrototypeOf(t2, e3);
  }
  function _inheritsLoose(t2, o) {
    t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
  }
  const TransitionGroupContext = React$1.createContext(null);
  function _assertThisInitialized(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }
  function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children) reactExports.Children.map(children, function(c6) {
      return c6;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
    return result;
  }
  function mergeChildMappings(prev2, next2) {
    prev2 = prev2 || {};
    next2 = next2 || {};
    function getValueForKey(key) {
      return key in next2 ? next2[key] : prev2[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev2) {
      if (prevKey in next2) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey2 in next2) {
      if (nextKeysPending[nextKey2]) {
        for (i = 0; i < nextKeysPending[nextKey2].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey2][i];
          childMapping[nextKeysPending[nextKey2][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey2] = getValueForKey(nextKey2);
    }
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
      var child = children[key];
      if (!reactExports.isValidElement(child)) return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children[key] = reactExports.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
        children[key] = reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children;
  }
  var values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k2) {
      return obj[k2];
    });
  };
  var defaultProps$2 = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node2) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;
      if (child.props.onExited) {
        child.props.onExited(node2);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory2);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }
      return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ React$1.createElement(Component, props, children));
    };
    return TransitionGroup2;
  }(React$1.Component);
  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps$2;
  class LazyRipple {
    constructor() {
      __publicField(this, "mountEffect", () => {
        if (this.shouldMount && !this.didMount) {
          if (this.ref.current !== null) {
            this.didMount = true;
            this.mounted.resolve();
          }
        }
      });
      this.ref = {
        current: null
      };
      this.mounted = null;
      this.didMount = false;
      this.shouldMount = false;
      this.setShouldMount = null;
    }
    /** React ref to the ripple instance */
    /** If the ripple component should be mounted */
    /** Promise that resolves when the ripple component is mounted */
    /** If the ripple component has been mounted */
    /** React state hook setter */
    static create() {
      return new LazyRipple();
    }
    static use() {
      const ripple = useLazyRef(LazyRipple.create).current;
      const [shouldMount, setShouldMount] = reactExports.useState(false);
      ripple.shouldMount = shouldMount;
      ripple.setShouldMount = setShouldMount;
      reactExports.useEffect(ripple.mountEffect, [shouldMount]);
      return ripple;
    }
    mount() {
      if (!this.mounted) {
        this.mounted = createControlledPromise();
        this.shouldMount = true;
        this.setShouldMount(this.shouldMount);
      }
      return this.mounted;
    }
    /* Ripple API */
    start(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.start(...args);
      });
    }
    stop(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.stop(...args);
      });
    }
    pulsate(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.pulsate(...args);
      });
    }
  }
  function useLazyRipple() {
    return LazyRipple.use();
  }
  function createControlledPromise() {
    let resolve;
    let reject;
    const p2 = new Promise((resolveFn, rejectFn) => {
      resolve = resolveFn;
      reject = rejectFn;
    });
    p2.resolve = resolve;
    p2.reject = reject;
    return p2;
  }
  function Ripple(props) {
    const {
      className,
      classes,
      pulsate = false,
      rippleX,
      rippleY,
      rippleSize,
      in: inProp,
      onExited,
      timeout
    } = props;
    const [leaving, setLeaving] = reactExports.useState(false);
    const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
      setLeaving(true);
    }
    reactExports.useEffect(() => {
      if (!inProp && onExited != null) {
        const timeoutId = setTimeout(onExited, timeout);
        return () => {
          clearTimeout(timeoutId);
        };
      }
      return void 0;
    }, [onExited, inProp, timeout]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: rippleClassName,
      style: rippleStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: childClassName
      })
    });
  }
  const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
  const DURATION = 550;
  const DELAY_RIPPLE = 80;
  const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
  const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
  const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
  const TouchRippleRoot = styled("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  });
  const TouchRippleRipple = styled(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
    theme
  }) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
  const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTouchRipple"
    });
    const {
      center: centerProp = false,
      classes = {},
      className,
      ...other
    } = props;
    const [ripples, setRipples] = reactExports.useState([]);
    const nextKey2 = reactExports.useRef(0);
    const rippleCallback = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]);
    const ignoringMouseDown = reactExports.useRef(false);
    const startTimer = useTimeout();
    const startTimerCommit = reactExports.useRef(null);
    const container = reactExports.useRef(null);
    const startCommit = reactExports.useCallback((params) => {
      const {
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      } = params;
      setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
        classes: {
          ripple: clsx(classes.ripple, touchRippleClasses.ripple),
          rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
          ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
          child: clsx(classes.child, touchRippleClasses.child),
          childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
          childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
        },
        timeout: DURATION,
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize
      }, nextKey2.current)]);
      nextKey2.current += 1;
      rippleCallback.current = cb2;
    }, [classes]);
    const start2 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
    }) => {
      const {
        pulsate: pulsate2 = false,
        center = centerProp || options.pulsate,
        fakeElement = false
        // For test purposes
      } = options;
      if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }
      if ((event == null ? void 0 : event.type) === "touchstart") {
        ignoringMouseDown.current = true;
      }
      const element = fakeElement ? null : container.current;
      const rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let rippleX;
      let rippleY;
      let rippleSize;
      if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        const {
          clientX,
          clientY
        } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }
      if (center) {
        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
      }
      if (event == null ? void 0 : event.touches) {
        if (startTimerCommit.current === null) {
          startTimerCommit.current = () => {
            startCommit({
              pulsate: pulsate2,
              rippleX,
              rippleY,
              rippleSize,
              cb: cb2
            });
          };
          startTimer.start(DELAY_RIPPLE, () => {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          });
        }
      } else {
        startCommit({
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        });
      }
    }, [centerProp, startCommit, startTimer]);
    const pulsate = reactExports.useCallback(() => {
      start2({}, {
        pulsate: true
      });
    }, [start2]);
    const stop2 = reactExports.useCallback((event, cb2) => {
      startTimer.clear();
      if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.start(0, () => {
          stop2(event, cb2);
        });
        return;
      }
      startTimerCommit.current = null;
      setRipples((oldRipples) => {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }
        return oldRipples;
      });
      rippleCallback.current = cb2;
    }, [startTimer]);
    reactExports.useImperativeHandle(ref, () => ({
      pulsate,
      start: start2,
      stop: stop2
    }), [pulsate, start2, stop2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
      className: clsx(touchRippleClasses.root, classes.root, className),
      ref: container,
      ...other,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
        component: null,
        exit: true,
        children: ripples
      })
    });
  });
  function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass("MuiButtonBase", slot);
  }
  const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
  const useUtilityClasses$n = (ownerState) => {
    const {
      disabled,
      focusVisible,
      focusVisibleClassName,
      classes
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
      composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
  };
  const ButtonBaseRoot = styled("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${buttonBaseClasses.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  });
  const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiButtonBase"
    });
    const {
      action,
      centerRipple = false,
      children,
      className,
      component = "button",
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      focusVisibleClassName,
      LinkComponent = "a",
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      touchRippleRef,
      type,
      ...other
    } = props;
    const buttonRef = reactExports.useRef(null);
    const ripple = useLazyRipple();
    const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
    const [focusVisible, setFocusVisible] = reactExports.useState(false);
    if (disabled && focusVisible) {
      setFocusVisible(false);
    }
    reactExports.useImperativeHandle(action, () => ({
      focusVisible: () => {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    }), []);
    const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
    reactExports.useEffect(() => {
      if (focusVisible && focusRipple && !disableRipple) {
        ripple.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible, ripple]);
    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
      return useEventCallback((event) => {
        if (eventCallback) {
          eventCallback(event);
        }
        const ignore = skipRippleAction;
        if (!ignore) {
          ripple[rippleAction](event);
        }
        return true;
      });
    }
    const handleMouseDown = useRippleHandler("start", onMouseDown);
    const handleContextMenu = useRippleHandler("stop", onContextMenu);
    const handleDragLeave = useRippleHandler("stop", onDragLeave);
    const handleMouseUp = useRippleHandler("stop", onMouseUp);
    const handleMouseLeave = useRippleHandler("stop", (event) => {
      if (focusVisible) {
        event.preventDefault();
      }
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    const handleTouchStart = useRippleHandler("start", onTouchStart);
    const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
    const handleTouchMove = useRippleHandler("stop", onTouchMove);
    const handleBlur = useRippleHandler("stop", (event) => {
      if (!isFocusVisible(event.target)) {
        setFocusVisible(false);
      }
      if (onBlur) {
        onBlur(event);
      }
    }, false);
    const handleFocus = useEventCallback((event) => {
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }
      if (isFocusVisible(event.target)) {
        setFocusVisible(true);
        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }
      if (onFocus) {
        onFocus(event);
      }
    });
    const isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    const handleKeyDown = useEventCallback((event) => {
      if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
        ripple.stop(event, () => {
          ripple.start(event);
        });
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
        event.preventDefault();
        if (onClick) {
          onClick(event);
        }
      }
    });
    const handleKeyUp = useEventCallback((event) => {
      if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
        ripple.stop(event, () => {
          ripple.pulsate(event);
        });
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
        onClick(event);
      }
    });
    let ComponentProp = component;
    if (ComponentProp === "button" && (other.href || other.to)) {
      ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === "button") {
      buttonProps.type = type === void 0 ? "button" : type;
      buttonProps.disabled = disabled;
    } else {
      if (!other.href && !other.to) {
        buttonProps.role = "button";
      }
      if (disabled) {
        buttonProps["aria-disabled"] = disabled;
      }
    }
    const handleRef = useForkRef(ref, buttonRef);
    const ownerState = {
      ...props,
      centerRipple,
      component,
      disabled,
      disableRipple,
      disableTouchRipple,
      focusRipple,
      tabIndex,
      focusVisible
    };
    const classes = useUtilityClasses$n(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
      as: ComponentProp,
      className: clsx(classes.root, className),
      ownerState,
      onBlur: handleBlur,
      onClick,
      onContextMenu: handleContextMenu,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex,
      type,
      ...buttonProps,
      ...other,
      children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
        ref: handleRippleRef,
        center: centerRipple,
        ...TouchRippleProps
      }) : null]
    });
  });
  function hasCorrectMainProperty(obj) {
    return typeof obj.main === "string";
  }
  function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
    if (!hasCorrectMainProperty(obj)) {
      return false;
    }
    for (const value of additionalPropertiesToCheck) {
      if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
        return false;
      }
    }
    return true;
  }
  function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
    return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
  }
  function getTypographyUtilityClass(slot) {
    return generateUtilityClass("MuiTypography", slot);
  }
  generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
  const v6Colors = {
    primary: true,
    secondary: true,
    error: true,
    info: true,
    success: true,
    warning: true,
    textPrimary: true,
    textSecondary: true,
    textDisabled: true
  };
  const extendSxProp = internal_createExtendSxProp();
  const useUtilityClasses$m = (ownerState) => {
    const {
      align,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
  };
  const TypographyRoot = styled("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
    }
  })(memoTheme(({
    theme
  }) => {
    var _a;
    return {
      margin: 0,
      variants: [{
        props: {
          variant: "inherit"
        },
        style: {
          // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
          font: "inherit",
          lineHeight: "inherit",
          letterSpacing: "inherit"
        }
      }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
        props: {
          variant
        },
        style: value
      })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
        props: {
          color: color2
        },
        style: {
          color: (theme.vars || theme).palette[color2].main
        }
      })), ...Object.entries(((_a = theme.palette) == null ? void 0 : _a.text) || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
        props: {
          color: `text${capitalize(color2)}`
        },
        style: {
          color: (theme.vars || theme).palette.text[color2]
        }
      })), {
        props: ({
          ownerState
        }) => ownerState.align !== "inherit",
        style: {
          textAlign: "var(--Typography-textAlign)"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.noWrap,
        style: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.gutterBottom,
        style: {
          marginBottom: "0.35em"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.paragraph,
        style: {
          marginBottom: 16
        }
      }]
    };
  }));
  const defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  };
  const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
    const {
      color: color2,
      ...themeProps
    } = useDefaultProps({
      props: inProps,
      name: "MuiTypography"
    });
    const isSxColor = !v6Colors[color2];
    const props = extendSxProp({
      ...themeProps,
      ...isSxColor && {
        color: color2
      }
    });
    const {
      align = "inherit",
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = "body1",
      variantMapping = defaultVariantMapping,
      ...other
    } = props;
    const ownerState = {
      ...props,
      align,
      color: color2,
      className,
      component,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      variantMapping
    };
    const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
    const classes = useUtilityClasses$m(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, {
      as: Component,
      ref,
      className: clsx(classes.root, className),
      ...other,
      ownerState,
      style: {
        ...align !== "inherit" && {
          "--Typography-textAlign": align
        },
        ...other.style
      }
    });
  });
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start$1 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start$1, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main$1 = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument2 = node2.ownerDocument;
      return ownerDocument2 ? ownerDocument2.defaultView || window : window;
    }
    return node2;
  }
  function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement$1(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement$1(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  const applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
  };
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var max$1 = Math.max;
  var min$1 = Math.min;
  var round = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement$1(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2,
      left: x2,
      x: x2,
      y: y2
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement$1(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min2, value, max2) {
    return max$1(min2, min$1(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v2 = within(min2, value, max2);
    return v2 > max2 ? max2 : v2;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  var toPaddingObject = function toPaddingObject2(padding2, state) {
    padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding2;
    return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  const arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x2 = _ref.x, y2 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x2 * dpr) / dpr || 0,
      y: round(y2 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x2,
      y: y2
    }) : {
      x: x2,
      y: y2
    };
    x2 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y2 -= offsetY - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x2 -= offsetX - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position2
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x2,
      y: y2
    }, getWindow(popper2)) : {
      x: x2,
      y: y2
    };
    x2 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  const computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance2.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance2.update, passive);
      }
    };
  }
  const eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash[matched];
    });
  }
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height2 = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
      width2 = visualViewport.width;
      height2 = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width: width2,
      height: height2,
      x: x2 + getWindowScrollBarX(element),
      y: y2
    };
  }
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height2 = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
      x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
      width: width2,
      height: height2,
      x: x2,
      y: y2
    };
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement$1(node2) && isScrollParent(node2)) {
      return node2;
    }
    return getScrollParent(getParentNode(node2));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max$1(rect.top, accRect.top);
      accRect.right = min$1(rect.right, accRect.right);
      accRect.bottom = min$1(rect.bottom, accRect.bottom);
      accRect.left = max$1(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start$1:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b2) {
      return overflows[a] - overflows[b2];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start$1;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding: padding2
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  const flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  const hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  const offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding: padding2,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn());
          });
        });
      }
      return pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current2) {
      var existing = merged2[current2.name];
      merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
        options: Object.assign({}, existing.options, current2.options),
        data: Object.assign({}, existing.data, current2.data)
      }) : current2;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance2 = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          runModifierEffects();
          return instance2.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn === "function") {
              state = fn({
                state,
                options: _options,
                name,
                instance: instance2
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance2.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance2;
      }
      instance2.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
          if (typeof effect2 === "function") {
            var cleanupFn = effect2({
              state,
              name,
              instance: instance2,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn) {
          return fn();
        });
        effectCleanupFns = [];
      }
      return instance2;
    };
  }
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function getContainer(container) {
    return typeof container === "function" ? container() : container;
  }
  const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
    const {
      children,
      container,
      disablePortal = false
    } = props;
    const [mountNode, setMountNode] = reactExports.useState(null);
    const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
    useEnhancedEffect(() => {
      if (!disablePortal) {
        setMountNode(getContainer(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect(() => {
      if (mountNode && !disablePortal) {
        setRef(forwardedRef, mountNode);
        return () => {
          setRef(forwardedRef, null);
        };
      }
      return void 0;
    }, [forwardedRef, mountNode, disablePortal]);
    if (disablePortal) {
      if (/* @__PURE__ */ reactExports.isValidElement(children)) {
        const newProps = {
          ref: handleRef
        };
        return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
    });
  });
  function getPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPopper", slot);
  }
  generateUtilityClasses("MuiPopper", ["root"]);
  function flipPlacement(placement, direction) {
    if (direction === "ltr") {
      return placement;
    }
    switch (placement) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return placement;
    }
  }
  function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  function isHTMLElement(element) {
    return element.nodeType !== void 0;
  }
  const useUtilityClasses$l = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getPopperUtilityClass, classes);
  };
  const defaultPopperOptions = {};
  const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
    const {
      anchorEl,
      children,
      direction,
      disablePortal,
      modifiers,
      open,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      slotProps = {},
      slots = {},
      TransitionProps,
      // @ts-ignore internal logic
      ownerState: ownerStateProp,
      // prevent from spreading to DOM, it can come from the parent component e.g. Select.
      ...other
    } = props;
    const tooltipRef = reactExports.useRef(null);
    const ownRef = useForkRef(tooltipRef, forwardedRef);
    const popperRef = reactExports.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = reactExports.useRef(handlePopperRef);
    useEnhancedEffect(() => {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    const [placement, setPlacement] = reactExports.useState(rtlPlacement);
    const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl(anchorEl));
    reactExports.useEffect(() => {
      if (popperRef.current) {
        popperRef.current.forceUpdate();
      }
    });
    reactExports.useEffect(() => {
      if (anchorEl) {
        setResolvedAnchorElement(resolveAnchorEl(anchorEl));
      }
    }, [anchorEl]);
    useEnhancedEffect(() => {
      if (!resolvedAnchorElement || !open) {
        return void 0;
      }
      const handlePopperUpdate = (data) => {
        setPlacement(data.placement);
      };
      let popperModifiers = [{
        name: "preventOverflow",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "flip",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state
        }) => {
          handlePopperUpdate(state);
        }
      }];
      if (modifiers != null) {
        popperModifiers = popperModifiers.concat(modifiers);
      }
      if (popperOptions && popperOptions.modifiers != null) {
        popperModifiers = popperModifiers.concat(popperOptions.modifiers);
      }
      const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, {
        placement: rtlPlacement,
        ...popperOptions,
        modifiers: popperModifiers
      });
      handlePopperRefRef.current(popper2);
      return () => {
        popper2.destroy();
        handlePopperRefRef.current(null);
      };
    }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
    const childProps = {
      placement
    };
    if (TransitionProps !== null) {
      childProps.TransitionProps = TransitionProps;
    }
    const classes = useUtilityClasses$l(props);
    const Root = slots.root ?? "div";
    const rootProps = useSlotProps({
      elementType: Root,
      externalSlotProps: slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        role: "tooltip",
        ref: ownRef
      },
      ownerState: props,
      className: classes.root
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
      ...rootProps,
      children: typeof children === "function" ? children(childProps) : children
    });
  });
  const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
    const {
      anchorEl,
      children,
      container: containerProp,
      direction = "ltr",
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = "bottom",
      popperOptions = defaultPopperOptions,
      popperRef,
      style: style2,
      transition = false,
      slotProps = {},
      slots = {},
      ...other
    } = props;
    const [exited, setExited] = reactExports.useState(true);
    const handleEnter = () => {
      setExited(false);
    };
    const handleExited = () => {
      setExited(true);
    };
    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    }
    let container;
    if (containerProp) {
      container = containerProp;
    } else if (anchorEl) {
      const resolvedAnchorEl = resolveAnchorEl(anchorEl);
      container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
    }
    const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
    const transitionProps = transition ? {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    } : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
      disablePortal,
      container,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, {
        anchorEl,
        direction,
        disablePortal,
        modifiers,
        ref: forwardedRef,
        open: transition ? !exited : open,
        placement,
        popperOptions,
        popperRef,
        slotProps,
        slots,
        ...other,
        style: {
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display,
          ...style2
        },
        TransitionProps: transitionProps,
        children
      })
    });
  });
  const PopperRoot = styled(Popper$1, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper2(inProps, ref) {
    const isRtl = useRtl();
    const props = useDefaultProps({
      props: inProps,
      name: "MuiPopper"
    });
    const {
      anchorEl,
      component,
      components,
      componentsProps,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition,
      slots,
      slotProps,
      ...other
    } = props;
    const RootComponent = (slots == null ? void 0 : slots.root) ?? (components == null ? void 0 : components.Root);
    const otherProps = {
      anchorEl,
      container,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition,
      ...other
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, {
      as: component,
      direction: isRtl ? "rtl" : "ltr",
      slots: {
        root: RootComponent
      },
      slotProps: slotProps ?? componentsProps,
      ...otherProps,
      ref
    });
  });
  function getIconUtilityClass(slot) {
    return generateUtilityClass("MuiIcon", slot);
  }
  generateUtilityClasses("MuiIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const useUtilityClasses$k = (ownerState) => {
    const {
      color: color2,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
    };
    return composeClasses(slots, getIconUtilityClass, classes);
  };
  const IconRoot = styled("span", {
    name: "MuiIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
    }
  })(memoTheme(({
    theme
  }) => ({
    userSelect: "none",
    width: "1em",
    height: "1em",
    // Chrome fix for https://issues.chromium.org/issues/41375697
    // To remove at some point.
    overflow: "hidden",
    display: "inline-block",
    // allow overflow hidden to take action
    textAlign: "center",
    // support non-square icon
    flexShrink: 0,
    variants: [{
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    }, {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: theme.typography.pxToRem(20)
      }
    }, {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: theme.typography.pxToRem(24)
      }
    }, {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: theme.typography.pxToRem(36)
      }
    }, {
      props: {
        color: "action"
      },
      style: {
        color: (theme.vars || theme).palette.action.active
      }
    }, {
      props: {
        color: "disabled"
      },
      style: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }, {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme.vars || theme).palette[color2].main
      }
    }))]
  })));
  const Icon = /* @__PURE__ */ reactExports.forwardRef(function Icon2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiIcon"
    });
    const {
      baseClassName = "material-icons",
      className,
      color: color2 = "inherit",
      component: Component = "span",
      fontSize = "medium",
      ...other
    } = props;
    const ownerState = {
      ...props,
      baseClassName,
      color: color2,
      component: Component,
      fontSize
    };
    const classes = useUtilityClasses$k(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(IconRoot, {
      as: Component,
      className: clsx(
        baseClassName,
        // Prevent the translation of the text content.
        // The font relies on the exact text content to render the icon.
        "notranslate",
        classes.root,
        className
      ),
      ownerState,
      "aria-hidden": true,
      ref,
      ...other
    });
  });
  if (Icon) {
    Icon.muiName = "Icon";
  }
  function NoSsr(props) {
    const {
      children,
      defer = false,
      fallback = null
    } = props;
    const [mountedState, setMountedState] = reactExports.useState(false);
    useEnhancedEffect(() => {
      if (!defer) {
        setMountedState(true);
      }
    }, [defer]);
    reactExports.useEffect(() => {
      if (defer) {
        setMountedState(true);
      }
    }, [defer]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: mountedState ? children : fallback
    });
  }
  function getSkeletonUtilityClass(slot) {
    return generateUtilityClass("MuiSkeleton", slot);
  }
  generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
  const useUtilityClasses$j = (ownerState) => {
    const {
      classes,
      variant,
      animation,
      hasChildren,
      width: width2,
      height: height2
    } = ownerState;
    const slots = {
      root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
    };
    return composeClasses(slots, getSkeletonUtilityClass, classes);
  };
  const pulseKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`;
  const waveKeyframe = keyframes`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`;
  const pulseAnimation = typeof pulseKeyframe !== "string" ? css`
        animation: ${pulseKeyframe} 2s ease-in-out 0.5s infinite;
      ` : null;
  const waveAnimation = typeof waveKeyframe !== "string" ? css`
        &::after {
          animation: ${waveKeyframe} 2s linear 0.5s infinite;
        }
      ` : null;
  const SkeletonRoot = styled("span", {
    name: "MuiSkeleton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
    }
  })(memoTheme(({
    theme
  }) => {
    const radiusUnit = getUnit(theme.shape.borderRadius) || "px";
    const radiusValue = toUnitless(theme.shape.borderRadius);
    return {
      display: "block",
      // Create a "on paper" color with sufficient contrast retaining the color
      backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === "light" ? 0.11 : 0.13),
      height: "1.2em",
      variants: [{
        props: {
          variant: "text"
        },
        style: {
          marginTop: 0,
          marginBottom: 0,
          height: "auto",
          transformOrigin: "0 55%",
          transform: "scale(1, 0.60)",
          borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
          "&:empty:before": {
            content: '"\\00a0"'
          }
        }
      }, {
        props: {
          variant: "circular"
        },
        style: {
          borderRadius: "50%"
        }
      }, {
        props: {
          variant: "rounded"
        },
        style: {
          borderRadius: (theme.vars || theme).shape.borderRadius
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.hasChildren,
        style: {
          "& > *": {
            visibility: "hidden"
          }
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.hasChildren && !ownerState.width,
        style: {
          maxWidth: "fit-content"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.hasChildren && !ownerState.height,
        style: {
          height: "auto"
        }
      }, {
        props: {
          animation: "pulse"
        },
        style: pulseAnimation || {
          animation: `${pulseKeyframe} 2s ease-in-out 0.5s infinite`
        }
      }, {
        props: {
          animation: "wave"
        },
        style: {
          position: "relative",
          overflow: "hidden",
          /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
          WebkitMaskImage: "-webkit-radial-gradient(white, black)",
          "&::after": {
            background: `linear-gradient(
                90deg,
                transparent,
                ${(theme.vars || theme).palette.action.hover},
                transparent
              )`,
            content: '""',
            position: "absolute",
            transform: "translateX(-100%)",
            bottom: 0,
            left: 0,
            right: 0,
            top: 0
          }
        }
      }, {
        props: {
          animation: "wave"
        },
        style: waveAnimation || {
          "&::after": {
            animation: `${waveKeyframe} 2s linear 0.5s infinite`
          }
        }
      }]
    };
  }));
  const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiSkeleton"
    });
    const {
      animation = "pulse",
      className,
      component = "span",
      height: height2,
      style: style2,
      variant = "text",
      width: width2,
      ...other
    } = props;
    const ownerState = {
      ...props,
      animation,
      component,
      variant,
      hasChildren: Boolean(other.children)
    };
    const classes = useUtilityClasses$j(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, {
      as: component,
      ref,
      className: clsx(classes.root, className),
      ownerState,
      ...other,
      style: {
        width: width2,
        height: height2,
        ...style2
      }
    });
  });
  function getTabUtilityClass(slot) {
    return generateUtilityClass("MuiTab", slot);
  }
  const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]);
  const useUtilityClasses$i = (ownerState) => {
    const {
      classes,
      textColor,
      fullWidth,
      wrapped,
      icon,
      label,
      selected,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
      icon: ["iconWrapper", "icon"]
    };
    return composeClasses(slots, getTabUtilityClass, classes);
  };
  const TabRoot = styled(ButtonBase, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
        [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
      }, {
        [`& .${tabClasses.icon}`]: styles2.icon
      }];
    }
  })(memoTheme(({
    theme
  }) => ({
    ...theme.typography.button,
    maxWidth: 360,
    minWidth: 90,
    position: "relative",
    minHeight: 48,
    flexShrink: 0,
    padding: "12px 16px",
    overflow: "hidden",
    whiteSpace: "normal",
    textAlign: "center",
    lineHeight: 1.25,
    variants: [{
      props: ({
        ownerState
      }) => ownerState.label && (ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom"),
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.label && ownerState.iconPosition !== "top" && ownerState.iconPosition !== "bottom",
      style: {
        flexDirection: "row"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.icon && ownerState.label,
      style: {
        minHeight: 72,
        paddingTop: 9,
        paddingBottom: 9
      }
    }, {
      props: ({
        ownerState,
        iconPosition
      }) => ownerState.icon && ownerState.label && iconPosition === "top",
      style: {
        [`& > .${tabClasses.icon}`]: {
          marginBottom: 6
        }
      }
    }, {
      props: ({
        ownerState,
        iconPosition
      }) => ownerState.icon && ownerState.label && iconPosition === "bottom",
      style: {
        [`& > .${tabClasses.icon}`]: {
          marginTop: 6
        }
      }
    }, {
      props: ({
        ownerState,
        iconPosition
      }) => ownerState.icon && ownerState.label && iconPosition === "start",
      style: {
        [`& > .${tabClasses.icon}`]: {
          marginRight: theme.spacing(1)
        }
      }
    }, {
      props: ({
        ownerState,
        iconPosition
      }) => ownerState.icon && ownerState.label && iconPosition === "end",
      style: {
        [`& > .${tabClasses.icon}`]: {
          marginLeft: theme.spacing(1)
        }
      }
    }, {
      props: {
        textColor: "inherit"
      },
      style: {
        color: "inherit",
        opacity: 0.6,
        // same opacity as theme.palette.text.secondary
        [`&.${tabClasses.selected}`]: {
          opacity: 1
        },
        [`&.${tabClasses.disabled}`]: {
          opacity: (theme.vars || theme).palette.action.disabledOpacity
        }
      }
    }, {
      props: {
        textColor: "primary"
      },
      style: {
        color: (theme.vars || theme).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
          color: (theme.vars || theme).palette.primary.main
        },
        [`&.${tabClasses.disabled}`]: {
          color: (theme.vars || theme).palette.text.disabled
        }
      }
    }, {
      props: {
        textColor: "secondary"
      },
      style: {
        color: (theme.vars || theme).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
          color: (theme.vars || theme).palette.secondary.main
        },
        [`&.${tabClasses.disabled}`]: {
          color: (theme.vars || theme).palette.text.disabled
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.fullWidth,
      style: {
        flexShrink: 1,
        flexGrow: 1,
        flexBasis: 0,
        maxWidth: "none"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.wrapped,
      style: {
        fontSize: theme.typography.pxToRem(12)
      }
    }]
  })));
  const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTab"
    });
    const {
      className,
      disabled = false,
      disableFocusRipple = false,
      // eslint-disable-next-line react/prop-types
      fullWidth,
      icon: iconProp,
      iconPosition = "top",
      // eslint-disable-next-line react/prop-types
      indicator,
      label,
      onChange,
      onClick,
      onFocus,
      // eslint-disable-next-line react/prop-types
      selected,
      // eslint-disable-next-line react/prop-types
      selectionFollowsFocus,
      // eslint-disable-next-line react/prop-types
      textColor = "inherit",
      value,
      wrapped = false,
      ...other
    } = props;
    const ownerState = {
      ...props,
      disabled,
      disableFocusRipple,
      selected,
      icon: !!iconProp,
      iconPosition,
      label: !!label,
      fullWidth,
      textColor,
      wrapped
    };
    const classes = useUtilityClasses$i(ownerState);
    const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    }) : iconProp;
    const handleClick = (event) => {
      if (!selected && onChange) {
        onChange(event, value);
      }
      if (onClick) {
        onClick(event);
      }
    };
    const handleFocus = (event) => {
      if (selectionFollowsFocus && !selected && onChange) {
        onChange(event, value);
      }
      if (onFocus) {
        onFocus(event);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, {
      focusRipple: !disableFocusRipple,
      className: clsx(classes.root, className),
      ref,
      role: "tab",
      "aria-selected": selected,
      disabled,
      onClick: handleClick,
      onFocus: handleFocus,
      ownerState,
      tabIndex: selected ? 0 : -1,
      ...other,
      children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [icon, label]
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, icon]
      }), indicator]
    });
  });
  const TableContext = /* @__PURE__ */ reactExports.createContext();
  function getTableUtilityClass(slot) {
    return generateUtilityClass("MuiTable", slot);
  }
  generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
  const useUtilityClasses$h = (ownerState) => {
    const {
      classes,
      stickyHeader
    } = ownerState;
    const slots = {
      root: ["root", stickyHeader && "stickyHeader"]
    };
    return composeClasses(slots, getTableUtilityClass, classes);
  };
  const TableRoot = styled("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
    }
  })(memoTheme(({
    theme
  }) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": {
      ...theme.typography.body2,
      padding: theme.spacing(2),
      color: (theme.vars || theme).palette.text.secondary,
      textAlign: "left",
      captionSide: "bottom"
    },
    variants: [{
      props: ({
        ownerState
      }) => ownerState.stickyHeader,
      style: {
        borderCollapse: "separate"
      }
    }]
  })));
  const defaultComponent$3 = "table";
  const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTable"
    });
    const {
      className,
      component = defaultComponent$3,
      padding: padding2 = "normal",
      size = "medium",
      stickyHeader = false,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component,
      padding: padding2,
      size,
      stickyHeader
    };
    const classes = useUtilityClasses$h(ownerState);
    const table = reactExports.useMemo(() => ({
      padding: padding2,
      size,
      stickyHeader
    }), [padding2, size, stickyHeader]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
      value: table,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, {
        as: component,
        role: component === defaultComponent$3 ? null : "table",
        ref,
        className: clsx(classes.root, className),
        ownerState,
        ...other
      })
    });
  });
  const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
  function getTableBodyUtilityClass(slot) {
    return generateUtilityClass("MuiTableBody", slot);
  }
  generateUtilityClasses("MuiTableBody", ["root"]);
  const useUtilityClasses$g = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTableBodyUtilityClass, classes);
  };
  const TableBodyRoot = styled("tbody", {
    name: "MuiTableBody",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "table-row-group"
  });
  const tablelvl2$1 = {
    variant: "body"
  };
  const defaultComponent$2 = "tbody";
  const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTableBody"
    });
    const {
      className,
      component = defaultComponent$2,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component
    };
    const classes = useUtilityClasses$g(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
      value: tablelvl2$1,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, {
        className: clsx(classes.root, className),
        as: component,
        ref,
        role: component === defaultComponent$2 ? null : "rowgroup",
        ownerState,
        ...other
      })
    });
  });
  function getTableCellUtilityClass(slot) {
    return generateUtilityClass("MuiTableCell", slot);
  }
  const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
  const useUtilityClasses$f = (ownerState) => {
    const {
      classes,
      variant,
      align,
      padding: padding2,
      size,
      stickyHeader
    } = ownerState;
    const slots = {
      root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size)}`]
    };
    return composeClasses(slots, getTableCellUtilityClass, classes);
  };
  const TableCellRoot = styled("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
    }
  })(memoTheme(({
    theme
  }) => ({
    ...theme.typography.body2,
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
      props: {
        variant: "head"
      },
      style: {
        color: (theme.vars || theme).palette.text.primary,
        lineHeight: theme.typography.pxToRem(24),
        fontWeight: theme.typography.fontWeightMedium
      }
    }, {
      props: {
        variant: "body"
      },
      style: {
        color: (theme.vars || theme).palette.text.primary
      }
    }, {
      props: {
        variant: "footer"
      },
      style: {
        color: (theme.vars || theme).palette.text.secondary,
        lineHeight: theme.typography.pxToRem(21),
        fontSize: theme.typography.pxToRem(12)
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        padding: "6px 16px",
        [`&.${tableCellClasses.paddingCheckbox}`]: {
          width: 24,
          // prevent the checkbox column from growing
          padding: "0 12px 0 16px",
          "& > *": {
            padding: 0
          }
        }
      }
    }, {
      props: {
        padding: "checkbox"
      },
      style: {
        width: 48,
        // prevent the checkbox column from growing
        padding: "0 0 0 4px"
      }
    }, {
      props: {
        padding: "none"
      },
      style: {
        padding: 0
      }
    }, {
      props: {
        align: "left"
      },
      style: {
        textAlign: "left"
      }
    }, {
      props: {
        align: "center"
      },
      style: {
        textAlign: "center"
      }
    }, {
      props: {
        align: "right"
      },
      style: {
        textAlign: "right",
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        align: "justify"
      },
      style: {
        textAlign: "justify"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.stickyHeader,
      style: {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (theme.vars || theme).palette.background.default
      }
    }]
  })));
  const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTableCell"
    });
    const {
      align = "inherit",
      className,
      component: componentProp,
      padding: paddingProp,
      scope: scopeProp,
      size: sizeProp,
      sortDirection,
      variant: variantProp,
      ...other
    } = props;
    const table = reactExports.useContext(TableContext);
    const tablelvl22 = reactExports.useContext(Tablelvl2Context);
    const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
    let component;
    if (componentProp) {
      component = componentProp;
    } else {
      component = isHeadCell ? "th" : "td";
    }
    let scope = scopeProp;
    if (component === "td") {
      scope = void 0;
    } else if (!scope && isHeadCell) {
      scope = "col";
    }
    const variant = variantProp || tablelvl22 && tablelvl22.variant;
    const ownerState = {
      ...props,
      align,
      component,
      padding: paddingProp || (table && table.padding ? table.padding : "normal"),
      size: sizeProp || (table && table.size ? table.size : "medium"),
      sortDirection,
      stickyHeader: variant === "head" && table && table.stickyHeader,
      variant
    };
    const classes = useUtilityClasses$f(ownerState);
    let ariaSort = null;
    if (sortDirection) {
      ariaSort = sortDirection === "asc" ? "ascending" : "descending";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, {
      as: component,
      ref,
      className: clsx(classes.root, className),
      "aria-sort": ariaSort,
      scope,
      ownerState,
      ...other
    });
  });
  function getTableHeadUtilityClass(slot) {
    return generateUtilityClass("MuiTableHead", slot);
  }
  generateUtilityClasses("MuiTableHead", ["root"]);
  const useUtilityClasses$e = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTableHeadUtilityClass, classes);
  };
  const TableHeadRoot = styled("thead", {
    name: "MuiTableHead",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "table-header-group"
  });
  const tablelvl2 = {
    variant: "head"
  };
  const defaultComponent$1 = "thead";
  const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTableHead"
    });
    const {
      className,
      component = defaultComponent$1,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component
    };
    const classes = useUtilityClasses$e(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
      value: tablelvl2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, {
        as: component,
        className: clsx(classes.root, className),
        ref,
        role: component === defaultComponent$1 ? null : "rowgroup",
        ownerState,
        ...other
      })
    });
  });
  const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
  }), "KeyboardArrowLeft");
  const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
  }), "KeyboardArrowRight");
  function getTableRowUtilityClass(slot) {
    return generateUtilityClass("MuiTableRow", slot);
  }
  const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
  const useUtilityClasses$d = (ownerState) => {
    const {
      classes,
      selected,
      hover,
      head,
      footer
    } = ownerState;
    const slots = {
      root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
    };
    return composeClasses(slots, getTableRowUtilityClass, classes);
  };
  const TableRowRoot = styled("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
    }
  })(memoTheme(({
    theme
  }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${tableRowClasses.hover}:hover`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover
    },
    [`&.${tableRowClasses.selected}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
      }
    }
  })));
  const defaultComponent = "tr";
  const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTableRow"
    });
    const {
      className,
      component = defaultComponent,
      hover = false,
      selected = false,
      ...other
    } = props;
    const tablelvl22 = reactExports.useContext(Tablelvl2Context);
    const ownerState = {
      ...props,
      component,
      hover,
      selected,
      head: tablelvl22 && tablelvl22.variant === "head",
      footer: tablelvl22 && tablelvl22.variant === "footer"
    };
    const classes = useUtilityClasses$d(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, {
      as: component,
      ref,
      className: clsx(classes.root, className),
      role: component === defaultComponent ? null : "row",
      ownerState,
      ...other
    });
  });
  function easeInOutSin(time2) {
    return (1 + Math.sin(Math.PI * time2 - Math.PI / 2)) / 2;
  }
  function animate(property, element, to2, options = {}, cb2 = () => {
  }) {
    const {
      ease = easeInOutSin,
      duration: duration2 = 300
      // standard
    } = options;
    let start2 = null;
    const from2 = element[property];
    let cancelled = false;
    const cancel = () => {
      cancelled = true;
    };
    const step = (timestamp) => {
      if (cancelled) {
        cb2(new Error("Animation cancelled"));
        return;
      }
      if (start2 === null) {
        start2 = timestamp;
      }
      const time2 = Math.min(1, (timestamp - start2) / duration2);
      element[property] = ease(time2) * (to2 - from2) + from2;
      if (time2 >= 1) {
        requestAnimationFrame(() => {
          cb2(null);
        });
        return;
      }
      requestAnimationFrame(step);
    };
    if (from2 === to2) {
      cb2(new Error("Element already at target position"));
      return cancel;
    }
    requestAnimationFrame(step);
    return cancel;
  }
  const styles = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll"
  };
  function ScrollbarSize(props) {
    const {
      onChange,
      ...other
    } = props;
    const scrollbarHeight = reactExports.useRef();
    const nodeRef = reactExports.useRef(null);
    const setMeasurements = () => {
      scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
    };
    useEnhancedEffect(() => {
      const handleResize = debounce$1(() => {
        const prevHeight = scrollbarHeight.current;
        setMeasurements();
        if (prevHeight !== scrollbarHeight.current) {
          onChange(scrollbarHeight.current);
        }
      });
      const containerWindow = ownerWindow(nodeRef.current);
      containerWindow.addEventListener("resize", handleResize);
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener("resize", handleResize);
      };
    }, [onChange]);
    reactExports.useEffect(() => {
      setMeasurements();
      onChange(scrollbarHeight.current);
    }, [onChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      style: styles,
      ref: nodeRef,
      ...other
    });
  }
  function getTabScrollButtonUtilityClass(slot) {
    return generateUtilityClass("MuiTabScrollButton", slot);
  }
  const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
  const useUtilityClasses$c = (ownerState) => {
    const {
      classes,
      orientation,
      disabled
    } = ownerState;
    const slots = {
      root: ["root", orientation, disabled && "disabled"]
    };
    return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
  };
  const TabScrollButtonRoot = styled(ButtonBase, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
    }
  })({
    width: 40,
    flexShrink: 0,
    opacity: 0.8,
    [`&.${tabScrollButtonClasses.disabled}`]: {
      opacity: 0
    },
    variants: [{
      props: {
        orientation: "vertical"
      },
      style: {
        width: "100%",
        height: 40,
        "& svg": {
          transform: "var(--TabScrollButton-svgRotate)"
        }
      }
    }]
  });
  const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTabScrollButton"
    });
    const {
      className,
      slots = {},
      slotProps = {},
      direction,
      orientation,
      disabled,
      ...other
    } = props;
    const isRtl = useRtl();
    const ownerState = {
      isRtl,
      ...props
    };
    const classes = useUtilityClasses$c(ownerState);
    const StartButtonIcon = slots.StartScrollButtonIcon ?? KeyboardArrowLeft;
    const EndButtonIcon = slots.EndScrollButtonIcon ?? KeyboardArrowRight;
    const startButtonIconProps = useSlotProps({
      elementType: StartButtonIcon,
      externalSlotProps: slotProps.startScrollButtonIcon,
      additionalProps: {
        fontSize: "small"
      },
      ownerState
    });
    const endButtonIconProps = useSlotProps({
      elementType: EndButtonIcon,
      externalSlotProps: slotProps.endScrollButtonIcon,
      additionalProps: {
        fontSize: "small"
      },
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, {
      component: "div",
      className: clsx(classes.root, className),
      ref,
      role: null,
      ownerState,
      tabIndex: null,
      ...other,
      style: {
        ...other.style,
        ...orientation === "vertical" && {
          "--TabScrollButton-svgRotate": `rotate(${isRtl ? -90 : 90}deg)`
        }
      },
      children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, {
        ...startButtonIconProps
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, {
        ...endButtonIconProps
      })
    });
  });
  function getTabsUtilityClass(slot) {
    return generateUtilityClass("MuiTabs", slot);
  }
  const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
  const nextItem = (list, item) => {
    if (list === item) {
      return list.firstChild;
    }
    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }
    return list.firstChild;
  };
  const previousItem = (list, item) => {
    if (list === item) {
      return list.lastChild;
    }
    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }
    return list.lastChild;
  };
  const moveFocus = (list, currentFocus, traversalFunction) => {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus);
    while (nextFocus) {
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return;
        }
        wrappedOnce = true;
      }
      const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
      if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus = traversalFunction(list, nextFocus);
      } else {
        nextFocus.focus();
        return;
      }
    }
  };
  const useUtilityClasses$b = (ownerState) => {
    const {
      vertical,
      fixed,
      hideScrollbar,
      scrollableX,
      scrollableY,
      centered,
      scrollButtonsHideMobile,
      classes
    } = ownerState;
    const slots = {
      root: ["root", vertical && "vertical"],
      scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
      flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
      indicator: ["indicator"],
      scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
      scrollableX: [scrollableX && "scrollableX"],
      hideScrollbar: [hideScrollbar && "hideScrollbar"]
    };
    return composeClasses(slots, getTabsUtilityClass, classes);
  };
  const TabsRoot = styled("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [{
        [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
      }, {
        [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
      }, styles2.root, ownerState.vertical && styles2.vertical];
    }
  })(memoTheme(({
    theme
  }) => ({
    overflow: "hidden",
    minHeight: 48,
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch",
    display: "flex",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.vertical,
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.scrollButtonsHideMobile,
      style: {
        [`& .${tabsClasses.scrollButtons}`]: {
          [theme.breakpoints.down("sm")]: {
            display: "none"
          }
        }
      }
    }]
  })));
  const TabsScroller = styled("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
    }
  })({
    position: "relative",
    display: "inline-block",
    flex: "1 1 auto",
    whiteSpace: "nowrap",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.fixed,
      style: {
        overflowX: "hidden",
        width: "100%"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hideScrollbar,
      style: {
        // Hide dimensionless scrollbar on macOS
        scrollbarWidth: "none",
        // Firefox
        "&::-webkit-scrollbar": {
          display: "none"
          // Safari + Chrome
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.scrollableX,
      style: {
        overflowX: "auto",
        overflowY: "hidden"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.scrollableY,
      style: {
        overflowY: "auto",
        overflowX: "hidden"
      }
    }]
  });
  const FlexContainer = styled("div", {
    name: "MuiTabs",
    slot: "FlexContainer",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
    }
  })({
    display: "flex",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.vertical,
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.centered,
      style: {
        justifyContent: "center"
      }
    }]
  });
  const TabsIndicator = styled("span", {
    name: "MuiTabs",
    slot: "Indicator",
    overridesResolver: (props, styles2) => styles2.indicator
  })(memoTheme(({
    theme
  }) => ({
    position: "absolute",
    height: 2,
    bottom: 0,
    width: "100%",
    transition: theme.transitions.create(),
    variants: [{
      props: {
        indicatorColor: "primary"
      },
      style: {
        backgroundColor: (theme.vars || theme).palette.primary.main
      }
    }, {
      props: {
        indicatorColor: "secondary"
      },
      style: {
        backgroundColor: (theme.vars || theme).palette.secondary.main
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.vertical,
      style: {
        height: "100%",
        width: 2,
        right: 0
      }
    }]
  })));
  const TabsScrollbarSize = styled(ScrollbarSize)({
    overflowX: "auto",
    overflowY: "hidden",
    // Hide dimensionless scrollbar on macOS
    scrollbarWidth: "none",
    // Firefox
    "&::-webkit-scrollbar": {
      display: "none"
      // Safari + Chrome
    }
  });
  const defaultIndicatorStyle = {};
  const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
    const props = useDefaultProps({
      props: inProps,
      name: "MuiTabs"
    });
    const theme = useTheme();
    const isRtl = useRtl();
    const {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      action,
      centered = false,
      children: childrenProp,
      className,
      component = "div",
      allowScrollButtonsMobile = false,
      indicatorColor = "primary",
      onChange,
      orientation = "horizontal",
      ScrollButtonComponent = TabScrollButton,
      scrollButtons = "auto",
      selectionFollowsFocus,
      slots = {},
      slotProps = {},
      TabIndicatorProps = {},
      TabScrollButtonProps = {},
      textColor = "primary",
      value,
      variant = "standard",
      visibleScrollbar = false,
      ...other
    } = props;
    const scrollable = variant === "scrollable";
    const vertical = orientation === "vertical";
    const scrollStart = vertical ? "scrollTop" : "scrollLeft";
    const start2 = vertical ? "top" : "left";
    const end2 = vertical ? "bottom" : "right";
    const clientSize = vertical ? "clientHeight" : "clientWidth";
    const size = vertical ? "height" : "width";
    const ownerState = {
      ...props,
      component,
      allowScrollButtonsMobile,
      indicatorColor,
      orientation,
      vertical,
      scrollButtons,
      textColor,
      variant,
      visibleScrollbar,
      fixed: !scrollable,
      hideScrollbar: scrollable && !visibleScrollbar,
      scrollableX: scrollable && !vertical,
      scrollableY: scrollable && vertical,
      centered: centered && !scrollable,
      scrollButtonsHideMobile: !allowScrollButtonsMobile
    };
    const classes = useUtilityClasses$b(ownerState);
    const startScrollButtonIconProps = useSlotProps({
      elementType: slots.StartScrollButtonIcon,
      externalSlotProps: slotProps.startScrollButtonIcon,
      ownerState
    });
    const endScrollButtonIconProps = useSlotProps({
      elementType: slots.EndScrollButtonIcon,
      externalSlotProps: slotProps.endScrollButtonIcon,
      ownerState
    });
    const [mounted, setMounted] = reactExports.useState(false);
    const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
    const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
    const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
    const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
    const [scrollerStyle, setScrollerStyle] = reactExports.useState({
      overflow: "hidden",
      scrollbarWidth: 0
    });
    const valueToIndex = /* @__PURE__ */ new Map();
    const tabsRef = reactExports.useRef(null);
    const tabListRef = reactExports.useRef(null);
    const getTabsMeta = () => {
      const tabsNode = tabsRef.current;
      let tabsMeta;
      if (tabsNode) {
        const rect = tabsNode.getBoundingClientRect();
        tabsMeta = {
          clientWidth: tabsNode.clientWidth,
          scrollLeft: tabsNode.scrollLeft,
          scrollTop: tabsNode.scrollTop,
          scrollWidth: tabsNode.scrollWidth,
          top: rect.top,
          bottom: rect.bottom,
          left: rect.left,
          right: rect.right
        };
      }
      let tabMeta;
      if (tabsNode && value !== false) {
        const children2 = tabListRef.current.children;
        if (children2.length > 0) {
          const tab = children2[valueToIndex.get(value)];
          tabMeta = tab ? tab.getBoundingClientRect() : null;
        }
      }
      return {
        tabsMeta,
        tabMeta
      };
    };
    const updateIndicatorState = useEventCallback(() => {
      const {
        tabsMeta,
        tabMeta
      } = getTabsMeta();
      let startValue = 0;
      let startIndicator;
      if (vertical) {
        startIndicator = "top";
        if (tabMeta && tabsMeta) {
          startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
        }
      } else {
        startIndicator = isRtl ? "right" : "left";
        if (tabMeta && tabsMeta) {
          startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + tabsMeta.scrollLeft);
        }
      }
      const newIndicatorStyle = {
        [startIndicator]: startValue,
        // May be wrong until the font is loaded.
        [size]: tabMeta ? tabMeta[size] : 0
      };
      if (typeof indicatorStyle[startIndicator] !== "number" || typeof indicatorStyle[size] !== "number") {
        setIndicatorStyle(newIndicatorStyle);
      } else {
        const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
        const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
        if (dStart >= 1 || dSize >= 1) {
          setIndicatorStyle(newIndicatorStyle);
        }
      }
    });
    const scroll = (scrollValue, {
      animation = true
    } = {}) => {
      if (animation) {
        animate(scrollStart, tabsRef.current, scrollValue, {
          duration: theme.transitions.duration.standard
        });
      } else {
        tabsRef.current[scrollStart] = scrollValue;
      }
    };
    const moveTabsScroll = (delta) => {
      let scrollValue = tabsRef.current[scrollStart];
      if (vertical) {
        scrollValue += delta;
      } else {
        scrollValue += delta * (isRtl ? -1 : 1);
      }
      scroll(scrollValue);
    };
    const getScrollSize = () => {
      const containerSize = tabsRef.current[clientSize];
      let totalSize = 0;
      const children2 = Array.from(tabListRef.current.children);
      for (let i = 0; i < children2.length; i += 1) {
        const tab = children2[i];
        if (totalSize + tab[clientSize] > containerSize) {
          if (i === 0) {
            totalSize = containerSize;
          }
          break;
        }
        totalSize += tab[clientSize];
      }
      return totalSize;
    };
    const handleStartScrollClick = () => {
      moveTabsScroll(-1 * getScrollSize());
    };
    const handleEndScrollClick = () => {
      moveTabsScroll(getScrollSize());
    };
    const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
      setScrollerStyle({
        overflow: null,
        scrollbarWidth
      });
    }, []);
    const getConditionalElements = () => {
      const conditionalElements2 = {};
      conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(TabsScrollbarSize, {
        onChange: handleScrollbarSizeChange,
        className: clsx(classes.scrollableX, classes.hideScrollbar)
      }) : null;
      const scrollButtonsActive = displayStartScroll || displayEndScroll;
      const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
      conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, {
        slots: {
          StartScrollButtonIcon: slots.StartScrollButtonIcon
        },
        slotProps: {
          startScrollButtonIcon: startScrollButtonIconProps
        },
        orientation,
        direction: isRtl ? "right" : "left",
        onClick: handleStartScrollClick,
        disabled: !displayStartScroll,
        ...TabScrollButtonProps,
        className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
      }) : null;
      conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, {
        slots: {
          EndScrollButtonIcon: slots.EndScrollButtonIcon
        },
        slotProps: {
          endScrollButtonIcon: endScrollButtonIconProps
        },
        orientation,
        direction: isRtl ? "left" : "right",
        onClick: handleEndScrollClick,
        disabled: !displayEndScroll,
        ...TabScrollButtonProps,
        className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
      }) : null;
      return conditionalElements2;
    };
    const scrollSelectedIntoView = useEventCallback((animation) => {
      const {
        tabsMeta,
        tabMeta
      } = getTabsMeta();
      if (!tabMeta || !tabsMeta) {
        return;
      }
      if (tabMeta[start2] < tabsMeta[start2]) {
        const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
        scroll(nextScrollStart, {
          animation
        });
      } else if (tabMeta[end2] > tabsMeta[end2]) {
        const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
        scroll(nextScrollStart, {
          animation
        });
      }
    });
    const updateScrollButtonState = useEventCallback(() => {
      if (scrollable && scrollButtons !== false) {
        setUpdateScrollObserver(!updateScrollObserver);
      }
    });
    reactExports.useEffect(() => {
      const handleResize = debounce$1(() => {
        if (tabsRef.current) {
          updateIndicatorState();
        }
      });
      let resizeObserver;
      const handleMutation = (records) => {
        records.forEach((record) => {
          record.removedNodes.forEach((item) => {
            resizeObserver == null ? void 0 : resizeObserver.unobserve(item);
          });
          record.addedNodes.forEach((item) => {
            resizeObserver == null ? void 0 : resizeObserver.observe(item);
          });
        });
        handleResize();
        updateScrollButtonState();
      };
      const win = ownerWindow(tabsRef.current);
      win.addEventListener("resize", handleResize);
      let mutationObserver;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver = new ResizeObserver(handleResize);
        Array.from(tabListRef.current.children).forEach((child) => {
          resizeObserver.observe(child);
        });
      }
      if (typeof MutationObserver !== "undefined") {
        mutationObserver = new MutationObserver(handleMutation);
        mutationObserver.observe(tabListRef.current, {
          childList: true
        });
      }
      return () => {
        handleResize.clear();
        win.removeEventListener("resize", handleResize);
        mutationObserver == null ? void 0 : mutationObserver.disconnect();
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
      };
    }, [updateIndicatorState, updateScrollButtonState]);
    reactExports.useEffect(() => {
      const tabListChildren = Array.from(tabListRef.current.children);
      const length2 = tabListChildren.length;
      if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
        const firstTab = tabListChildren[0];
        const lastTab = tabListChildren[length2 - 1];
        const observerOptions = {
          root: tabsRef.current,
          threshold: 0.99
        };
        const handleScrollButtonStart = (entries) => {
          setDisplayStartScroll(!entries[0].isIntersecting);
        };
        const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
        firstObserver.observe(firstTab);
        const handleScrollButtonEnd = (entries) => {
          setDisplayEndScroll(!entries[0].isIntersecting);
        };
        const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
        lastObserver.observe(lastTab);
        return () => {
          firstObserver.disconnect();
          lastObserver.disconnect();
        };
      }
      return void 0;
    }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
    reactExports.useEffect(() => {
      setMounted(true);
    }, []);
    reactExports.useEffect(() => {
      updateIndicatorState();
    });
    reactExports.useEffect(() => {
      scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
    }, [scrollSelectedIntoView, indicatorStyle]);
    reactExports.useImperativeHandle(action, () => ({
      updateIndicator: updateIndicatorState,
      updateScrollButtons: updateScrollButtonState
    }), [updateIndicatorState, updateScrollButtonState]);
    const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(TabsIndicator, {
      ...TabIndicatorProps,
      className: clsx(classes.indicator, TabIndicatorProps.className),
      ownerState,
      style: {
        ...indicatorStyle,
        ...TabIndicatorProps.style
      }
    });
    let childIndex = 0;
    const children = reactExports.Children.map(childrenProp, (child) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      valueToIndex.set(childValue, childIndex);
      const selected = childValue === value;
      childIndex += 1;
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        fullWidth: variant === "fullWidth",
        indicator: selected && !mounted && indicator,
        selected,
        selectionFollowsFocus,
        onChange,
        textColor,
        value: childValue,
        ...childIndex === 1 && value === false && !child.props.tabIndex ? {
          tabIndex: 0
        } : {}
      });
    });
    const handleKeyDown = (event) => {
      const list = tabListRef.current;
      const currentFocus = ownerDocument(list).activeElement;
      const role = currentFocus.getAttribute("role");
      if (role !== "tab") {
        return;
      }
      let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
      let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
      if (orientation === "horizontal" && isRtl) {
        previousItemKey = "ArrowRight";
        nextItemKey = "ArrowLeft";
      }
      switch (event.key) {
        case previousItemKey:
          event.preventDefault();
          moveFocus(list, currentFocus, previousItem);
          break;
        case nextItemKey:
          event.preventDefault();
          moveFocus(list, currentFocus, nextItem);
          break;
        case "Home":
          event.preventDefault();
          moveFocus(list, null, nextItem);
          break;
        case "End":
          event.preventDefault();
          moveFocus(list, null, previousItem);
          break;
      }
    };
    const conditionalElements = getConditionalElements();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsRoot, {
      className: clsx(classes.root, className),
      ownerState,
      ref,
      as: component,
      ...other,
      children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsScroller, {
        className: classes.scroller,
        ownerState,
        style: {
          overflow: scrollerStyle.overflow,
          [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
        },
        ref: tabsRef,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FlexContainer, {
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledBy,
          "aria-orientation": orientation === "vertical" ? "vertical" : null,
          className: classes.flexContainer,
          ownerState,
          onKeyDown: handleKeyDown,
          ref: tabListRef,
          role: "tablist",
          children
        }), mounted && indicator]
      }), conditionalElements.scrollButtonEnd]
    });
  });
  const BoxDiv = ({ title, children, toggleOpen = true, togglable = true }) => {
    const [isOpen, setIsOpen] = reactExports.useState(toggleOpen);
    const toggleBody = () => {
      if (togglable) {
        setIsOpen(!isOpen);
      }
    };
    return /* @__PURE__ */ React$1.createElement("div", { className: "box" }, /* @__PURE__ */ React$1.createElement("h2", { onClick: toggleBody, style: { cursor: togglable ? "pointer" : "default", display: "flex", alignItems: "center" } }, title, /* @__PURE__ */ React$1.createElement(Icon, { style: { marginLeft: "2px" } }, isOpen ? "expand_more" : "chevron_right")), isOpen && /* @__PURE__ */ React$1.createElement("div", { className: "dashboard-body" }, children));
  };
  var withSelector = { exports: {} };
  var useSyncExternalStoreWithSelector_production_min = {};
  /**
   * @license React
   * use-sync-external-store-with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var g = reactExports;
  function n(a, b2) {
    return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
  }
  var p = "function" === typeof Object.is ? Object.is : n, q = g.useSyncExternalStore, r = g.useRef, t = g.useEffect, u = g.useMemo, v = g.useDebugValue;
  useSyncExternalStoreWithSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e3, l2, h2) {
    var c6 = r(null);
    if (null === c6.current) {
      var f2 = { hasValue: false, value: null };
      c6.current = f2;
    } else f2 = c6.current;
    c6 = u(function() {
      function a2(a3) {
        if (!c7) {
          c7 = true;
          d3 = a3;
          a3 = l2(a3);
          if (void 0 !== h2 && f2.hasValue) {
            var b3 = f2.value;
            if (h2(b3, a3)) return k2 = b3;
          }
          return k2 = a3;
        }
        b3 = k2;
        if (p(d3, a3)) return b3;
        var e4 = l2(a3);
        if (void 0 !== h2 && h2(b3, e4)) return b3;
        d3 = a3;
        return k2 = e4;
      }
      var c7 = false, d3, k2, m2 = void 0 === e3 ? null : e3;
      return [function() {
        return a2(b2());
      }, null === m2 ? void 0 : function() {
        return a2(m2());
      }];
    }, [b2, e3, l2, h2]);
    var d2 = q(a, c6[0], c6[1]);
    t(function() {
      f2.hasValue = true;
      f2.value = d2;
    }, [d2]);
    v(d2);
    return d2;
  };
  {
    withSelector.exports = useSyncExternalStoreWithSelector_production_min;
  }
  var withSelectorExports = withSelector.exports;
  var React = (
    // prettier-ignore
    // @ts-ignore
    "default" in ReactOriginal ? React$1 : ReactOriginal
  );
  var ContextKey = Symbol.for(`react-redux-context`);
  var gT = typeof globalThis !== "undefined" ? globalThis : (
    /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
    {}
  );
  function getContext() {
    if (!React.createContext)
      return {};
    const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
    let realContext = contextMap.get(React.createContext);
    if (!realContext) {
      realContext = React.createContext(
        null
      );
      contextMap.set(React.createContext, realContext);
    }
    return realContext;
  }
  var ReactReduxContext = /* @__PURE__ */ getContext();
  var notInitialized = () => {
    throw new Error("uSES not initialized!");
  };
  function createReduxContextHook(context = ReactReduxContext) {
    return function useReduxContext2() {
      const contextValue = React.useContext(context);
      return contextValue;
    };
  }
  var useReduxContext = /* @__PURE__ */ createReduxContextHook();
  var useSyncExternalStoreWithSelector = notInitialized;
  var initializeUseSelector = (fn) => {
    useSyncExternalStoreWithSelector = fn;
  };
  var refEquality = (a, b2) => a === b2;
  function createSelectorHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = (selector, equalityFnOrOptions = {}) => {
      const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
      const {
        store: store2,
        subscription,
        getServerState,
        stabilityCheck,
        identityFunctionCheck
      } = useReduxContext2();
      React.useRef(true);
      const wrappedSelector = React.useCallback(
        {
          [selector.name](state) {
            const selected = selector(state);
            return selected;
          }
        }[selector.name],
        [selector, stabilityCheck, devModeChecks.stabilityCheck]
      );
      const selectedState = useSyncExternalStoreWithSelector(
        subscription.addNestedSub,
        store2.getState,
        getServerState || store2.getState,
        wrappedSelector,
        equalityFn
      );
      React.useDebugValue(selectedState);
      return selectedState;
    };
    Object.assign(useSelector2, {
      withTypes: () => useSelector2
    });
    return useSelector2;
  }
  var useSelector = /* @__PURE__ */ createSelectorHook();
  function defaultNoopBatch(callback) {
    callback();
  }
  function createListenerCollection() {
    let first = null;
    let last = null;
    return {
      clear() {
        first = null;
        last = null;
      },
      notify() {
        defaultNoopBatch(() => {
          let listener = first;
          while (listener) {
            listener.callback();
            listener = listener.next;
          }
        });
      },
      get() {
        const listeners = [];
        let listener = first;
        while (listener) {
          listeners.push(listener);
          listener = listener.next;
        }
        return listeners;
      },
      subscribe(callback) {
        let isSubscribed = true;
        const listener = last = {
          callback,
          next: null,
          prev: last
        };
        if (listener.prev) {
          listener.prev.next = listener;
        } else {
          first = listener;
        }
        return function unsubscribe() {
          if (!isSubscribed || first === null)
            return;
          isSubscribed = false;
          if (listener.next) {
            listener.next.prev = listener.prev;
          } else {
            last = listener.prev;
          }
          if (listener.prev) {
            listener.prev.next = listener.next;
          } else {
            first = listener.next;
          }
        };
      }
    };
  }
  var nullListeners = {
    notify() {
    },
    get: () => []
  };
  function createSubscription(store2, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener) {
      trySubscribe();
      const cleanupListener = listeners.subscribe(listener);
      let removed = false;
      return () => {
        if (!removed) {
          removed = true;
          cleanupListener();
          tryUnsubscribe();
        }
      };
    }
    function notifyNestedSubs() {
      listeners.notify();
    }
    function handleChangeWrapper() {
      if (subscription.onStateChange) {
        subscription.onStateChange();
      }
    }
    function isSubscribed() {
      return selfSubscribed;
    }
    function trySubscribe() {
      subscriptionsAmount++;
      if (!unsubscribe) {
        unsubscribe = store2.subscribe(handleChangeWrapper);
        listeners = createListenerCollection();
      }
    }
    function tryUnsubscribe() {
      subscriptionsAmount--;
      if (unsubscribe && subscriptionsAmount === 0) {
        unsubscribe();
        unsubscribe = void 0;
        listeners.clear();
        listeners = nullListeners;
      }
    }
    function trySubscribeSelf() {
      if (!selfSubscribed) {
        selfSubscribed = true;
        trySubscribe();
      }
    }
    function tryUnsubscribeSelf() {
      if (selfSubscribed) {
        selfSubscribed = false;
        tryUnsubscribe();
      }
    }
    const subscription = {
      addNestedSub,
      notifyNestedSubs,
      handleChangeWrapper,
      isSubscribed,
      trySubscribe: trySubscribeSelf,
      tryUnsubscribe: tryUnsubscribeSelf,
      getListeners: () => listeners
    };
    return subscription;
  }
  var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
  var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var useIsomorphicLayoutEffect$1 = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
  function Provider({
    store: store2,
    context,
    children,
    serverState,
    stabilityCheck = "once",
    identityFunctionCheck = "once"
  }) {
    const contextValue = React.useMemo(() => {
      const subscription = createSubscription(store2);
      return {
        store: store2,
        subscription,
        getServerState: serverState ? () => serverState : void 0,
        stabilityCheck,
        identityFunctionCheck
      };
    }, [store2, serverState, stabilityCheck, identityFunctionCheck]);
    const previousState = React.useMemo(() => store2.getState(), [store2]);
    useIsomorphicLayoutEffect$1(() => {
      const { subscription } = contextValue;
      subscription.onStateChange = subscription.notifyNestedSubs;
      subscription.trySubscribe();
      if (previousState !== store2.getState()) {
        subscription.notifyNestedSubs();
      }
      return () => {
        subscription.tryUnsubscribe();
        subscription.onStateChange = void 0;
      };
    }, [contextValue, previousState]);
    const Context2 = context || ReactReduxContext;
    return /* @__PURE__ */ React.createElement(Context2.Provider, { value: contextValue }, children);
  }
  var Provider_default = Provider;
  initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
  var jquery = { exports: {} };
  /*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   */
  (function(module) {
    (function(global2, factory) {
      {
        module.exports = global2.document ? factory(global2, true) : function(w2) {
          if (!w2.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w2);
        };
      }
    })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice2 = arr.slice;
      var flat = arr.flat ? function(array2) {
        return arr.flat.call(array2);
      } : function(array2) {
        return arr.concat.apply([], array2);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction = function isFunction2(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code, node2, doc) {
        doc = doc || document2;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node2) {
          for (i in preservedScriptAttributes) {
            val = node2[i] || node2.getAttribute && node2.getAttribute(i);
            if (val) {
              script.setAttribute(i, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      var version = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      };
      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice2.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice2.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice2.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i) {
            return (i + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i) {
            return i % 2;
          }));
        },
        eq: function(i) {
          var len = this.length, j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy2, copyIsArray, clone, target = arguments[0] || {}, i = 1, length2 = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i] || {};
          i++;
        }
        if (typeof target !== "object" && !isFunction(target)) {
          target = {};
        }
        if (i === length2) {
          target = this;
          i--;
        }
        for (; i < length2; i++) {
          if ((options = arguments[i]) != null) {
            for (name in options) {
              copy2 = options[name];
              if (name === "__proto__" || target === copy2) {
                continue;
              }
              if (deep && copy2 && (jQuery.isPlainObject(copy2) || (copyIsArray = Array.isArray(copy2)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }
                copyIsArray = false;
                target[name] = jQuery.extend(deep, clone, copy2);
              } else if (copy2 !== void 0) {
                target[name] = copy2;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
          DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length2, i = 0;
          if (isArrayLike(obj)) {
            length2 = obj.length;
            for (; i < length2; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node2, ret = "", i = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node2 = elem[i++]) {
              ret += jQuery.text(node2);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second2) {
          var len = +second2.length, j = 0, i = first.length;
          for (; j < len; j++) {
            first[i++] = second2[j];
          }
          first.length = i;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse, matches = [], i = 0, length2 = elems.length, callbackExpect = !invert;
          for (; i < length2; i++) {
            callbackInverse = !callback(elems[i], i);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg2) {
          var length2, value, i = 0, ret = [];
          if (isArrayLike(elems)) {
            length2 = elems.length;
            for (; i < length2; i++) {
              value = callback(elems[i], i, arg2);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg2);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length2 = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length2 === 0 || typeof length2 === "number" && length2 > 0 && length2 - 1 in obj;
      }
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace2 = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$",
        "g"
      );
      jQuery.contains = function(a, b2) {
        var bup = b2 && b2.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch2, asCodePoint) {
        if (asCodePoint) {
          if (ch2 === "\0") {
            return "�";
          }
          return ch2.slice(0, -1) + "\\" + ch2.charCodeAt(ch2.length - 1).toString(16) + " ";
        }
        return "\\" + ch2;
      }
      jQuery.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push;
      (function() {
        var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache2(), tokenCache = createCache2(), compilerCache = createCache2(), nonnativeSelectorCache = createCache2(), sortOrder = function(a, b2) {
          if (a === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier2 = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier2 + ")(?:" + whitespace2 + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier2 + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier2 + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier2 + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier2 + ")"),
          CLASS: new RegExp("^\\.(" + identifier2 + ")"),
          TAG: new RegExp("^(" + identifier2 + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push2.apply(
            arr = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e3) {
          push2 = {
            apply: function(target, els) {
              pushNative.apply(target, slice2.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice2.call(arguments, 1));
            }
          };
        }
        function find(selector, context, results, seed) {
          var m2, i2, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
                if (m2 = match2[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m2)) {
                      if (elem.id === m2) {
                        push2.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m2)) && find.contains(context, elem) && elem.id === m2) {
                      push2.call(results, elem);
                      return results;
                    }
                  }
                } else if (match2[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m2 = match2[3]) && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m2));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache2() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el2 = document3.createElement("fieldset");
          try {
            return !!fn(el2);
          } catch (e3) {
            return false;
          } finally {
            if (el2.parentNode) {
              el2.parentNode.removeChild(el2);
            }
            el2 = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j = matchIndexes[i2]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node2) {
          var subWindow, doc = node2 ? node2.ownerDocument || node2 : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el2) {
            documentElement2.appendChild(el2).id = jQuery.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
          });
          support.disconnectedMatch = assert(function(el2) {
            return matches.call(el2, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e3) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id2);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id2) {
              var attrId = id2.replace(runescape, funescape);
              return function(elem) {
                var node3 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node3 && node3.value === attrId;
              };
            };
            Expr.find.ID = function(id2, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node3, i2, elems, elem = context.getElementById(id2);
                if (elem) {
                  node3 = elem.getAttributeNode("id");
                  if (node3 && node3.value === id2) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id2);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node3 = elem.getAttributeNode("id");
                    if (node3 && node3.value === id2) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el2) {
            var input;
            documentElement2.appendChild(el2).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el2.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
            }
            if (!el2.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el2.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el2.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el2.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el2).disabled = true;
            if (el2.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el2.appendChild(input);
            if (!el2.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a, b2) {
            if (a === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b2.ownerDocument || b2) ? a.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a) === compare) {
              if (a === document3 || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument == preferredDoc && find.contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b2) : 0;
            }
            return compare & 4 ? -1 : 1;
          };
          return document3;
        }
        find.matches = function(expr, elements) {
          return find(expr, null, null, elements);
        };
        find.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e3) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find(expr, document3, null, [elem]).length > 0;
        };
        find.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery.contains(context, elem);
        };
        find.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name);
        };
        find.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice2.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              splice.call(results, duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery.fn.uniqueSort = function() {
          return this.pushStack(jQuery.uniqueSort(slice2.apply(this)));
        };
        Expr = jQuery.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match2) {
              match2[1] = match2[1].replace(runescape, funescape);
              match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
              if (match2[2] === "~=") {
                match2[3] = " " + match2[3] + " ";
              }
              return match2.slice(0, 4);
            },
            CHILD: function(match2) {
              match2[1] = match2[1].toLowerCase();
              if (match2[1].slice(0, 3) === "nth") {
                if (!match2[3]) {
                  find.error(match2[0]);
                }
                match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
              } else if (match2[3]) {
                find.error(match2[0]);
              }
              return match2;
            },
            PSEUDO: function(match2) {
              var excess, unquoted = !match2[6] && match2[2];
              if (matchExpr.CHILD.test(match2[0])) {
                return null;
              }
              if (match2[3]) {
                match2[2] = match2[4] || match2[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match2[0] = match2[0].slice(0, excess);
                match2[2] = unquoted.slice(0, excess);
              }
              return match2.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name, operator, check) {
              return function(elem) {
                var result = find.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                if (operator === "=") {
                  return result === check;
                }
                if (operator === "!=") {
                  return result !== check;
                }
                if (operator === "^=") {
                  return check && result.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result === check || result.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, outerCache, node2, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node2 = elem;
                      while (node2 = node2[dir2]) {
                        if (ofType ? nodeName(node2, name) : node2.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node2 = nodeIndex && parent.childNodes[nodeIndex];
                    while (node2 = ++nodeIndex && node2 && node2[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start2.pop()) {
                      if (node2.nodeType === 1 && ++diff && node2 === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node2 = ++nodeIndex && node2 && node2[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                        if ((ofType ? nodeName(node2, name) : node2.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node2[expando] || (node2[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node2 === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf.call(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile2(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash2 = window2.location && window2.location.hash;
              return hash2 && hash2.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length2) {
              return [length2 - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length2, argument) {
              return [argument < 0 ? argument + length2 : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length2) {
              var i2 = 0;
              for (; i2 < length2; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length2) {
              var i2 = 1;
              for (; i2 < length2; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length2, argument) {
              var i2;
              if (argument < 0) {
                i2 = argument + length2;
              } else if (argument > length2) {
                i2 = length2;
              } else {
                i2 = argument;
              }
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length2, argument) {
              var i2 = argument < 0 ? argument + length2 : argument;
              for (; ++i2 < length2; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match2 = rcomma.exec(soFar))) {
              if (match2) {
                soFar = soFar.slice(match2[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match2 = rleadingCombinator.exec(soFar)) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match2[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
                matched = match2.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match2
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            find(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i2 > 1 && elementMatcher(matchers),
                  i2 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher,
                  i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                  j < len && matcherFromTokens(tokens = tokens.slice(j)),
                  j < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    push2.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile2(selector, match2) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match2) {
              match2 = tokenize(selector);
            }
            i2 = match2.length;
            while (i2--) {
              cached = matcherFromTokens(match2[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select(selector, context, results, seed) {
          var i2, tokens, token2, type, find2, compiled = typeof selector === "function" && selector, match2 = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match2.length === 1) {
            tokens = match2[0] = match2[0].slice(0);
            if (tokens.length > 2 && (token2 = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token2.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i2--) {
              token2 = tokens[i2];
              if (Expr.relative[type = token2.type]) {
                break;
              }
              if (find2 = Expr.find[type]) {
                if (seed = find2(
                  token2.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile2(selector, match2))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el2) {
          return el2.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery.find = find;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = jQuery.uniqueSort;
        find.compile = compile2;
        find.select = select;
        find.setDocument = setDocument;
        find.tokenize = tokenize;
        find.escape = jQuery.escapeSelector;
        find.getText = jQuery.text;
        find.isXML = jQuery.isXMLDoc;
        find.selectors = jQuery.expr;
        find.support = jQuery.support;
        find.uniqueSort = jQuery.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n2, elem) {
        var matched = [];
        for (; n2; n2 = n2.nextSibling) {
          if (n2.nodeType === 1 && n2 !== elem) {
            matched.push(n2);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
          return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery.filter(qualifier, elements, not);
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self2[i], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i = 0; i < len; i++) {
            jQuery.find(selector, self2[i], ret);
          }
          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match2, elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match2 = [null, selector, null];
          } else {
            match2 = rquickExpr.exec(selector);
          }
          if (match2 && (match2[1] || !context)) {
            if (match2[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(
                match2[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match2[1]) && jQuery.isPlainObject(context)) {
                for (match2 in context) {
                  if (isFunction(this[match2])) {
                    this[match2](context[match2]);
                  } else {
                    this.attr(match2, context[match2]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match2[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction(selector)) {
          return root.ready !== void 0 ? root.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery)
          );
        }
        return jQuery.makeArray(selector, this);
      };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this), l2 = targets.length;
          return this.filter(function() {
            var i = 0;
            for (; i < l2; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i < l2; i++) {
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery.uniqueSort(
              jQuery.merge(this.get(), jQuery(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object2 = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
          object2[flag] = true;
        });
        return object2;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg2) {
                  if (isFunction(arg2)) {
                    if (!options.unique || !self2.has(arg2)) {
                      list.push(arg2);
                    }
                  } else if (arg2 && arg2.length && toType(arg2) !== "string") {
                    add(arg2);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery.each(arguments, function(_, arg2) {
              var index;
              while ((index = jQuery.inArray(arg2, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v2) {
        return v2;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
          if (value && isFunction(method = value.promise)) {
            method.call(value).done(resolve).fail(reject);
          } else if (value && isFunction(method = value.then)) {
            method.call(value, resolve, reject);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject.apply(void 0, [value2]);
        }
      }
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery.Callbacks("memory"),
              jQuery.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(_i, tuple) {
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e3) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(
                          e3,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e3];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery.Deferred.getErrorHook) {
                      process2.error = jQuery.Deferred.getErrorHook();
                    } else if (jQuery.Deferred.getStackHook) {
                      process2.error = jQuery.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery.each(tuples, function(i, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(
                function() {
                  state = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
            return function(value) {
              resolveContexts[i2] = this;
              resolveValues[i2] = arguments.length > 1 ? slice2.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
              return primary.then();
            }
          }
          while (i--) {
            adoptValue(resolveValues[i], updateFunc(i), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function(error, asyncError) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error.message,
            error.stack,
            asyncError
          );
        }
      };
      jQuery.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery.Deferred();
      jQuery.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery.readyException(error);
        });
        return this;
      };
      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i in key) {
            access(elems, fn, i, key[i], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value2) {
                return bulk.call(jQuery(elem), value2);
              };
            }
          }
          if (fn) {
            for (; i < len; i++) {
              fn(
                elems[i],
                key,
                raw ? value : value.call(elems[i], i, fn(elems[i], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache = this.cache(owner);
          if (typeof data === "string") {
            cache[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache[camelCase(prop)] = data[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i, cache = owner[this.expando];
          if (cache === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }
            i = key.length;
            while (i--) {
              delete cache[key[i]];
            }
          }
          if (key === void 0 || jQuery.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== void 0 && !jQuery.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name;
        if (data === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e3) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i, name, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;
                while (i--) {
                  if (attrs[i]) {
                    name = attrs[i].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next2 = function() {
            jQuery.dequeue(elem, type);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next2, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
            if (!--count) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el2) {
        elem = el2 || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit2 = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit2 !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit2) {
          initial = initial / 2;
          unit2 = unit2 || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery.style(elem, prop, initialInUnit + unit2);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit2);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit2;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values2 = [], index = 0, length2 = elements.length;
        for (; index < length2; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values2[index] = dataPriv.get(elem, "display") || null;
              if (!values2[index]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values2[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values2[index] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index = 0; index < length2; index++) {
          if (values2[index] != null) {
            elements[index].style.display = values2[index];
          }
        }
        return elements;
      }
      jQuery.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i = 0, l2 = elems.length;
        for (; i < l2; i++) {
          dataPriv.set(
            elems[i],
            "globalEval",
            !refElements || dataPriv.get(refElements[i], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l2 = elems.length;
        for (; i < l2; i++) {
          elem = elems[i];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
              j = wrap[0];
              while (j--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i = 0;
        while (elem = nodes[i++]) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j = 0;
            while (elem = tmp[j++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on(elem, types, selector, data, fn, one2) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type in types) {
            on(elem, type, selector, data, types[type], one2);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = void 0;
          } else {
            fn = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one2 === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e3) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e3.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t2 = types.length;
          while (t2--) {
            tmp = rtypenamespace.exec(types[t2]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery.event.special[type] || {};
            handleObj = jQuery.extend({
              type,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t2 = types.length;
          while (t2--) {
            tmp = rtypenamespace.exec(types[t2]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t2], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j = handlers.length;
            while (j--) {
              handleObj = handlers[j];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
          args[0] = event;
          for (i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i = 0;
          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;
            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i = 0; i < delegateCount; i++) {
                  handleObj = handlers[i];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data) {
              var el2 = this || data;
              if (rcheckableType.test(el2.type) && el2.click && nodeName(el2, "input")) {
                leverageNative(el2, "click", true);
              }
              return false;
            },
            trigger: function(data) {
              var el2 = this || data;
              if (rcheckableType.test(el2.type) && el2.click && nodeName(el2, "input")) {
                leverageNative(el2, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el2, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el2, type) === void 0) {
            jQuery.event.add(el2, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el2, type, false);
        jQuery.event.add(el2, type, {
          namespace: false,
          handler: function(event) {
            var result, saved = dataPriv.get(this, type);
            if (event.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice2.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result;
                }
              } else if ((jQuery.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e3 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.preventDefault();
          }
        },
        stopPropagation: function() {
          var e3 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e3 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e3 && !this.isSimulated) {
            e3.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery.event.fix(nativeEvent)
            );
          }
        }
        jQuery.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType
        };
        jQuery.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i, l2, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i = 0, l2 = events[type].length; i < l2; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first, scripts, hasScripts, node2, doc, i = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction(value);
        if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index) {
            var self2 = collection.eq(index);
            if (valueIsFunction) {
              args[0] = value.call(this, index, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l2) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i < l2; i++) {
              node2 = fragment;
              if (i !== iNoClone) {
                node2 = jQuery.clone(node2, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node2, "script"));
                }
              }
              callback.call(collection[i], node2, i);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i = 0; i < hasScripts; i++) {
                node2 = scripts[i];
                if (rscriptType.test(node2.type || "") && !dataPriv.access(node2, "globalEval") && jQuery.contains(doc, node2)) {
                  if (node2.src && (node2.type || "").toLowerCase() !== "module") {
                    if (jQuery._evalUrl && !node2.noModule) {
                      jQuery._evalUrl(node2.src, {
                        nonce: node2.nonce || node2.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node2.textContent.replace(rcleanScript, ""), node2, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node2, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node2 = nodes[i]) != null; i++) {
          if (!keepData && node2.nodeType === 1) {
            jQuery.cleanData(getAll(node2));
          }
          if (node2.parentNode) {
            if (keepData && isAttached(node2)) {
              setGlobalEval(getAll(node2, "script"));
            }
            node2.parentNode.removeChild(node2);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i = 0, l2 = srcElements.length; i < l2; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i = 0, l2 = srcElements.length; i < l2; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        cleanData: function(elems) {
          var data, elem, type, special = jQuery.event.special, i = 0;
          for (; (elem = elems[i]) !== void 0; i++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type);
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i = 0;
          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i = 0, l2 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery.htmlPrefilter(value2);
              try {
                for (; i < l2; i++) {
                  elem = this[i] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e3) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name, old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "box-sizing:content-box;border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width2, minWidth2, maxWidth2, ret, isCustomProp = rcustomProp.test(name), style2 = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width2 = style2.width;
            minWidth2 = style2.minWidth;
            maxWidth2 = style2.maxWidth;
            style2.minWidth = style2.maxWidth = style2.width = ret;
            ret = computed.width;
            style2.width = width2;
            style2.minWidth = minWidth2;
            style2.maxWidth = maxWidth2;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
          name = cssPrefixes[i] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles2, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i < 4; i += 2) {
          if (box === "margin") {
            marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles2);
          }
          if (!isBorderBox) {
            delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles2);
            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            }
          } else {
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles2);
            }
            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles2 = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles2) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles2), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles2) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles2) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles2,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style2 = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style2[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style2.setProperty(name, value);
              } else {
                style2[name] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style2[name];
          }
        },
        css: function(elem, name, extra, styles2) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles2);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles2 = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles2.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles2) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles2
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles2[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles2) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix2, suffix) {
        jQuery.cssHooks[prefix2 + suffix] = {
          expand: function(value) {
            var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i < 4; i++) {
              expanded[prefix2 + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix2 !== "margin") {
          jQuery.cssHooks[prefix2 + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name2, value2) {
            var styles2, len, map2 = {}, i = 0;
            if (Array.isArray(name2)) {
              styles2 = getStyles(elem);
              len = name2.length;
              for (; i < len; i++) {
                map2[name2[i]] = jQuery.css(elem, name2[i], false, styles2);
              }
              return map2;
            }
            return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
          }, name, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end2, easing2) {
        return new Tween.prototype.init(elem, options, prop, end2, easing2);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end2, easing2, unit2) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing2 || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end2;
          this.unit = unit2 || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function(p2) {
          return p2;
        },
        swing: function(p2) {
          return 0.5 - Math.cos(p2 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule2() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule2);
          } else {
            window2.setTimeout(schedule2, jQuery.fx.interval);
          }
          jQuery.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation2.tweeners[prop] || []).concat(Animation2.tweeners["*"]), index = 0, length2 = collection.length;
        for (; index < length2; index++) {
          if (tween = collection[index].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style2 = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style2.overflow, style2.overflowX, style2.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style2.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style2.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style2.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style2.overflow = "hidden";
          anim.always(function() {
            style2.overflow = opts.overflow[0];
            style2.overflowX = opts.overflow[1];
            style2.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index, name, easing2, value, hooks;
        for (index in props) {
          name = camelCase(index);
          easing2 = specialEasing[name];
          value = props[index];
          if (Array.isArray(value)) {
            easing2 = value[1];
            value = props[index] = value[0];
          }
          if (index !== name) {
            props[name] = value;
            delete props[index];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing2;
              }
            }
          } else {
            specialEasing[name] = easing2;
          }
        }
      }
      function Animation2(elem, properties2, options) {
        var result, stopped, index = 0, length2 = Animation2.prefilters.length, deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length3 = animation.tweens.length;
          for (; index2 < length3; index2++) {
            animation.tweens[index2].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length3) {
            return remaining;
          }
          if (!length3) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery.extend({}, properties2),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties2,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end2) {
            var tween = jQuery.Tween(
              elem,
              animation.opts,
              prop,
              end2,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index2 = 0, length3 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index2 < length3; index2++) {
              animation.tweens[index2].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length2; index++) {
          result = Animation2.prefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction(result.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(
          jQuery.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery.Animation = jQuery.extend(Animation2, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index = 0, length2 = props.length;
          for (; index < length2; index++) {
            prop = props[index];
            Animation2.tweeners[prop] = Animation2.tweeners[prop] || [];
            Animation2.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation2.prefilters.unshift(callback);
          } else {
            Animation2.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing2, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing2 || isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing2 || easing2 && !isFunction(easing2) && easing2
        };
        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to2, easing2, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to2 }, speed, easing2, callback);
        },
        animate: function(prop, speed, easing2, callback) {
          var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing2, callback), doAnimation = function() {
            var anim = Animation2(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop2 = hooks.stop;
            delete hooks.stop;
            stop2(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length2 = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length2; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing2, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing2, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing2, callback) {
          return this.animate(props, speed, easing2, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i < timers.length; i++) {
          timer = timers[i];
          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule2();
      };
      jQuery.fx.stop = function() {
        inProgress = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery.fn.delay = function(time2, type) {
        time2 = jQuery.fx ? jQuery.fx.speeds[time2] || time2 : time2;
        type = type || "fx";
        return this.queue(type, function(next2, hooks) {
          var timeout = window2.setTimeout(next2, time2);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classNames, cur, curValue, className, i, finalValue;
          if (isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames, cur, curValue, className, i, finalValue;
          if (isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction(value)) {
            return this.each(function(i2) {
              jQuery(this).toggleClass(
                value.call(this, i2, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery(this);
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i = 0;
          className = " " + selector + " ";
          while (elem = this[i++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction(value);
          return this.each(function(i) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option, i, options = elem.options, index = elem.selectedIndex, one2 = elem.type === "select-one", values2 = one2 ? null : [], max2 = one2 ? index + 1 : options.length;
              if (index < 0) {
                i = max2;
              } else {
                i = one2 ? index : 0;
              }
              for (; i < max2; i++) {
                option = options[i];
                if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one2) {
                    return value;
                  }
                  values2.push(value);
                }
              }
              return values2;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values2 = jQuery.makeArray(value), i = options.length;
              while (i--) {
                option = options[i];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values2) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values2;
            }
          }
        }
      });
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e3) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el2) {
            return el2.textContent;
          }).join("\n") : data));
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e3) {
        e3.stopPropagation();
      };
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i = 0;
          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
          var e3 = jQuery.extend(
            new jQuery.Event(),
            event,
            {
              type,
              isSimulated: true
            }
          );
          jQuery.event.trigger(e3, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix2, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
          jQuery.each(obj, function(i, v2) {
            if (traditional || rbracket.test(prefix2)) {
              add(prefix2, v2);
            } else {
              buildParams(
                prefix2 + "[" + (typeof v2 === "object" && v2 != null ? i : "") + "]",
                v2,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix2 + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix2, obj);
        }
      }
      jQuery.param = function(a, traditional) {
        var prefix2, s = [], add = function(key, valueOrFunction) {
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) {
          return "";
        }
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
          jQuery.each(a, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix2 in a) {
            buildParams(prefix2, a[prefix2], traditional, add);
          }
        }
        return s.join("&");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i, elem) {
            var val = jQuery(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction(func)) {
            while (dataType = dataTypes[i++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current2, conv, tmp, prev2, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }
        current2 = dataTypes.shift();
        while (current2) {
          if (s.responseFields[current2]) {
            jqXHR[s.responseFields[current2]] = response;
          }
          if (!prev2 && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }
          prev2 = current2;
          current2 = dataTypes.shift();
          if (current2) {
            if (current2 === "*") {
              current2 = prev2;
            } else if (prev2 !== "*" && prev2 !== current2) {
              conv = converters[prev2 + " " + current2] || converters["* " + current2];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current2) {
                    conv = converters[prev2 + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current2 = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e3) {
                    return {
                      state: "parsererror",
                      error: conv ? e3 : "No conversion from " + prev2 + " to " + current2
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match2;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match2 = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                  }
                }
                match2 = responseHeaders[key.toLowerCase() + " "];
              }
              return match2 == null ? null : match2.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name, value) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map2) {
              var code;
              if (map2) {
                if (completed2) {
                  jqXHR.always(map2[jqXHR.status]);
                } else {
                  for (code in map2) {
                    statusCode[code] = [statusCode[code], map2[code]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
          s.type = options.method || options.type || s.method || s.type;
          s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s.url;
              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e3) {
              s.crossDomain = true;
            }
          }
          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s.type = s.type.toUpperCase();
          s.hasContent = !rnoContent.test(s.type);
          cacheURL = s.url.replace(rhash, "");
          if (!s.hasContent) {
            uncached = s.url.slice(cacheURL.length);
            if (s.data && (s.processData || typeof s.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
              delete s.data;
            }
            if (s.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s.url = cacheURL + uncached;
          } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s.data = s.data.replace(r20, "+");
          }
          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
          );
          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          }
          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s.complete);
          jqXHR.done(s.success);
          jqXHR.fail(s.error);
          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s.async && s.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e3) {
              if (completed2) {
                throw e3;
              }
              done(-1, e3);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            }
            if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
              s.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s, isSuccess ? success : error]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
              if (!--jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, void 0, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
          if (isFunction(data)) {
            type = type || callback;
            callback = data;
            data = void 0;
          }
          return jQuery.ajax(jQuery.extend({
            url,
            type: method,
            dataType: type,
            data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function(s) {
        var i;
        for (i in s.headers) {
          if (i.toLowerCase() === "content-type") {
            s.contentType = s.headers[i] || "";
          }
        }
      });
      jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (this[0]) {
            if (isFunction(html)) {
              html = html.call(this[0]);
            }
            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }
          return this.each(function() {
            var self2 = jQuery(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction(html);
          return this.each(function(i) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };
      jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e3) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e3) {
                if (callback) {
                  throw e3;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) {
          s.contents.script = false;
        }
      });
      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      });
      jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === void 0) {
          s.cache = false;
        }
        if (s.crossDomain) {
          s.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain || s.scriptAttrs) {
          var script, callback;
          return {
            send: function(_, complete) {
              script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
          callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          }
          s.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s[callbackName]) {
              s.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery.offset = {
        setOffset: function(elem, options, i) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position2 = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
          if (position2 === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position2 === "absolute" || position2 === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction(options)) {
            options = options.call(elem, i, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery.css(elem, "position") === "fixed") {
            offset2 = elem.getBoundingClientRect();
          } else {
            offset2 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top2 = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top2 ? val2 : win.pageXOffset,
                top2 ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin2, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin2 !== "boolean"), extra = defaultExtra || (margin2 === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery.style(elem, type2, value2, extra)
              );
            }, type, chainable ? margin2 : void 0, chainable);
          };
        });
      });
      jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i, type) {
        jQuery.fn[type] = function(fn) {
          return this.on(type, fn);
        };
      });
      jQuery.fn.extend({
        bind: function(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i, name) {
          jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction(fn)) {
          return void 0;
        }
        args = slice2.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice2.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };
      jQuery.holdReady = function(hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;
      jQuery.isNumeric = function(obj) {
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery.noConflict = function(deep) {
        if (window2.$ === jQuery) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery) {
          window2.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery;
      }
      return jQuery;
    });
  })(jquery);
  var jqueryExports = jquery.exports;
  const $ = /* @__PURE__ */ getDefaultExportFromCjs(jqueryExports);
  class PopularityImpl {
    constructor(city, popularity, fame) {
      this.city = city;
      this.popularity = popularity;
      this.fame = fame;
    }
  }
  function useGlobalPopularityAndFame() {
    const [popularityList, setPopularityList] = reactExports.useState([]);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const artistId = useSelector((state) => state.artist.artistId);
    reactExports.useEffect(() => {
      if (!artistId) return;
      function getUrlDomain() {
        return window.location.hostname;
      }
      function fetchPopularityAndFame() {
        let iframe = $('<iframe id="iframe-global-data" style="display:none;"></iframe>');
        $("body").append(iframe);
        const urlDomain = getUrlDomain();
        const url = `https://${urlDomain}/World/Popmundo.aspx/Artist/Popularity/${artistId}`;
        $("#iframe-global-data").attr("src", url);
        $("#iframe-global-data").on("load", function() {
          const iframeContents = $("#iframe-global-data").contents();
          const rows = iframeContents.find("#tablefame tbody tr");
          const newPopularityList = [];
          rows.each(function() {
            const city = $(this).find("td:nth-child(1) a").text().trim();
            const popularity = parseInt($(this).find("td:nth-child(2) .sortkey").text(), 10) - 1;
            const fame = parseInt($(this).find("td:nth-child(3) .sortkey").text(), 10);
            if (!isNaN(popularity) && !isNaN(fame)) {
              newPopularityList.push(new PopularityImpl(city, popularity, fame));
            }
          });
          setPopularityList(newPopularityList);
          setIsLoading(false);
          $("#iframe-global-data").remove();
        });
      }
      fetchPopularityAndFame();
    }, [artistId]);
    return { popularityList, isLoading };
  }
  class SegmentationImpl {
    constructor(segmentation, value) {
      this.segmentation = segmentation;
      this.value = value;
    }
  }
  function useSegmentation() {
    const [segmentationList, setSegmentationList] = reactExports.useState([]);
    const [isLoadingSegmentation, setIsLoadingSegmentation] = reactExports.useState(true);
    const artistId = useSelector((state) => state.artist.artistId);
    reactExports.useEffect(() => {
      if (!artistId) return;
      function isNullOrEmpty(value) {
        return !value || value.trim().length === 0;
      }
      function getUrlDomain() {
        return window.location.hostname;
      }
      function fetchSegmentation() {
        let iframe = $('<iframe id="iframe-segmentation" style="display:none;"></iframe>');
        $("body").append(iframe);
        let urlDomain = getUrlDomain();
        let url = `https://${urlDomain}/World/Popmundo.aspx/Artist/Popularity/${artistId}`;
        $("#iframe-segmentation").attr("src", url);
        $("#iframe-segmentation").on("load", function() {
          let iframeContents = $("#iframe-segmentation").contents();
          const rows = iframeContents.find("#tablemarketsegments tbody tr");
          const newSegmentationList = [];
          rows.each(function() {
            const marketSegmentation = $(this).find("td:nth-child(1)").text().trim();
            const value = parseInt($(this).find("td:nth-child(2) .sortkey").text(), 10);
            if (!isNullOrEmpty(marketSegmentation) && !isNaN(value)) {
              newSegmentationList.push(new SegmentationImpl(marketSegmentation, value));
            }
          });
          setSegmentationList(newSegmentationList);
          setIsLoadingSegmentation(false);
          $("#iframe-segmentation").remove();
        });
      }
      fetchSegmentation();
    }, [artistId]);
    return { segmentationList, isLoadingSegmentation };
  }
  const FameAndPopularitySection = () => {
    const { popularityList, isLoading } = useGlobalPopularityAndFame();
    const { segmentationList, isLoadingSegmentation } = useSegmentation();
    const totalPopularity = popularityList.reduce((acc, item) => acc + item.popularity, 0);
    const totalFame = popularityList.reduce((acc, item) => acc + item.fame, 0);
    const avgPopularity = popularityList.length > 0 ? totalPopularity / popularityList.length : 0;
    const avgFame = popularityList.length > 0 ? totalFame / popularityList.length : 0;
    const top4Fame = [...popularityList].sort((a, b2) => b2.fame - a.fame).slice(0, 4);
    const worst4Fame = [...popularityList].sort((a, b2) => a.fame - b2.fame).slice(0, 4);
    const top4Popularity = [...popularityList].sort((a, b2) => b2.popularity - a.popularity).slice(0, 4);
    const worst4Popularity = [...popularityList].sort((a, b2) => a.popularity - b2.popularity).slice(0, 4);
    return /* @__PURE__ */ React$1.createElement("div", { style: { display: "flex", flexDirection: "row", gap: 14, flexWrap: "wrap", justifyContent: "center", alignItems: "flex-start" } }, /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Artist Popularity" }, isLoading ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : /* @__PURE__ */ React$1.createElement("table", null, /* @__PURE__ */ React$1.createElement("tbody", null, /* @__PURE__ */ React$1.createElement("tr", null, /* @__PURE__ */ React$1.createElement("td", null, /* @__PURE__ */ React$1.createElement("b", null, "Global Pop")), /* @__PURE__ */ React$1.createElement("td", null, avgPopularity.toFixed(2))), /* @__PURE__ */ React$1.createElement("tr", null, /* @__PURE__ */ React$1.createElement("td", null, /* @__PURE__ */ React$1.createElement("b", null, "Global Fame")), /* @__PURE__ */ React$1.createElement("td", null, avgFame.toFixed(2), "%"))))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Top 4 city fame" }, isLoading ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : top4Fame.map((popularity, index) => /* @__PURE__ */ React$1.createElement("div", { key: index }, index + 1, ". ", /* @__PURE__ */ React$1.createElement("b", null, popularity.city), ": ", popularity.fame, "%"))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Worst 4 city fame" }, isLoading ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : worst4Fame.map((popularity, index) => /* @__PURE__ */ React$1.createElement("div", { key: index }, index + 1, ". ", /* @__PURE__ */ React$1.createElement("b", null, popularity.city), ": ", popularity.fame, "%"))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Top 4 city Pop" }, isLoading ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : top4Popularity.map((popularity, index) => /* @__PURE__ */ React$1.createElement("div", { key: index }, index + 1, ". ", /* @__PURE__ */ React$1.createElement("b", null, popularity.city), ": ", popularity.popularity))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Worst 4 city Pop" }, isLoading ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : worst4Popularity.map((popularity, index) => /* @__PURE__ */ React$1.createElement("div", { key: index }, index + 1, ". ", /* @__PURE__ */ React$1.createElement("b", null, popularity.city), ": ", popularity.popularity))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Market Segmentation" }, isLoadingSegmentation ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20 }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 50, height: 20, style: { marginTop: 8 } })) : /* @__PURE__ */ React$1.createElement("table", null, /* @__PURE__ */ React$1.createElement("tbody", null, segmentationList.map((segmentation, index) => /* @__PURE__ */ React$1.createElement("tr", { key: index }, /* @__PURE__ */ React$1.createElement("td", null, segmentation.segmentation, ":"), /* @__PURE__ */ React$1.createElement("td", null, segmentation.value, "%")))))));
  };
  class SingleImpl {
    constructor(title, sells, lastSell, lastSellDate, artistGain, recordLabelGain, evaluation, imageUrl, releaseDate, stock) {
      this.title = title;
      this.sells = sells;
      this.lastSell = lastSell;
      this.lastSellDate = lastSellDate;
      this.artistGain = artistGain;
      this.recordLabelGain = recordLabelGain;
      this.totalGain = artistGain + recordLabelGain;
      this.evaluation = evaluation;
      this.imageUrl = imageUrl;
      this.releaseDate = releaseDate;
      this.stock = stock;
    }
  }
  function useSingles() {
    const [singles, setSingles] = reactExports.useState([]);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const artistId = useSelector((state) => state.artist.artistId);
    reactExports.useEffect(() => {
      if (!artistId) return;
      function getUrlDomain() {
        return window.location.hostname;
      }
      function fetchSingles() {
        const iframeSingles = $('<iframe id="iframe-singles" style="display:none;"></iframe>');
        $("body").append(iframeSingles);
        const urlDomain = getUrlDomain();
        const url = `https://${urlDomain}/World/Popmundo.aspx/Artist/Records/${artistId}`;
        $("#iframe-singles").attr("src", url);
        $("#iframe-singles").on("load", function() {
          const iframeContents = $("#iframe-singles").contents();
          const singleElements = iframeContents.find("#tablesingles tbody tr").slice(0, 4);
          const singleHrefs = singleElements.map(function() {
            const singleHref = $(this).find("a").attr("href");
            return singleHref ? `https://${urlDomain}${singleHref}` : null;
          }).get().filter(Boolean);
          let singlesData = [];
          function fetchSingleSequentially(index = 0) {
            if (index >= singleHrefs.length) {
              setSingles(singlesData);
              setIsLoading(false);
              $("#iframe-singles").remove();
              return;
            }
            const singleUrl = singleHrefs[index];
            fetchSingleDetails(singleUrl).then((single) => {
              if (single) singlesData.push(single);
              fetchSingleSequentially(index + 1);
            });
          }
          fetchSingleSequentially();
        });
      }
      function fetchSingleDetails(url) {
        return new Promise((resolve) => {
          try {
            const iframeSingle = $('<iframe id="iframe-single" style="display:none;"></iframe>');
            $("body").append(iframeSingle);
            $("#iframe-single").attr("src", url);
            $("#iframe-single").on("load", function() {
              var _a;
              const singleContents = $("#iframe-single").contents();
              const recordCover = singleContents.find(".RecordCover").length ? singleContents.find(".RecordCover") : singleContents.find(".RecordCoverEmpty");
              const title = recordCover.next("table").find("tbody tr").eq(0).find("td").eq(1).text().trim();
              const releaseDateStr = singleContents.find(".RecordCover + table tbody tr").eq(2).find("td").eq(1).text().trim();
              const releaseDate = new Date(releaseDateStr);
              const sellsStr = singleContents.find("a#ctl00_cphLeftColumn_ctl01_lnkUnitsSold").text().replace(/\D/g, "");
              const sells = parseInt(sellsStr, 10) || 0;
              const stockStr = singleContents.find(".RecordCover + table tbody tr").eq(7).find("td").eq(1).text().replace(/\D/g, "");
              const stock = parseInt(stockStr, 10) || 0;
              const lastSellRow = singleContents.find("#tablerecentsales tbody tr").first();
              const lastSellDateStr = lastSellRow.find("td").eq(0).clone().children().remove().end().text().trim();
              const [day, month, year] = lastSellDateStr.split("/").map(Number);
              const lastSellDate = new Date(year, month - 1, day);
              const lastSellStr = lastSellRow.find("td").eq(1).text().replace(/\D/g, "");
              const lastSell = parseInt(lastSellStr, 10) || 0;
              const artistGainStr = singleContents.find(".RecordCover + table tbody tr").eq(10).find("td").last().text().replace(/[^0-9,]/g, "").replace(",", ".");
              const artistGain = parseFloat(artistGainStr) || 0;
              const recordLabelGainStr = singleContents.find(".RecordCover + table tbody tr").eq(11).find("td").last().text().replace(/[^0-9,]/g, "").replace(",", ".");
              const recordLabelGain = parseFloat(recordLabelGainStr) || 0;
              const evaluationStr = singleContents.find("tr").eq(8).find("a").attr("title") || "0/26";
              const evaluation = parseInt(evaluationStr.split("/")[0]) || 0;
              const imageUrl = ((_a = singleContents.find(".RecordCover").css("background-image")) == null ? void 0 : _a.slice(5, -2)) || "";
              const single = new SingleImpl(
                title,
                sells,
                lastSell,
                lastSellDate,
                artistGain,
                recordLabelGain,
                evaluation,
                imageUrl,
                releaseDate,
                stock
              );
              resolve(single);
              $("#iframe-single").remove();
            });
          } catch (error) {
            console.error("Error fetching single details:", error);
            resolve(null);
          }
        });
      }
      fetchSingles();
    }, [artistId]);
    console.log(singles);
    return { singles, isLoading };
  }
  const DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
  const DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
  const DEFAULT_MARGINS = {
    top: 50,
    bottom: 50,
    left: 50,
    right: 50
  };
  const HighlightedContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {
      highlightedItem: null,
      setHighlighted: () => {
      },
      clearHighlighted: () => {
      },
      isHighlighted: () => false,
      isFaded: () => false
    }
  });
  const createIsFaded = (highlightScope, highlightedItem) => (input) => {
    if (!highlightScope) {
      return false;
    }
    if (highlightScope.fade === "series") {
      return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId) && input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
    }
    if (highlightScope.fade === "global") {
      return input.seriesId !== (highlightedItem == null ? void 0 : highlightedItem.seriesId) || input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
    }
    return false;
  };
  const createIsHighlighted = (highlightScope, highlightedItem) => (input) => {
    if (!highlightScope) {
      return false;
    }
    if (highlightScope.highlight === "series") {
      return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
    }
    if (highlightScope.highlight === "item") {
      return input.dataIndex === (highlightedItem == null ? void 0 : highlightedItem.dataIndex) && input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
    }
    return false;
  };
  const DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
  function defaultizeColor(series, seriesIndex, colors3 = DEFAULT_COLORS) {
    if (series.type === "pie") {
      return _extends({}, series, {
        data: series.data.map((d2, index) => _extends({
          color: colors3[index % colors3.length]
        }, d2))
      });
    }
    return _extends({
      color: colors3[seriesIndex % colors3.length]
    }, series);
  }
  const preprocessSeries = ({
    series,
    colors: colors3,
    seriesFormatters,
    dataset
  }) => {
    const seriesGroups = {};
    series.forEach((seriesData, seriesIndex) => {
      var _a;
      const {
        id: id2 = `auto-generated-id-${seriesIndex}`,
        type
      } = seriesData;
      if (seriesGroups[type] === void 0) {
        seriesGroups[type] = {
          series: {},
          seriesOrder: []
        };
      }
      if (((_a = seriesGroups[type]) == null ? void 0 : _a.series[id2]) !== void 0) {
        throw new Error(`MUI X: series' id "${id2}" is not unique.`);
      }
      seriesGroups[type].series[id2] = _extends({
        id: id2
      }, defaultizeColor(seriesData, seriesIndex, colors3));
      seriesGroups[type].seriesOrder.push(id2);
    });
    const formattedSeries = {};
    Object.keys(seriesFormatters).forEach((type) => {
      var _a;
      const group = seriesGroups[type];
      if (group !== void 0) {
        formattedSeries[type] = ((_a = seriesFormatters[type]) == null ? void 0 : _a.call(seriesFormatters, group, dataset)) ?? seriesGroups[type];
      }
    });
    return formattedSeries;
  };
  const blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
  const blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
  const blueberryTwilightPalette = (mode) => mode === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;
  const SeriesContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {}
  });
  const PluginContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {
      colorProcessors: {},
      seriesFormatters: {},
      xExtremumGetters: {},
      yExtremumGetters: {},
      rotationExtremumGetters: {},
      radiusExtremumGetters: {}
    }
  });
  const createResult = (data, direction) => {
    if (direction === "x") {
      return {
        x: data,
        y: null
      };
    }
    return {
      x: null,
      y: data
    };
  };
  const getBaseExtremum = (params) => {
    var _a;
    const {
      axis,
      getFilters,
      isDefaultAxis
    } = params;
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis
    });
    const data = filter ? (_a = axis.data) == null ? void 0 : _a.filter((_, i) => filter({
      x: null,
      y: null
    }, i)) : axis.data;
    const minX = Math.min(...data ?? []);
    const maxX = Math.max(...data ?? []);
    return [minX, maxX];
  };
  const getValueExtremum = (direction) => (params) => {
    const {
      series,
      axis,
      getFilters,
      isDefaultAxis
    } = params;
    return Object.keys(series).filter((seriesId) => {
      const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
      return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
    }).reduce((acc, seriesId) => {
      const {
        stackedData
      } = series[seriesId];
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
        seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
      });
      const [seriesMin, seriesMax] = (stackedData == null ? void 0 : stackedData.reduce((seriesAcc, values2, index) => {
        if (filter && (!filter(createResult(values2[0], direction), index) || !filter(createResult(values2[1], direction), index))) {
          return seriesAcc;
        }
        return [Math.min(...values2, seriesAcc[0]), Math.max(...values2, seriesAcc[1])];
      }, [Infinity, -Infinity])) ?? [Infinity, -Infinity];
      return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
    }, [Infinity, -Infinity]);
  };
  const getExtremumX$2 = (params) => {
    const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
    if (isHorizontal) {
      return getValueExtremum("x")(params);
    }
    return getBaseExtremum(params);
  };
  const getExtremumY$2 = (params) => {
    const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
    if (isHorizontal) {
      return getBaseExtremum(params);
    }
    return getValueExtremum("y")(params);
  };
  function constant$1(x2) {
    return function constant2() {
      return x2;
    };
  }
  const abs = Math.abs;
  const atan2 = Math.atan2;
  const cos = Math.cos;
  const max = Math.max;
  const min = Math.min;
  const sin = Math.sin;
  const sqrt$1 = Math.sqrt;
  const epsilon$1 = 1e-12;
  const pi$1 = Math.PI;
  const halfPi = pi$1 / 2;
  const tau$1 = 2 * pi$1;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
  }
  function asin(x2) {
    return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
  }
  const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
  function append(strings) {
    this._ += strings[0];
    for (let i = 1, n2 = strings.length; i < n2; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d2 = Math.floor(digits);
    if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d2 > 15) return append;
    const k2 = 10 ** d2;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n2 = strings.length; i < n2; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  class Path {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append : appendRound(digits);
    }
    moveTo(x2, y2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x2, y2) {
      this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
    }
    quadraticCurveTo(x1, y1, x2, y2) {
      this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
    }
    bezierCurveTo(x1, y1, x2, y2, x3, y3) {
      this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x1, y1, x2, y2, r2) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
      if (r2 < 0) throw new Error(`negative radius: ${r2}`);
      let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x1},${this._y1 = y1}`;
      } else if (!(l01_2 > epsilon)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
        this._append`L${this._x1 = x1},${this._y1 = y1}`;
      } else {
        let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
        if (Math.abs(t01 - 1) > epsilon) {
          this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
        }
        this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
      }
    }
    arc(x2, y2, r2, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
      if (r2 < 0) throw new Error(`negative radius: ${r2}`);
      let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x0},${y0}`;
      } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._append`L${x0},${y0}`;
      }
      if (!r2) return;
      if (da2 < 0) da2 = da2 % tau + tau;
      if (da2 > tauEpsilon) {
        this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
      } else if (da2 > epsilon) {
        this._append`A${r2},${r2},0,${+(da2 >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
      }
    }
    rect(x2, y2, w2, h2) {
      this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
    }
    toString() {
      return this._;
    }
  }
  function withPath(shape2) {
    let digits = 3;
    shape2.digits = function(_) {
      if (!arguments.length) return digits;
      if (_ == null) {
        digits = null;
      } else {
        const d2 = Math.floor(_);
        if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
        digits = d2;
      }
      return shape2;
    };
    return () => new Path(digits);
  }
  function arcInnerRadius(d2) {
    return d2.innerRadius;
  }
  function arcOuterRadius(d2) {
    return d2.outerRadius;
  }
  function arcStartAngle(d2) {
    return d2.startAngle;
  }
  function arcEndAngle(d2) {
    return d2.endAngle;
  }
  function arcPadAngle(d2) {
    return d2 && d2.padAngle;
  }
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t2 = y32 * x10 - x32 * y10;
    if (t2 * t2 < epsilon$1) return;
    t2 = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t2;
    return [x0 + t2 * x10, y0 + t2 * y10];
  }
  function cornerTangents(x0, y0, x1, y1, r1, rc2, cw) {
    var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc2 : -rc2) / sqrt$1(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc2, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt$1(max(0, r2 * r2 * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d2, cy0 = (-D2 * dx - dy * d3) / d2, cx1 = (D2 * dy + dx * d3) / d2, cy1 = (-D2 * dx + dy * d3) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r2 - 1),
      y11: cy0 * (r1 / r2 - 1)
    };
  }
  function d3Arc() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$1(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path = withPath(arc);
    function arc() {
      var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da2 = abs(a1 - a0), cw = a1 > a0;
      if (!context) context = buffer = path();
      if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
      if (!(r1 > epsilon$1)) context.moveTo(0, 0);
      else if (da2 > tau$1 - epsilon$1) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$1) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)), rc2 = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc2, rc1 = rc2, t02, t12;
        if (rp > epsilon$1) {
          var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon$1) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon$1) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
        if (rc2 > epsilon$1) {
          var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc2;
          if (da2 < pi$1) {
            if (oc2 = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
              var ax = x01 - oc2[0], ay = y01 - oc2[1], bx = x11 - oc2[0], by = y11 - oc2[1], kc2 = 1 / sin(acos((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2), lc2 = sqrt$1(oc2[0] * oc2[0] + oc2[1] * oc2[1]);
              rc0 = min(rc2, (r0 - lc2) / (kc2 - 1));
              rc1 = min(rc2, (r1 - lc2) / (kc2 + 1));
            } else {
              rc0 = rc1 = 0;
            }
          }
        }
        if (!(da1 > epsilon$1)) context.moveTo(x01, y01);
        else if (rc1 > epsilon$1) {
          t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc1 < rc2) context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
            context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
        if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);
        else if (rc0 > epsilon$1) {
          t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
          context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc0 < rc2) context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
            context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else context.arc(0, 0, r0, a10, a00, cw);
      }
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
      var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
      return [cos(a) * r2, sin(a) * r2];
    };
    arc.innerRadius = function(_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
    };
    arc.outerRadius = function(_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
    };
    arc.cornerRadius = function(_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
    };
    arc.padRadius = function(_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
    };
    arc.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
    };
    arc.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
    };
    arc.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
    };
    arc.context = function(_) {
      return arguments.length ? (context = _ == null ? null : _, arc) : context;
    };
    return arc;
  }
  function array(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }
  function descending$1(a, b2) {
    return b2 < a ? -1 : b2 > a ? 1 : b2 >= a ? 0 : NaN;
  }
  function identity$2(d2) {
    return d2;
  }
  function d3Pie() {
    var value = identity$2, sortValues = descending$1, sort = null, startAngle = constant$1(0), endAngle = constant$1(tau$1), padAngle = constant$1(0);
    function pie(data) {
      var i, n2 = (data = array(data)).length, j, k2, sum2 = 0, index = new Array(n2), arcs = new Array(n2), a0 = +startAngle.apply(this, arguments), da2 = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)), a1, p2 = Math.min(Math.abs(da2) / n2, padAngle.apply(this, arguments)), pa2 = p2 * (da2 < 0 ? -1 : 1), v2;
      for (i = 0; i < n2; ++i) {
        if ((v2 = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
          sum2 += v2;
        }
      }
      if (sortValues != null) index.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
      else if (sort != null) index.sort(function(i2, j2) {
        return sort(data[i2], data[j2]);
      });
      for (i = 0, k2 = sum2 ? (da2 - n2 * pa2) / sum2 : 0; i < n2; ++i, a0 = a1) {
        j = index[i], v2 = arcs[j], a1 = a0 + (v2 > 0 ? v2 * k2 : 0) + pa2, arcs[j] = {
          data: data[j],
          index: i,
          value: v2,
          startAngle: a0,
          endAngle: a1,
          padAngle: p2
        };
      }
      return arcs;
    }
    pie.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
    };
    pie.sortValues = function(_) {
      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };
    pie.sort = function(_) {
      return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };
    pie.startAngle = function(_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
    };
    pie.endAngle = function(_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
    };
    pie.padAngle = function(_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
    };
    return pie;
  }
  function d3StackOffsetNone(series, order2) {
    if (!((n2 = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order2[0]], n2, m2 = s1.length; i < n2; ++i) {
      s0 = s1, s1 = series[order2[i]];
      for (j = 0; j < m2; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }
  function d3StackOrderNone(series) {
    var n2 = series.length, o = new Array(n2);
    while (--n2 >= 0) o[n2] = n2;
    return o;
  }
  function stackValue(d2, key) {
    return d2[key];
  }
  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }
  function d3Stack() {
    var keys = constant$1([]), order2 = d3StackOrderNone, offset2 = d3StackOffsetNone, value = stackValue;
    function stack(data) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n2 = sz.length, j = -1, oz;
      for (const d2 of data) {
        for (i = 0, ++j; i < n2; ++i) {
          (sz[i][j] = [0, +value(d2, sz[i].key, j, data)]).data = d2;
        }
      }
      for (i = 0, oz = array(order2(sz)); i < n2; ++i) {
        sz[oz[i]].index = i;
      }
      offset2(sz, oz);
      return sz;
    }
    stack.keys = function(_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
    };
    stack.value = function(_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
    };
    stack.order = function(_) {
      return arguments.length ? (order2 = _ == null ? d3StackOrderNone : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order2;
    };
    stack.offset = function(_) {
      return arguments.length ? (offset2 = _ == null ? d3StackOffsetNone : _, stack) : offset2;
    };
    return stack;
  }
  function d3StackOffsetExpand(series, order2) {
    if (!((n2 = series.length) > 0)) return;
    for (var i, n2, j = 0, m2 = series[0].length, y2; j < m2; ++j) {
      for (y2 = i = 0; i < n2; ++i) y2 += series[i][j][1] || 0;
      if (y2) for (i = 0; i < n2; ++i) series[i][j][1] /= y2;
    }
    d3StackOffsetNone(series, order2);
  }
  function d3StackOffsetDiverging(series, order2) {
    if (!((n2 = series.length) > 0)) return;
    for (var i, j = 0, d2, dy, yp, yn, n2, m2 = series[order2[0]].length; j < m2; ++j) {
      for (yp = yn = 0, i = 0; i < n2; ++i) {
        if ((dy = (d2 = series[order2[i]][j])[1] - d2[0]) > 0) {
          d2[0] = yp, d2[1] = yp += dy;
        } else if (dy < 0) {
          d2[1] = yn, d2[0] = yn += dy;
        } else {
          d2[0] = 0, d2[1] = dy;
        }
      }
    }
  }
  function d3StackOffsetSilhouette(series, order2) {
    if (!((n2 = series.length) > 0)) return;
    for (var j = 0, s0 = series[order2[0]], n2, m2 = s0.length; j < m2; ++j) {
      for (var i = 0, y2 = 0; i < n2; ++i) y2 += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y2 / 2;
    }
    d3StackOffsetNone(series, order2);
  }
  function d3StackOffsetWiggle(series, order2) {
    if (!((n2 = series.length) > 0) || !((m2 = (s0 = series[order2[0]]).length) > 0)) return;
    for (var y2 = 0, j = 1, s0, m2, n2; j < m2; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n2; ++i) {
        var si2 = series[order2[i]], sij0 = si2[j][1] || 0, sij1 = si2[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
        for (var k2 = 0; k2 < i; ++k2) {
          var sk2 = series[order2[k2]], skj0 = sk2[j][1] || 0, skj1 = sk2[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y2;
      if (s1) y2 -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    d3StackOffsetNone(series, order2);
  }
  function d3StackOrderAppearance(series) {
    var peaks = series.map(peak);
    return d3StackOrderNone(series).sort(function(a, b2) {
      return peaks[a] - peaks[b2];
    });
  }
  function peak(series) {
    var i = -1, j = 0, n2 = series.length, vi2, vj2 = -Infinity;
    while (++i < n2) if ((vi2 = +series[i][1]) > vj2) vj2 = vi2, j = i;
    return j;
  }
  function d3StackOrderAscending(series) {
    var sums = series.map(sum);
    return d3StackOrderNone(series).sort(function(a, b2) {
      return sums[a] - sums[b2];
    });
  }
  function sum(series) {
    var s = 0, i = -1, n2 = series.length, v2;
    while (++i < n2) if (v2 = +series[i][1]) s += v2;
    return s;
  }
  function d3StackOrderDescending(series) {
    return d3StackOrderAscending(series).reverse();
  }
  function d3StackOrderInsideOut(series) {
    var n2 = series.length, i, j, sums = series.map(sum), order2 = d3StackOrderAppearance(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
    for (i = 0; i < n2; ++i) {
      j = order2[i];
      if (top2 < bottom2) {
        top2 += sums[j];
        tops.push(j);
      } else {
        bottom2 += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  }
  function d3StackOrderReverse(series) {
    return d3StackOrderNone(series).reverse();
  }
  const StackOrder = {
    /**
     * Series order such that the earliest series (according to the maximum value) is at the bottom.
     * */
    appearance: d3StackOrderAppearance,
    /**
     *  Series order such that the smallest series (according to the sum of values) is at the bottom.
     * */
    ascending: d3StackOrderAscending,
    /**
     * Series order such that the largest series (according to the sum of values) is at the bottom.
     */
    descending: d3StackOrderDescending,
    /**
     * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.
     */
    insideOut: d3StackOrderInsideOut,
    /**
     * Given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
     */
    none: d3StackOrderNone,
    /**
     * Reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
     */
    reverse: d3StackOrderReverse
  };
  const StackOffset = {
    /**
     * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
     * */
    expand: d3StackOffsetExpand,
    /**
     * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
     * */
    diverging: d3StackOffsetDiverging,
    /**
     * Applies a zero baseline.
     * */
    none: d3StackOffsetNone,
    /**
     * Shifts the baseline down such that the center of the streamgraph is always at zero.
     * */
    silhouette: d3StackOffsetSilhouette,
    /**
     * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
     * */
    wiggle: d3StackOffsetWiggle
  };
  const getStackingGroups = (params) => {
    const {
      series,
      seriesOrder,
      defaultStrategy
    } = params;
    const stackingGroups = [];
    const stackIndex = {};
    seriesOrder.forEach((id2) => {
      const {
        stack,
        stackOrder,
        stackOffset
      } = series[id2];
      if (stack === void 0) {
        stackingGroups.push({
          ids: [id2],
          stackingOrder: StackOrder.none,
          stackingOffset: StackOffset.none
        });
      } else if (stackIndex[stack] === void 0) {
        stackIndex[stack] = stackingGroups.length;
        stackingGroups.push({
          ids: [id2],
          stackingOrder: StackOrder[stackOrder ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOrder) ?? "none"],
          stackingOffset: StackOffset[stackOffset ?? (defaultStrategy == null ? void 0 : defaultStrategy.stackOffset) ?? "diverging"]
        });
      } else {
        stackingGroups[stackIndex[stack]].ids.push(id2);
        if (stackOrder !== void 0) {
          stackingGroups[stackIndex[stack]].stackingOrder = StackOrder[stackOrder];
        }
        if (stackOffset !== void 0) {
          stackingGroups[stackIndex[stack]].stackingOffset = StackOffset[stackOffset];
        }
      }
    });
    return stackingGroups;
  };
  function defaultizeValueFormatter(series, defaultValueFormatter) {
    const defaultizedSeries = {};
    Object.keys(series).forEach((seriesId) => {
      defaultizedSeries[seriesId] = _extends({}, series[seriesId], {
        valueFormatter: series[seriesId].valueFormatter ?? defaultValueFormatter
      });
    });
    return defaultizedSeries;
  }
  const formatter$3 = (params, dataset) => {
    const {
      seriesOrder,
      series
    } = params;
    const stackingGroups = getStackingGroups(params);
    const d3Dataset = dataset ?? [];
    seriesOrder.forEach((id2) => {
      const data = series[id2].data;
      if (data !== void 0) {
        data.forEach((value, index) => {
          if (d3Dataset.length <= index) {
            d3Dataset.push({
              [id2]: value
            });
          } else {
            d3Dataset[index][id2] = value;
          }
        });
      } else if (dataset === void 0) {
        throw new Error([`MUI X: bar series with id='${id2}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
      }
    });
    const completedSeries = {};
    stackingGroups.forEach((stackingGroup) => {
      const {
        ids,
        stackingOffset,
        stackingOrder
      } = stackingGroup;
      const stackedSeries = d3Stack().keys(ids.map((id2) => {
        const dataKey = series[id2].dataKey;
        return series[id2].data === void 0 && dataKey !== void 0 ? dataKey : id2;
      })).value((d2, key) => d2[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
      ids.forEach((id2, index) => {
        const dataKey = series[id2].dataKey;
        completedSeries[id2] = _extends({
          layout: "vertical"
        }, series[id2], {
          data: dataKey ? dataset.map((data) => {
            const value = data[dataKey];
            if (typeof value !== "number") {
              return 0;
            }
            return value;
          }) : series[id2].data,
          stackedData: stackedSeries[index].map(([a, b2]) => [a, b2])
        });
      });
    });
    return {
      seriesOrder,
      stackingGroups,
      series: defaultizeValueFormatter(completedSeries, (v2) => v2 == null ? "" : v2.toLocaleString())
    };
  };
  const getColor$3 = (series, xAxis, yAxis) => {
    const verticalLayout = series.layout === "vertical";
    const bandColorScale = verticalLayout ? xAxis == null ? void 0 : xAxis.colorScale : yAxis == null ? void 0 : yAxis.colorScale;
    const valueColorScale = verticalLayout ? yAxis == null ? void 0 : yAxis.colorScale : xAxis == null ? void 0 : xAxis.colorScale;
    const bandValues = verticalLayout ? xAxis == null ? void 0 : xAxis.data : yAxis == null ? void 0 : yAxis.data;
    if (valueColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color2 = value === null ? series.color : valueColorScale(value);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    if (bandColorScale && bandValues) {
      return (dataIndex) => {
        const value = bandValues[dataIndex];
        const color2 = value === null ? series.color : bandColorScale(value);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    return () => series.color;
  };
  const plugin$3 = {
    seriesType: "bar",
    seriesFormatter: formatter$3,
    colorProcessor: getColor$3,
    xExtremumGetter: getExtremumX$2,
    yExtremumGetter: getExtremumY$2
  };
  const mergeMinMax = (acc, val) => {
    return [Math.min(acc[0], val[0]), Math.max(acc[1], val[1])];
  };
  const getExtremumX$1 = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      const axisId = series[seriesId].xAxisId ?? series[seriesId].xAxisKey;
      return axisId === axis.id || axisId === void 0 && isDefaultAxis;
    }).reduce((acc, seriesId) => {
      var _a;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
        seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
      });
      const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d2, dataIndex) => {
        if (filter && !filter(d2, dataIndex)) {
          return accSeries;
        }
        return mergeMinMax(accSeries, [d2.x, d2.x]);
      }, [Infinity, -Infinity]);
      return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
    }, [Infinity, -Infinity]);
  };
  const getExtremumY$1 = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      const axisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
      return axisId === axis.id || axisId === void 0 && isDefaultAxis;
    }).reduce((acc, seriesId) => {
      var _a;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
        seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
      });
      const seriesMinMax = (_a = series[seriesId].data) == null ? void 0 : _a.reduce((accSeries, d2, dataIndex) => {
        if (filter && !filter(d2, dataIndex)) {
          return accSeries;
        }
        return mergeMinMax(accSeries, [d2.y, d2.y]);
      }, [Infinity, -Infinity]);
      return mergeMinMax(acc, seriesMinMax ?? [Infinity, -Infinity]);
    }, [Infinity, -Infinity]);
  };
  const formatter$2 = ({
    series,
    seriesOrder
  }, dataset) => {
    const completeSeries = Object.fromEntries(Object.entries(series).map(([seriesId, seriesData]) => {
      const datasetKeys = seriesData == null ? void 0 : seriesData.datasetKeys;
      const missingKeys = ["x", "y", "id"].filter((key) => typeof (datasetKeys == null ? void 0 : datasetKeys[key]) !== "string");
      if ((seriesData == null ? void 0 : seriesData.datasetKeys) && missingKeys.length > 0) {
        throw new Error([`MUI X: scatter series with id='${seriesId}' has incomplete datasetKeys.`, `Properties ${missingKeys.map((key) => `"${key}"`).join(", ")} are missing.`].join("\n"));
      }
      const data = !datasetKeys ? seriesData.data ?? [] : (dataset == null ? void 0 : dataset.map((d2) => {
        return {
          x: d2[datasetKeys.x],
          y: d2[datasetKeys.y],
          z: datasetKeys.z && d2[datasetKeys.z],
          id: d2[datasetKeys.id]
        };
      })) ?? [];
      return [seriesId, _extends({}, seriesData, {
        data,
        valueFormatter: seriesData.valueFormatter ?? ((v2) => `(${v2.x}, ${v2.y})`)
      })];
    }));
    return {
      series: completeSeries,
      seriesOrder
    };
  };
  const getColor$2 = (series, xAxis, yAxis, zAxis) => {
    const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
    const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
    const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
    if (zColorScale) {
      return (dataIndex) => {
        var _a, _b;
        if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
          const color3 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
          if (color3 !== null) {
            return color3;
          }
        }
        const value = series.data[dataIndex];
        const color2 = value === null ? series.color : zColorScale(value.z);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    if (yColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color2 = value === null ? series.color : yColorScale(value.y);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    if (xColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color2 = value === null ? series.color : xColorScale(value.x);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    return () => series.color;
  };
  const plugin$2 = {
    seriesType: "scatter",
    seriesFormatter: formatter$2,
    colorProcessor: getColor$2,
    xExtremumGetter: getExtremumX$1,
    yExtremumGetter: getExtremumY$1
  };
  const getExtremumX = (params) => {
    const {
      axis
    } = params;
    const minX = Math.min(...axis.data ?? []);
    const maxX = Math.max(...axis.data ?? []);
    return [minX, maxX];
  };
  function getSeriesExtremums(getValues, stackedData, filter) {
    return stackedData.reduce((seriesAcc, stackedValue, index) => {
      const [base, value] = getValues(stackedValue);
      if (filter && (!filter({
        y: base,
        x: null
      }, index) || !filter({
        y: value,
        x: null
      }, index))) {
        return seriesAcc;
      }
      return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
    }, [Infinity, -Infinity]);
  }
  const getExtremumY = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;
      return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
    }).reduce((acc, seriesId) => {
      const {
        area,
        stackedData
      } = series[seriesId];
      const isArea = area !== void 0;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,
        seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey
      });
      const getValues = isArea && axis.scaleType !== "log" && typeof series[seriesId].baseline !== "string" ? (d2) => d2 : (d2) => [d2[1], d2[1]];
      const seriesExtremums = getSeriesExtremums(getValues, stackedData, filter);
      const [seriesMin, seriesMax] = seriesExtremums;
      return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
    }, [Infinity, -Infinity]);
  };
  const formatter$1 = (params, dataset) => {
    const {
      seriesOrder,
      series
    } = params;
    const stackingGroups = getStackingGroups(_extends({}, params, {
      defaultStrategy: {
        stackOffset: "none"
      }
    }));
    const d3Dataset = dataset ?? [];
    seriesOrder.forEach((id2) => {
      const data = series[id2].data;
      if (data !== void 0) {
        data.forEach((value, index) => {
          if (d3Dataset.length <= index) {
            d3Dataset.push({
              [id2]: value
            });
          } else {
            d3Dataset[index][id2] = value;
          }
        });
      } else if (dataset === void 0 && false) {
        throw new Error([`MUI X: line series with id='${id2}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
      }
    });
    const completedSeries = {};
    stackingGroups.forEach((stackingGroup) => {
      const {
        ids,
        stackingOrder,
        stackingOffset
      } = stackingGroup;
      const stackedSeries = d3Stack().keys(ids.map((id2) => {
        const dataKey = series[id2].dataKey;
        return series[id2].data === void 0 && dataKey !== void 0 ? dataKey : id2;
      })).value((d2, key) => d2[key] ?? 0).order(stackingOrder).offset(stackingOffset)(d3Dataset);
      ids.forEach((id2, index) => {
        const dataKey = series[id2].dataKey;
        completedSeries[id2] = _extends({}, series[id2], {
          data: dataKey ? dataset.map((data) => {
            const value = data[dataKey];
            if (typeof value !== "number") {
              return null;
            }
            return value;
          }) : series[id2].data,
          stackedData: stackedSeries[index].map(([a, b2]) => [a, b2])
        });
      });
    });
    return {
      seriesOrder,
      stackingGroups,
      series: defaultizeValueFormatter(completedSeries, (v2) => v2 == null ? "" : v2.toLocaleString())
    };
  };
  const getColor$1 = (series, xAxis, yAxis) => {
    const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
    const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
    if (yColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color2 = value === null ? series.color : yColorScale(value);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    if (xColorScale) {
      return (dataIndex) => {
        var _a;
        const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
        const color2 = value === null ? series.color : xColorScale(value);
        if (color2 === null) {
          return series.color;
        }
        return color2;
      };
    }
    return () => series.color;
  };
  const plugin$1 = {
    seriesType: "line",
    colorProcessor: getColor$1,
    seriesFormatter: formatter$1,
    xExtremumGetter: getExtremumX,
    yExtremumGetter: getExtremumY
  };
  function getLabel(value, location) {
    return typeof value === "function" ? value(location) : value;
  }
  const getSortingComparator = (comparator = "none") => {
    if (typeof comparator === "function") {
      return comparator;
    }
    switch (comparator) {
      case "none":
        return null;
      case "desc":
        return (a, b2) => b2 - a;
      case "asc":
        return (a, b2) => a - b2;
      default:
        return null;
    }
  };
  const formatter = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    const defaultizedSeries = {};
    seriesOrder.forEach((seriesId) => {
      const arcs = d3Pie().startAngle(2 * Math.PI * (series[seriesId].startAngle ?? 0) / 360).endAngle(2 * Math.PI * (series[seriesId].endAngle ?? 360) / 360).padAngle(2 * Math.PI * (series[seriesId].paddingAngle ?? 0) / 360).sortValues(getSortingComparator(series[seriesId].sortingValues ?? "none"))(series[seriesId].data.map((piePoint) => piePoint.value));
      defaultizedSeries[seriesId] = _extends({
        valueFormatter: (item) => item.value.toLocaleString()
      }, series[seriesId], {
        data: series[seriesId].data.map((item, index) => _extends({}, item, {
          id: item.id ?? `auto-generated-pie-id-${seriesId}-${index}`
        }, arcs[index])).map((item, index) => {
          var _a, _b;
          return _extends({}, item, {
            formattedValue: ((_b = (_a = series[seriesId]).valueFormatter) == null ? void 0 : _b.call(_a, _extends({}, item, {
              label: getLabel(item.label, "arc")
            }), {
              dataIndex: index
            })) ?? item.value.toLocaleString()
          });
        })
      });
    });
    return {
      seriesOrder,
      series: defaultizedSeries
    };
  };
  const getColor = (series) => {
    return (dataIndex) => {
      return series.data[dataIndex].color;
    };
  };
  const plugin = {
    seriesType: "pie",
    colorProcessor: getColor,
    seriesFormatter: formatter
  };
  const defaultPlugins = [plugin$3, plugin$2, plugin$1, plugin];
  function mergePlugins(plugins2) {
    const defaultizedPlugins = plugins2 ?? defaultPlugins;
    const seriesFormatters = {};
    const colorProcessors = {};
    const xExtremumGetters = {};
    const yExtremumGetters = {};
    const rotationExtremumGetters = {};
    const radiusExtremumGetters = {};
    for (let i = 0; i < defaultizedPlugins.length; i += 1) {
      const plugin2 = defaultizedPlugins[i];
      const seriesType = plugin2.seriesType;
      seriesFormatters[seriesType] = plugin2.seriesFormatter;
      colorProcessors[seriesType] = plugin2.colorProcessor;
      if (plugin2.xExtremumGetter) {
        xExtremumGetters[seriesType] = plugin2.xExtremumGetter;
      }
      if (plugin2.yExtremumGetter) {
        yExtremumGetters[seriesType] = plugin2.yExtremumGetter;
      }
      if (plugin2.rotationExtremumGetter) {
        rotationExtremumGetters[seriesType] = plugin2.rotationExtremumGetter;
      }
      if (plugin2.radiusExtremumGetter) {
        radiusExtremumGetters[seriesType] = plugin2.radiusExtremumGetter;
      }
    }
    return {
      seriesFormatters,
      colorProcessors,
      xExtremumGetters,
      yExtremumGetters,
      rotationExtremumGetters,
      radiusExtremumGetters
    };
  }
  function PluginProvider(props) {
    const {
      children,
      plugins: plugins2
    } = props;
    const formattedSeries = reactExports.useMemo(() => ({
      isInitialized: true,
      data: mergePlugins(plugins2)
    }), [plugins2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PluginContext.Provider, {
      value: formattedSeries,
      children
    });
  }
  function useColorProcessor(seriesType) {
    const {
      isInitialized,
      data
    } = reactExports.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    {
      return data.colorProcessors;
    }
  }
  function useSeriesFormatter(seriesType) {
    const {
      isInitialized,
      data
    } = reactExports.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    {
      return data.seriesFormatters;
    }
  }
  function useXExtremumGetter(seriesType) {
    const {
      isInitialized,
      data
    } = reactExports.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    {
      return data.xExtremumGetters;
    }
  }
  function useYExtremumGetter(seriesType) {
    const {
      isInitialized,
      data
    } = reactExports.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    {
      return data.yExtremumGetters;
    }
  }
  function SeriesProvider(props) {
    const {
      series,
      dataset,
      colors: colors3 = blueberryTwilightPalette,
      children
    } = props;
    const seriesFormatters = useSeriesFormatter();
    const theme = useTheme();
    const formattedSeries = reactExports.useMemo(() => ({
      isInitialized: true,
      data: preprocessSeries({
        series,
        colors: typeof colors3 === "function" ? colors3(theme.palette.mode) : colors3,
        seriesFormatters,
        dataset
      })
    }), [series, colors3, theme.palette.mode, seriesFormatters, dataset]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SeriesContext.Provider, {
      value: formattedSeries,
      children
    });
  }
  function useSeries() {
    const {
      isInitialized,
      data
    } = reactExports.useContext(SeriesContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the series ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }
  function usePieSeries() {
    const series = useSeries();
    return reactExports.useMemo(() => series.pie, [series.pie]);
  }
  function useBarSeries() {
    const series = useSeries();
    return reactExports.useMemo(() => series.bar, [series.bar]);
  }
  const _excluded$p = ["highlighted", "faded"];
  const mergeDeprecatedOptions = (options) => {
    const _ref = options ?? {}, {
      highlighted,
      faded
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$p);
    return _extends({
      highlight: highlighted,
      fade: faded
    }, other);
  };
  function HighlightedProvider({
    children,
    highlightedItem: highlightedItemProps,
    onHighlightChange
  }) {
    const [highlightedItem, setHighlightedItem] = useControlled({
      controlled: highlightedItemProps,
      default: null,
      name: "HighlightedProvider",
      state: "highlightedItem"
    });
    const series = useSeries();
    const seriesById = reactExports.useMemo(() => {
      const map2 = /* @__PURE__ */ new Map();
      Object.keys(series).forEach((seriesType) => {
        const seriesData = series[seriesType];
        Object.keys((seriesData == null ? void 0 : seriesData.series) ?? {}).forEach((seriesId) => {
          const seriesItem = seriesData == null ? void 0 : seriesData.series[seriesId];
          map2.set(seriesId, mergeDeprecatedOptions(seriesItem == null ? void 0 : seriesItem.highlightScope));
        });
      });
      return map2;
    }, [series]);
    const highlightScope = highlightedItem && highlightedItem.seriesId ? seriesById.get(highlightedItem.seriesId) ?? void 0 : void 0;
    const providerValue = reactExports.useMemo(() => {
      return {
        isInitialized: true,
        data: {
          highlightScope,
          highlightedItem,
          setHighlighted: (itemData) => {
            setHighlightedItem(itemData);
            onHighlightChange == null ? void 0 : onHighlightChange(itemData);
          },
          clearHighlighted: () => {
            setHighlightedItem(null);
            onHighlightChange == null ? void 0 : onHighlightChange(null);
          },
          isHighlighted: createIsHighlighted(highlightScope, highlightedItem),
          isFaded: createIsFaded(highlightScope, highlightedItem)
        }
      };
    }, [highlightedItem, highlightScope, setHighlightedItem, onHighlightChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HighlightedContext.Provider, {
      value: providerValue,
      children
    });
  }
  function useHighlighted() {
    const {
      isInitialized,
      data
    } = reactExports.useContext(HighlightedContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the highlighted ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }
  function useItemHighlighted(item) {
    const highlighted = useHighlighted();
    if (!item) {
      return {
        isHighlighted: false,
        isFaded: false
      };
    }
    const isHighlighted = highlighted.isHighlighted(item);
    const isFaded = !isHighlighted && highlighted.isFaded(item);
    return {
      isHighlighted,
      isFaded
    };
  }
  function ascending(a, b2) {
    return a == null || b2 == null ? NaN : a < b2 ? -1 : a > b2 ? 1 : a >= b2 ? 0 : NaN;
  }
  function descending(a, b2) {
    return a == null || b2 == null ? NaN : b2 < a ? -1 : b2 > a ? 1 : b2 >= a ? 0 : NaN;
  }
  function bisector(f2) {
    let compare1, compare2, delta;
    if (f2.length !== 2) {
      compare1 = ascending;
      compare2 = (d2, x2) => ascending(f2(d2), x2);
      delta = (d2, x2) => f2(d2) - x2;
    } else {
      compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
      compare2 = f2;
      delta = f2;
    }
    function left2(a, x2, lo = 0, hi2 = a.length) {
      if (lo < hi2) {
        if (compare1(x2, x2) !== 0) return hi2;
        do {
          const mid = lo + hi2 >>> 1;
          if (compare2(a[mid], x2) < 0) lo = mid + 1;
          else hi2 = mid;
        } while (lo < hi2);
      }
      return lo;
    }
    function right2(a, x2, lo = 0, hi2 = a.length) {
      if (lo < hi2) {
        if (compare1(x2, x2) !== 0) return hi2;
        do {
          const mid = lo + hi2 >>> 1;
          if (compare2(a[mid], x2) <= 0) lo = mid + 1;
          else hi2 = mid;
        } while (lo < hi2);
      }
      return lo;
    }
    function center(a, x2, lo = 0, hi2 = a.length) {
      const i = left2(a, x2, lo, hi2 - 1);
      return i > lo && delta(a[i - 1], x2) > -delta(a[i], x2) ? i - 1 : i;
    }
    return { left: left2, center, right: right2 };
  }
  function zero$1() {
    return 0;
  }
  function number$2(x2) {
    return x2 === null ? NaN : +x2;
  }
  const ascendingBisect = bisector(ascending);
  const bisectRight = ascendingBisect.right;
  bisector(number$2).center;
  class InternMap extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
  function tickSpec(start2, stop2, count) {
    const step = (stop2 - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc);
      i2 = Math.round(stop2 * inc);
      if (i1 / inc < start2) ++i1;
      if (i2 / inc > stop2) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc);
      i2 = Math.round(stop2 / inc);
      if (i1 * inc < start2) ++i1;
      if (i2 * inc > stop2) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start2, stop2, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start2, stop2, count) {
    stop2 = +stop2, start2 = +start2, count = +count;
    if (!(count > 0)) return [];
    if (start2 === stop2) return [start2];
    const reverse = stop2 < start2, [i1, i2, inc] = reverse ? tickSpec(stop2, start2, count) : tickSpec(start2, stop2, count);
    if (!(i2 >= i1)) return [];
    const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop2, count) {
    stop2 = +stop2, start2 = +start2, count = +count;
    return tickSpec(start2, stop2, count)[2];
  }
  function tickStep(start2, stop2, count) {
    stop2 = +stop2, start2 = +start2, count = +count;
    const reverse = stop2 < start2, inc = reverse ? tickIncrement(stop2, start2, count) : tickIncrement(start2, stop2, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }
  function range(start2, stop2, step) {
    start2 = +start2, stop2 = +stop2, step = (n2 = arguments.length) < 2 ? (stop2 = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step;
    var i = -1, n2 = Math.max(0, Math.ceil((stop2 - start2) / step)) | 0, range2 = new Array(n2);
    while (++i < n2) {
      range2[i] = start2 + i * step;
    }
    return range2;
  }
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }
  const implicit = Symbol("implicit");
  function ordinal() {
    var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale(d2) {
      let i = index.get(d2);
      if (i === void 0) {
        if (unknown !== implicit) return unknown;
        index.set(d2, i = domain.push(d2) - 1);
      }
      return range2[i % range2.length];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = new InternMap();
      for (const value of _) {
        if (index.has(value)) continue;
        index.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n2 = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop2 = reverse ? r0 : r1;
      step = (stop2 - start2) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
      if (round2) step = Math.floor(step);
      start2 += (stop2 - start2 - step * (n2 - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round2) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values2 = range(n2).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse ? values2.reverse() : values2);
    }
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_) {
      return arguments.length ? (round2 = !!_, rescale()) : round2;
    };
    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale) {
    var copy2 = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
      return pointish(copy2());
    };
    return scale;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }
  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m2, l2;
    format2 = (format2 + "").trim().toLowerCase();
    return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba$1(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba$1(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba$1(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba$1(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba$1(r2, g2, b2, a) {
    if (a <= 0) r2 = g2 = b2 = NaN;
    return new Rgb(r2, g2, b2, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb$2(r2, g2, b2, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g2, b2, opacity) {
    this.r = +r2;
    this.g = +g2;
    this.b = +b2;
    this.opacity = +opacity;
  }
  define(Rgb, rgb$2, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla$1(h2, s, l2, a) {
    if (a <= 0) h2 = s = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h2 = s = NaN;
    else if (s <= 0) h2 = NaN;
    return new Hsl(h2, s, l2, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r2 = o.r / 255, g2 = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s = max2 - min2, l2 = (max2 + min2) / 2;
    if (s) {
      if (r2 === max2) h2 = (g2 - b2) / s + (g2 < b2) * 6;
      else if (g2 === max2) h2 = (b2 - r2) / s + 2;
      else h2 = (r2 - g2) / s + 4;
      s /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h2 *= 60;
    } else {
      s = l2 > 0 && l2 < 1 ? 0 : h2;
    }
    return new Hsl(h2, s, l2, o.opacity);
  }
  function hsl$1(h2, s, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s, l2, opacity) {
    this.h = +h2;
    this.s = +s;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define(Hsl, hsl$1, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s, m1 = 2 * l2 - m2;
      return new Rgb(
        hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
        hsl2rgb(h2, m1, m2),
        hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }
  const constant = (x2) => () => x2;
  function linear$1(a, d2) {
    return function(t2) {
      return a + t2 * d2;
    };
  }
  function exponential(a, b2, y2) {
    return a = Math.pow(a, y2), b2 = Math.pow(b2, y2) - a, y2 = 1 / y2, function(t2) {
      return Math.pow(a + t2 * b2, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a, b2) {
      return b2 - a ? exponential(a, b2, y2) : constant(isNaN(a) ? b2 : a);
    };
  }
  function nogamma(a, b2) {
    var d2 = b2 - a;
    return d2 ? linear$1(a, d2) : constant(isNaN(a) ? b2 : a);
  }
  const rgb$1 = function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end2) {
      var r2 = color2((start2 = rgb$2(start2)).r, (end2 = rgb$2(end2)).r), g2 = color2(start2.g, end2.g), b2 = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t2) {
        start2.r = r2(t2);
        start2.g = g2(t2);
        start2.b = b2(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function numberArray(a, b2) {
    if (!b2) b2 = [];
    var n2 = a ? Math.min(b2.length, a.length) : 0, c6 = b2.slice(), i;
    return function(t2) {
      for (i = 0; i < n2; ++i) c6[i] = a[i] * (1 - t2) + b2[i] * t2;
      return c6;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }
  function genericArray(a, b2) {
    var nb2 = b2 ? b2.length : 0, na = a ? Math.min(nb2, a.length) : 0, x2 = new Array(na), c6 = new Array(nb2), i;
    for (i = 0; i < na; ++i) x2[i] = interpolate$1(a[i], b2[i]);
    for (; i < nb2; ++i) c6[i] = b2[i];
    return function(t2) {
      for (i = 0; i < na; ++i) c6[i] = x2[i](t2);
      return c6;
    };
  }
  function interpolateDate(a, b2) {
    var d2 = /* @__PURE__ */ new Date();
    return a = +a, b2 = +b2, function(t2) {
      return d2.setTime(a * (1 - t2) + b2 * t2), d2;
    };
  }
  function interpolateNumber(a, b2) {
    return a = +a, b2 = +b2, function(t2) {
      return a * (1 - t2) + b2 * t2;
    };
  }
  function object(a, b2) {
    var i = {}, c6 = {}, k2;
    if (a === null || typeof a !== "object") a = {};
    if (b2 === null || typeof b2 !== "object") b2 = {};
    for (k2 in b2) {
      if (k2 in a) {
        i[k2] = interpolate$1(a[k2], b2[k2]);
      } else {
        c6[k2] = b2[k2];
      }
    }
    return function(t2) {
      for (k2 in i) c6[k2] = i[k2](t2);
      return c6;
    };
  }
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
  function zero(b2) {
    return function() {
      return b2;
    };
  }
  function one(b2) {
    return function(t2) {
      return b2(t2) + "";
    };
  }
  function interpolateString(a, b2) {
    var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q2 = [];
    a = a + "", b2 = b2 + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b2))) {
      if ((bs = bm.index) > bi2) {
        bs = b2.slice(bi2, bs);
        if (s[i]) s[i] += bs;
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm;
        else s[++i] = bm;
      } else {
        s[++i] = null;
        q2.push({ i, x: interpolateNumber(am, bm) });
      }
      bi2 = reB.lastIndex;
    }
    if (bi2 < b2.length) {
      bs = b2.slice(bi2);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    return s.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
      for (var i2 = 0, o; i2 < b2; ++i2) s[(o = q2[i2]).i] = o.x(t2);
      return s.join("");
    });
  }
  function interpolate$1(a, b2) {
    var t2 = typeof b2, c6;
    return b2 == null || t2 === "boolean" ? constant(b2) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c6 = color(b2)) ? (b2 = c6, rgb$1) : interpolateString : b2 instanceof color ? rgb$1 : b2 instanceof Date ? interpolateDate : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber)(a, b2);
  }
  function interpolateRound(a, b2) {
    return a = +a, b2 = +b2, function(t2) {
      return Math.round(a * (1 - t2) + b2 * t2);
    };
  }
  function constants(x2) {
    return function() {
      return x2;
    };
  }
  function number$1(x2) {
    return +x2;
  }
  var unit = [0, 1];
  function identity$1(x2) {
    return x2;
  }
  function normalize(a, b2) {
    return (b2 -= a = +a) ? function(x2) {
      return (x2 - a) / b2;
    } : constants(isNaN(b2) ? NaN : 0.5);
  }
  function clamper(a, b2) {
    var t2;
    if (a > b2) t2 = a, a = b2, b2 = t2;
    return function(x2) {
      return Math.max(a, Math.min(b2, x2));
    };
  }
  function bimap(domain, range2, interpolate2) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range2, interpolate2) {
    var j = Math.min(domain.length, range2.length) - 1, d2 = new Array(j), r2 = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d2[i] = normalize(domain[i], domain[i + 1]);
      r2[i] = interpolate2(range2[i], range2[i + 1]);
    }
    return function(x2) {
      var i2 = bisectRight(domain, x2, 1, j) - 1;
      return r2[i2](d2[i2](x2));
    };
  }
  function copy$1(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer$1() {
    var domain = unit, range2 = unit, interpolate2 = interpolate$1, transform, untransform, unknown, clamp2 = identity$1, piecewise, output, input;
    function rescale() {
      var n2 = Math.min(domain.length, range2.length);
      if (clamp2 !== identity$1) clamp2 = clamper(domain[0], domain[n2 - 1]);
      piecewise = n2 > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate2)))(transform(clamp2(x2)));
    }
    scale.invert = function(y2) {
      return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform), interpolateNumber)))(y2)));
    };
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale.rangeRound = function(_) {
      return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = _ ? true : identity$1, rescale()) : clamp2 !== identity$1;
    };
    scale.interpolate = function(_) {
      return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t2, u2) {
      transform = t2, untransform = u2;
      return rescale();
    };
  }
  function continuous() {
    return transformer$1()(identity$1, identity$1);
  }
  function formatDecimal(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p2) {
    if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x2.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i + 1)
    ];
  }
  function exponent(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }
  function formatGroup(grouping, thousands) {
    return function(value, width2) {
      var i = value.length, t2 = [], j = 0, g2 = grouping[0], length2 = 0;
      while (i > 0 && g2 > 0) {
        if (length2 + g2 + 1 > width2) g2 = Math.max(1, width2 - length2);
        t2.push(value.substring(i -= g2, i + g2));
        if ((length2 += g2 + 1) > width2) break;
        g2 = grouping[j = (j + 1) % grouping.length];
      }
      return t2.reverse().join(thousands);
    };
  }
  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match2;
    return new FormatSpecifier({
      fill: match2[1],
      align: match2[2],
      sign: match2[3],
      symbol: match2[4],
      zero: match2[5],
      width: match2[6],
      comma: match2[7],
      precision: match2[8] && match2[8].slice(1),
      trim: match2[9],
      type: match2[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function formatTrim(s) {
    out: for (var n2 = s.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }
  var prefixExponent;
  function formatPrefixAuto(x2, p2) {
    var d2 = formatDecimalParts(x2, p2);
    if (!d2) return x2 + "";
    var coefficient = d2[0], exponent2 = d2[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
    return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
  }
  function formatRounded(x2, p2) {
    var d2 = formatDecimalParts(x2, p2);
    if (!d2) return x2 + "";
    var coefficient = d2[0], exponent2 = d2[1];
    return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
  }
  const formatTypes = {
    "%": (x2, p2) => (x2 * 100).toFixed(p2),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal,
    "e": (x2, p2) => x2.toExponential(p2),
    "f": (x2, p2) => x2.toFixed(p2),
    "g": (x2, p2) => x2.toPrecision(p2),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p2) => formatRounded(x2 * 100, p2),
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };
  function identity(x2) {
    return x2;
  }
  var map = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function formatLocale$1(locale2) {
    var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
      if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
      var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix2, valueSuffix = suffix, i, n2, c6;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim2) value = formatTrim(value);
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes$1[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n2 = value.length;
            while (++i < n2) {
              if (c6 = value.charCodeAt(i), 48 > c6 || c6 > 57) {
                valueSuffix = (c6 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero2) value = group(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
        if (comma && zero2) value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding2;
            break;
          case "=":
            value = valuePrefix + padding2 + value + valueSuffix;
            break;
          case "^":
            value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
            break;
          default:
            value = padding2 + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix2 = prefixes$1[8 + e3 / 3];
      return function(value2) {
        return f2(k2 * value2) + prefix2;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }
  var locale$1;
  var format;
  var formatPrefix;
  defaultLocale$1({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    format = locale$1.format;
    formatPrefix = locale$1.formatPrefix;
    return locale$1;
  }
  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }
  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }
  function precisionRound(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent(max2) - exponent(step)) + 1;
  }
  function tickFormat(start2, stop2, count, specifier) {
    var step = tickStep(start2, stop2, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop2));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop2))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d2 = domain();
      return ticks(d2[0], d2[d2.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d2 = domain();
      return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null) count = 10;
      var d2 = domain();
      var i0 = 0;
      var i1 = d2.length - 1;
      var start2 = d2[i0];
      var stop2 = d2[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop2 < start2) {
        step = start2, start2 = stop2, stop2 = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop2, count);
        if (step === prestep) {
          d2[i0] = start2;
          d2[i1] = stop2;
          return domain(d2);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop2 = Math.ceil(stop2 / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop2 = Math.floor(stop2 * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear() {
    var scale = continuous();
    scale.copy = function() {
      return copy$1(scale, linear());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }
  function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
    if (x1 < x0) {
      t2 = i0, i0 = i1, i1 = t2;
      t2 = x0, x0 = x1, x1 = t2;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }
  function transformLog(x2) {
    return Math.log(x2);
  }
  function transformExp(x2) {
    return Math.exp(x2);
  }
  function transformLogn(x2) {
    return -Math.log(-x2);
  }
  function transformExpn(x2) {
    return -Math.exp(-x2);
  }
  function pow10(x2) {
    return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
  }
  function reflect(f2) {
    return (x2, k2) => -f2(-x2, k2);
  }
  function loggish(transform) {
    const scale = transform(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = (count) => {
      const d2 = domain();
      let u2 = d2[0];
      let v2 = d2[d2.length - 1];
      const r2 = v2 < u2;
      if (r2) [u2, v2] = [v2, u2];
      let i = logs(u2);
      let j = logs(v2);
      let k2;
      let t2;
      const n2 = count == null ? 10 : +count;
      let z2 = [];
      if (!(base % 1) && j - i < n2) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u2 > 0) for (; i <= j; ++i) {
          for (k2 = 1; k2 < base; ++k2) {
            t2 = i < 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u2) continue;
            if (t2 > v2) break;
            z2.push(t2);
          }
        }
        else for (; i <= j; ++i) {
          for (k2 = base - 1; k2 >= 1; --k2) {
            t2 = i > 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u2) continue;
            if (t2 > v2) break;
            z2.push(t2);
          }
        }
        if (z2.length * 2 < n2) z2 = ticks(u2, v2, n2);
      } else {
        z2 = ticks(i, j, Math.min(j - i, n2)).map(pows);
      }
      return r2 ? z2.reverse() : z2;
    };
    scale.tickFormat = (count, specifier) => {
      if (count == null) count = 10;
      if (specifier == null) specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
        specifier = format(specifier);
      }
      if (count === Infinity) return specifier;
      const k2 = Math.max(1, base * count / scale.ticks().length);
      return (d2) => {
        let i = d2 / pows(Math.round(logs(d2)));
        if (i * base < base - 0.5) i *= base;
        return i <= k2 ? specifier(d2) : "";
      };
    };
    scale.nice = () => {
      return domain(nice(domain(), {
        floor: (x2) => pows(Math.floor(logs(x2))),
        ceil: (x2) => pows(Math.ceil(logs(x2)))
      }));
    };
    return scale;
  }
  function log$1() {
    const scale = loggish(transformer$1()).domain([1, 10]);
    scale.copy = () => copy$1(scale, log$1()).base(scale.base());
    initRange.apply(scale, arguments);
    return scale;
  }
  function transformPow(exponent2) {
    return function(x2) {
      return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
    };
  }
  function transformSqrt(x2) {
    return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
  }
  function transformSquare(x2) {
    return x2 < 0 ? -x2 * x2 : x2 * x2;
  }
  function powish(transform) {
    var scale = transform(identity$1, identity$1), exponent2 = 1;
    function rescale() {
      return exponent2 === 1 ? transform(identity$1, identity$1) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
    }
    scale.exponent = function(_) {
      return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
    };
    return linearish(scale);
  }
  function pow() {
    var scale = powish(transformer$1());
    scale.copy = function() {
      return copy$1(scale, pow()).exponent(scale.exponent());
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
  }
  function threshold() {
    var domain = [0.5], range2 = [0, 1], unknown, n2 = 1;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range2[bisectRight(domain, x2, 0, n2)] : unknown;
    }
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_), n2 = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), n2 = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
    };
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return threshold().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }
  const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count, field) {
    function interval(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval.round = (date2) => {
      const d0 = interval(date2), d1 = interval.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval.offset = (date2, step) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval.range = (start2, stop2, step) => {
      const range2 = [];
      start2 = interval.ceil(start2);
      step = step == null ? 1 : Math.floor(step);
      if (!(start2 < stop2) || !(step > 0)) return range2;
      let previous;
      do
        range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
      while (previous < start2 && start2 < stop2);
      return range2;
    };
    interval.filter = (test) => {
      return timeInterval((date2) => {
        if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
      }, (date2, step) => {
        if (date2 >= date2) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
          else while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
        }
      });
    };
    if (count) {
      interval.count = (start2, end2) => {
        t0.setTime(+start2), t1.setTime(+end2);
        floori(t0), floori(t1);
        return Math.floor(count(t0, t1));
      };
      interval.every = (step) => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d2) => field(d2) % step === 0 : (d2) => interval.count(0, d2) % step === 0);
      };
    }
    return interval;
  }
  const millisecond = timeInterval(() => {
  }, (date2, step) => {
    date2.setTime(+date2 + step);
  }, (start2, end2) => {
    return end2 - start2;
  });
  millisecond.every = (k2) => {
    k2 = Math.floor(k2);
    if (!isFinite(k2) || !(k2 > 0)) return null;
    if (!(k2 > 1)) return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k2) * k2);
    }, (date2, step) => {
      date2.setTime(+date2 + step * k2);
    }, (start2, end2) => {
      return (end2 - start2) / k2;
    });
  };
  millisecond.range;
  const durationSecond = 1e3;
  const durationMinute = durationSecond * 60;
  const durationHour = durationMinute * 60;
  const durationDay = durationHour * 24;
  const durationWeek = durationDay * 7;
  const durationMonth = durationDay * 30;
  const durationYear = durationDay * 365;
  const second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationSecond);
  }, (start2, end2) => {
    return (end2 - start2) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  second.range;
  const timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end2) => {
    return (end2 - start2) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  timeMinute.range;
  const utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start2, end2) => {
    return (end2 - start2) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  utcMinute.range;
  const timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end2) => {
    return (end2 - start2) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  timeHour.range;
  const utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start2, end2) => {
    return (end2 - start2) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  utcHour.range;
  const timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  timeDay.range;
  const utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end2) => {
    return (end2 - start2) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  utcDay.range;
  const unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start2, end2) => {
    return (end2 - start2) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  unixDay.range;
  function timeWeekday(i) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setDate(date2.getDate() + step * 7);
    }, (start2, end2) => {
      return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  const timeSunday = timeWeekday(0);
  const timeMonday = timeWeekday(1);
  const timeTuesday = timeWeekday(2);
  const timeWednesday = timeWeekday(3);
  const timeThursday = timeWeekday(4);
  const timeFriday = timeWeekday(5);
  const timeSaturday = timeWeekday(6);
  timeSunday.range;
  timeMonday.range;
  timeTuesday.range;
  timeWednesday.range;
  timeThursday.range;
  timeFriday.range;
  timeSaturday.range;
  function utcWeekday(i) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, (start2, end2) => {
      return (end2 - start2) / durationWeek;
    });
  }
  const utcSunday = utcWeekday(0);
  const utcMonday = utcWeekday(1);
  const utcTuesday = utcWeekday(2);
  const utcWednesday = utcWeekday(3);
  const utcThursday = utcWeekday(4);
  const utcFriday = utcWeekday(5);
  const utcSaturday = utcWeekday(6);
  utcSunday.range;
  utcMonday.range;
  utcTuesday.range;
  utcWednesday.range;
  utcThursday.range;
  utcFriday.range;
  utcSaturday.range;
  const timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setMonth(date2.getMonth() + step);
  }, (start2, end2) => {
    return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  timeMonth.range;
  const utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, (start2, end2) => {
    return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  utcMonth.range;
  const timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step);
  }, (start2, end2) => {
    return end2.getFullYear() - start2.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k2) => {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step * k2);
    });
  };
  timeYear.range;
  const utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, (start2, end2) => {
    return end2.getUTCFullYear() - start2.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k2) => {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
    });
  };
  utcYear.range;
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start2, stop2, count) {
      const reverse = stop2 < start2;
      if (reverse) [start2, stop2] = [stop2, start2];
      const interval = count && typeof count.range === "function" ? count : tickInterval(start2, stop2, count);
      const ticks3 = interval ? interval.range(start2, +stop2 + 1) : [];
      return reverse ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start2, stop2, count) {
      const target = Math.abs(stop2 - start2) / count;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length) return year.every(tickStep(start2 / durationYear, stop2 / durationYear, count));
      if (i === 0) return millisecond.every(Math.max(tickStep(start2, stop2, count), 1));
      const [t2, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t2.every(step);
    }
    return [ticks2, tickInterval];
  }
  const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
  function localDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      var date2 = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
      date2.setFullYear(d2.y);
      return date2;
    }
    return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
  }
  function utcDate(d2) {
    if (0 <= d2.y && d2.y < 100) {
      var date2 = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
      date2.setUTCFullYear(d2.y);
      return date2;
    }
    return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
  }
  function newDate(y2, m2, d2) {
    return { y: y2, m: m2, d: d2, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale2) {
    var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string = [], i = -1, j = 0, n2 = specifier.length, c6, pad2, format2;
        if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
        while (++i < n2) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad2 = pads[c6 = specifier.charAt(++i)]) != null) c6 = specifier.charAt(++i);
            else pad2 = c6 === "e" ? " " : "0";
            if (format2 = formats2[c6]) c6 = format2(date2, pad2);
            string.push(c6);
            j = i + 1;
          }
        }
        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }
    function newParse(specifier, Z2) {
      return function(string) {
        var d2 = newDate(1900, void 0, 1), i = parseSpecifier(d2, specifier, string += "", 0), week, day;
        if (i != string.length) return null;
        if ("Q" in d2) return new Date(d2.Q);
        if ("s" in d2) return new Date(d2.s * 1e3 + ("L" in d2 ? d2.L : 0));
        if (Z2 && !("Z" in d2)) d2.Z = 0;
        if ("p" in d2) d2.H = d2.H % 12 + d2.p * 12;
        if (d2.m === void 0) d2.m = "q" in d2 ? d2.q : 0;
        if ("V" in d2) {
          if (d2.V < 1 || d2.V > 53) return null;
          if (!("w" in d2)) d2.w = 1;
          if ("Z" in d2) {
            week = utcDate(newDate(d2.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d2.V - 1) * 7);
            d2.y = week.getUTCFullYear();
            d2.m = week.getUTCMonth();
            d2.d = week.getUTCDate() + (d2.w + 6) % 7;
          } else {
            week = localDate(newDate(d2.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d2.V - 1) * 7);
            d2.y = week.getFullYear();
            d2.m = week.getMonth();
            d2.d = week.getDate() + (d2.w + 6) % 7;
          }
        } else if ("W" in d2 || "U" in d2) {
          if (!("w" in d2)) d2.w = "u" in d2 ? d2.u % 7 : "W" in d2 ? 1 : 0;
          day = "Z" in d2 ? utcDate(newDate(d2.y, 0, 1)).getUTCDay() : localDate(newDate(d2.y, 0, 1)).getDay();
          d2.m = 0;
          d2.d = "W" in d2 ? (d2.w + 6) % 7 + d2.W * 7 - (day + 5) % 7 : d2.w + d2.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d2) {
          d2.H += d2.Z / 100 | 0;
          d2.M += d2.Z % 100;
          return utcDate(d2);
        }
        return localDate(d2);
      };
    }
    function parseSpecifier(d2, specifier, string, j) {
      var i = 0, n2 = specifier.length, m2 = string.length, c6, parse2;
      while (i < n2) {
        if (j >= m2) return -1;
        c6 = specifier.charCodeAt(i++);
        if (c6 === 37) {
          c6 = specifier.charAt(i++);
          parse2 = parses[c6 in pads ? specifier.charAt(i++) : c6];
          if (!parse2 || (j = parse2(d2, string, j)) < 0) return -1;
        } else if (c6 != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d2, string, i) {
      var n2 = periodRe.exec(string.slice(i));
      return n2 ? (d2.p = periodLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseShortWeekday(d2, string, i) {
      var n2 = shortWeekdayRe.exec(string.slice(i));
      return n2 ? (d2.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseWeekday(d2, string, i) {
      var n2 = weekdayRe.exec(string.slice(i));
      return n2 ? (d2.w = weekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseShortMonth(d2, string, i) {
      var n2 = shortMonthRe.exec(string.slice(i));
      return n2 ? (d2.m = shortMonthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseMonth(d2, string, i) {
      var n2 = monthRe.exec(string.slice(i));
      return n2 ? (d2.m = monthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
    }
    function parseLocaleDateTime(d2, string, i) {
      return parseSpecifier(d2, locale_dateTime, string, i);
    }
    function parseLocaleDate(d2, string, i) {
      return parseSpecifier(d2, locale_date, string, i);
    }
    function parseLocaleTime(d2, string, i) {
      return parseSpecifier(d2, locale_time, string, i);
    }
    function formatShortWeekday(d2) {
      return locale_shortWeekdays[d2.getDay()];
    }
    function formatWeekday(d2) {
      return locale_weekdays[d2.getDay()];
    }
    function formatShortMonth(d2) {
      return locale_shortMonths[d2.getMonth()];
    }
    function formatMonth(d2) {
      return locale_months[d2.getMonth()];
    }
    function formatPeriod(d2) {
      return locale_periods[+(d2.getHours() >= 12)];
    }
    function formatQuarter(d2) {
      return 1 + ~~(d2.getMonth() / 3);
    }
    function formatUTCShortWeekday(d2) {
      return locale_shortWeekdays[d2.getUTCDay()];
    }
    function formatUTCWeekday(d2) {
      return locale_weekdays[d2.getUTCDay()];
    }
    function formatUTCShortMonth(d2) {
      return locale_shortMonths[d2.getUTCMonth()];
    }
    function formatUTCMonth(d2) {
      return locale_months[d2.getUTCMonth()];
    }
    function formatUTCPeriod(d2) {
      return locale_periods[+(d2.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d2) {
      return 1 + ~~(d2.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f2 = newFormat(specifier += "", formats);
        f2.toString = function() {
          return specifier;
        };
        return f2;
      },
      parse: function(specifier) {
        var p2 = newParse(specifier += "", false);
        p2.toString = function() {
          return specifier;
        };
        return p2;
      },
      utcFormat: function(specifier) {
        var f2 = newFormat(specifier += "", utcFormats);
        f2.toString = function() {
          return specifier;
        };
        return f2;
      },
      utcParse: function(specifier) {
        var p2 = newParse(specifier += "", true);
        p2.toString = function() {
          return specifier;
        };
        return p2;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad(value, fill, width2) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length2 = string.length;
    return sign + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
  }
  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d2.w = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d2.u = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberSunday(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.U = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberISO(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.V = +n2[0], i + n2[0].length) : -1;
  }
  function parseWeekNumberMonday(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.W = +n2[0], i + n2[0].length) : -1;
  }
  function parseFullYear(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 4));
    return n2 ? (d2.y = +n2[0], i + n2[0].length) : -1;
  }
  function parseYear(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i + n2[0].length) : -1;
  }
  function parseZone(d2, string, i) {
    var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n2 ? (d2.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i + n2[0].length) : -1;
  }
  function parseQuarter(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 1));
    return n2 ? (d2.q = n2[0] * 3 - 3, i + n2[0].length) : -1;
  }
  function parseMonthNumber(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.m = n2[0] - 1, i + n2[0].length) : -1;
  }
  function parseDayOfMonth(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.d = +n2[0], i + n2[0].length) : -1;
  }
  function parseDayOfYear(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 3));
    return n2 ? (d2.m = 0, d2.d = +n2[0], i + n2[0].length) : -1;
  }
  function parseHour24(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.H = +n2[0], i + n2[0].length) : -1;
  }
  function parseMinutes(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.M = +n2[0], i + n2[0].length) : -1;
  }
  function parseSeconds(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 2));
    return n2 ? (d2.S = +n2[0], i + n2[0].length) : -1;
  }
  function parseMilliseconds(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 3));
    return n2 ? (d2.L = +n2[0], i + n2[0].length) : -1;
  }
  function parseMicroseconds(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i, i + 6));
    return n2 ? (d2.L = Math.floor(n2[0] / 1e3), i + n2[0].length) : -1;
  }
  function parseLiteralPercent(d2, string, i) {
    var n2 = percentRe.exec(string.slice(i, i + 1));
    return n2 ? i + n2[0].length : -1;
  }
  function parseUnixTimestamp(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i));
    return n2 ? (d2.Q = +n2[0], i + n2[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d2, string, i) {
    var n2 = numberRe.exec(string.slice(i));
    return n2 ? (d2.s = +n2[0], i + n2[0].length) : -1;
  }
  function formatDayOfMonth(d2, p2) {
    return pad(d2.getDate(), p2, 2);
  }
  function formatHour24(d2, p2) {
    return pad(d2.getHours(), p2, 2);
  }
  function formatHour12(d2, p2) {
    return pad(d2.getHours() % 12 || 12, p2, 2);
  }
  function formatDayOfYear(d2, p2) {
    return pad(1 + timeDay.count(timeYear(d2), d2), p2, 3);
  }
  function formatMilliseconds(d2, p2) {
    return pad(d2.getMilliseconds(), p2, 3);
  }
  function formatMicroseconds(d2, p2) {
    return formatMilliseconds(d2, p2) + "000";
  }
  function formatMonthNumber(d2, p2) {
    return pad(d2.getMonth() + 1, p2, 2);
  }
  function formatMinutes(d2, p2) {
    return pad(d2.getMinutes(), p2, 2);
  }
  function formatSeconds(d2, p2) {
    return pad(d2.getSeconds(), p2, 2);
  }
  function formatWeekdayNumberMonday(d2) {
    var day = d2.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d2, p2) {
    return pad(timeSunday.count(timeYear(d2) - 1, d2), p2, 2);
  }
  function dISO(d2) {
    var day = d2.getDay();
    return day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
  }
  function formatWeekNumberISO(d2, p2) {
    d2 = dISO(d2);
    return pad(timeThursday.count(timeYear(d2), d2) + (timeYear(d2).getDay() === 4), p2, 2);
  }
  function formatWeekdayNumberSunday(d2) {
    return d2.getDay();
  }
  function formatWeekNumberMonday(d2, p2) {
    return pad(timeMonday.count(timeYear(d2) - 1, d2), p2, 2);
  }
  function formatYear(d2, p2) {
    return pad(d2.getFullYear() % 100, p2, 2);
  }
  function formatYearISO(d2, p2) {
    d2 = dISO(d2);
    return pad(d2.getFullYear() % 100, p2, 2);
  }
  function formatFullYear(d2, p2) {
    return pad(d2.getFullYear() % 1e4, p2, 4);
  }
  function formatFullYearISO(d2, p2) {
    var day = d2.getDay();
    d2 = day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
    return pad(d2.getFullYear() % 1e4, p2, 4);
  }
  function formatZone(d2) {
    var z2 = d2.getTimezoneOffset();
    return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d2, p2) {
    return pad(d2.getUTCDate(), p2, 2);
  }
  function formatUTCHour24(d2, p2) {
    return pad(d2.getUTCHours(), p2, 2);
  }
  function formatUTCHour12(d2, p2) {
    return pad(d2.getUTCHours() % 12 || 12, p2, 2);
  }
  function formatUTCDayOfYear(d2, p2) {
    return pad(1 + utcDay.count(utcYear(d2), d2), p2, 3);
  }
  function formatUTCMilliseconds(d2, p2) {
    return pad(d2.getUTCMilliseconds(), p2, 3);
  }
  function formatUTCMicroseconds(d2, p2) {
    return formatUTCMilliseconds(d2, p2) + "000";
  }
  function formatUTCMonthNumber(d2, p2) {
    return pad(d2.getUTCMonth() + 1, p2, 2);
  }
  function formatUTCMinutes(d2, p2) {
    return pad(d2.getUTCMinutes(), p2, 2);
  }
  function formatUTCSeconds(d2, p2) {
    return pad(d2.getUTCSeconds(), p2, 2);
  }
  function formatUTCWeekdayNumberMonday(d2) {
    var dow = d2.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d2, p2) {
    return pad(utcSunday.count(utcYear(d2) - 1, d2), p2, 2);
  }
  function UTCdISO(d2) {
    var day = d2.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
  }
  function formatUTCWeekNumberISO(d2, p2) {
    d2 = UTCdISO(d2);
    return pad(utcThursday.count(utcYear(d2), d2) + (utcYear(d2).getUTCDay() === 4), p2, 2);
  }
  function formatUTCWeekdayNumberSunday(d2) {
    return d2.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d2, p2) {
    return pad(utcMonday.count(utcYear(d2) - 1, d2), p2, 2);
  }
  function formatUTCYear(d2, p2) {
    return pad(d2.getUTCFullYear() % 100, p2, 2);
  }
  function formatUTCYearISO(d2, p2) {
    d2 = UTCdISO(d2);
    return pad(d2.getUTCFullYear() % 100, p2, 2);
  }
  function formatUTCFullYear(d2, p2) {
    return pad(d2.getUTCFullYear() % 1e4, p2, 4);
  }
  function formatUTCFullYearISO(d2, p2) {
    var day = d2.getUTCDay();
    d2 = day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
    return pad(d2.getUTCFullYear() % 1e4, p2, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d2) {
    return +d2;
  }
  function formatUnixTimestampSeconds(d2) {
    return Math.floor(+d2 / 1e3);
  }
  var locale;
  var timeFormat;
  var utcFormat;
  defaultLocale({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale(definition) {
    locale = formatLocale(definition);
    timeFormat = locale.format;
    locale.parse;
    utcFormat = locale.utcFormat;
    locale.utcParse;
    return locale;
  }
  function date(t2) {
    return new Date(t2);
  }
  function number(t2) {
    return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
    var scale = continuous(), invert = scale.invert, domain = scale.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
    }
    scale.invert = function(y2) {
      return new Date(invert(y2));
    };
    scale.domain = function(_) {
      return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
    };
    scale.ticks = function(interval) {
      var d2 = domain();
      return ticks2(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
    };
    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale.nice = function(interval) {
      var d2 = domain();
      if (!interval || typeof interval.range !== "function") interval = tickInterval(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
      return interval ? domain(nice(d2, interval)) : scale;
    };
    scale.copy = function() {
      return copy$1(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
    };
    return scale;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }
  function transformer() {
    var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$1, clamp2 = false, unknown;
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
    }
    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = !!_, scale) : clamp2;
    };
    scale.interpolator = function(_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
      };
    }
    scale.range = range2(interpolate$1);
    scale.rangeRound = range2(interpolateRound);
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t2) {
      transform = t2, t02 = t2(x0), t12 = t2(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
      return scale;
    };
  }
  function copy(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
  }
  function sequential() {
    var scale = linearish(transformer()(identity$1));
    scale.copy = function() {
      return copy(scale, sequential());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function getSequentialColorScale(config2) {
    if (config2.type === "piecewise") {
      return threshold(config2.thresholds, config2.colors);
    }
    return sequential([config2.min ?? 0, config2.max ?? 100], config2.color);
  }
  function getOrdinalColorScale(config2) {
    if (config2.values) {
      return ordinal(config2.values, config2.colors).unknown(config2.unknownColor ?? null);
    }
    return ordinal(config2.colors.map((_, index) => index), config2.colors).unknown(config2.unknownColor ?? null);
  }
  function getColorScale(config2) {
    return config2.type === "ordinal" ? getOrdinalColorScale(config2) : getSequentialColorScale(config2);
  }
  const ZAxisContext = /* @__PURE__ */ reactExports.createContext({
    zAxis: {},
    zAxisIds: []
  });
  function ZAxisContextProvider(props) {
    const {
      zAxis: inZAxis,
      dataset,
      children
    } = props;
    const zAxis = reactExports.useMemo(() => inZAxis == null ? void 0 : inZAxis.map((axisConfig) => {
      const dataKey = axisConfig.dataKey;
      if (dataKey === void 0 || axisConfig.data !== void 0) {
        return axisConfig;
      }
      if (dataset === void 0) {
        throw new Error("MUI X: z-axis uses `dataKey` but no `dataset` is provided.");
      }
      return _extends({}, axisConfig, {
        data: dataset.map((d2) => d2[dataKey])
      });
    }), [inZAxis, dataset]);
    const value = reactExports.useMemo(() => {
      const allZAxis = (zAxis == null ? void 0 : zAxis.map((axis, index) => _extends({
        id: `defaultized-z-axis-${index}`
      }, axis))) ?? [];
      const completedZAxis = {};
      allZAxis.forEach((axis) => {
        completedZAxis[axis.id] = _extends({}, axis, {
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" && axis.data ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap.type === "continuous" ? _extends({
            min: axis.min,
            max: axis.max
          }, axis.colorMap) : axis.colorMap))
        });
      });
      return {
        zAxis: completedZAxis,
        zAxisIds: allZAxis.map(({
          id: id2
        }) => id2)
      };
    }, [zAxis]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ZAxisContext.Provider, {
      value,
      children
    });
  }
  const useChartDimensions = (width2, height2, margin2) => {
    const defaultizedMargin = _extends({}, DEFAULT_MARGINS, margin2);
    const drawingArea = reactExports.useMemo(() => ({
      left: defaultizedMargin.left,
      top: defaultizedMargin.top,
      right: defaultizedMargin.right,
      bottom: defaultizedMargin.bottom,
      width: Math.max(0, width2 - defaultizedMargin.left - defaultizedMargin.right),
      height: Math.max(0, height2 - defaultizedMargin.top - defaultizedMargin.bottom)
    }), [width2, height2, defaultizedMargin.top, defaultizedMargin.bottom, defaultizedMargin.left, defaultizedMargin.right]);
    return drawingArea;
  };
  const DrawingContext = /* @__PURE__ */ reactExports.createContext({
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    height: 300,
    width: 400,
    chartId: "",
    isPointInside: () => false
  });
  const SvgContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {
      current: null
    }
  });
  function DrawingProvider(props) {
    const {
      width: width2,
      height: height2,
      margin: margin2,
      svgRef,
      children
    } = props;
    const drawingArea = useChartDimensions(width2, height2, margin2);
    const chartId = useId();
    const isPointInside = reactExports.useCallback(({
      x: x2,
      y: y2
    }, options) => {
      if ((options == null ? void 0 : options.targetElement) && (options == null ? void 0 : options.targetElement.closest("[data-drawing-container]"))) {
        return true;
      }
      const isInsideX = x2 >= drawingArea.left - 1 && x2 <= drawingArea.left + drawingArea.width;
      const isInsideY = y2 >= drawingArea.top - 1 && y2 <= drawingArea.top + drawingArea.height;
      if ((options == null ? void 0 : options.direction) === "x") {
        return isInsideX;
      }
      if ((options == null ? void 0 : options.direction) === "y") {
        return isInsideY;
      }
      return isInsideX && isInsideY;
    }, [drawingArea]);
    const value = reactExports.useMemo(() => _extends({
      chartId: chartId ?? ""
    }, drawingArea, {
      isPointInside
    }), [chartId, drawingArea, isPointInside]);
    const refValue = reactExports.useMemo(() => ({
      isInitialized: true,
      data: svgRef
    }), [svgRef]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgContext.Provider, {
      value: refValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawingContext.Provider, {
        value,
        children
      })
    });
  }
  function useDrawingArea() {
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      bottom: bottom2,
      right: right2,
      isPointInside
    } = reactExports.useContext(DrawingContext);
    return reactExports.useMemo(() => ({
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      bottom: bottom2,
      right: right2,
      isPointInside
    }), [height2, left2, top2, width2, bottom2, right2, isPointInside]);
  }
  function useChartId() {
    const {
      chartId
    } = reactExports.useContext(DrawingContext);
    return reactExports.useMemo(() => chartId, [chartId]);
  }
  function isBandScale(scale) {
    return scale.bandwidth !== void 0;
  }
  function isBandScaleConfig(scaleConfig) {
    return scaleConfig.scaleType === "band";
  }
  function isPointScaleConfig(scaleConfig) {
    return scaleConfig.scaleType === "point";
  }
  function isInfinity(v2) {
    return typeof v2 === "number" && !Number.isFinite(v2);
  }
  function getTickNumber(params) {
    const {
      tickMaxStep,
      tickMinStep,
      tickNumber,
      range: range2,
      domain
    } = params;
    const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
    const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
    const defaultizedTickNumber = tickNumber ?? Math.floor(Math.abs(range2[1] - range2[0]) / 50);
    return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
  }
  const offsetRatio = {
    start: 0,
    extremities: 0,
    end: 1,
    middle: 0.5
  };
  function useTicks(options) {
    const {
      scale,
      tickNumber,
      valueFormatter,
      tickInterval,
      tickPlacement = "extremities",
      tickLabelPlacement = "middle"
    } = options;
    return reactExports.useMemo(() => {
      if (isBandScale(scale)) {
        const domain2 = scale.domain();
        if (scale.bandwidth() > 0) {
          const filteredDomain2 = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
          return [...filteredDomain2.map((value) => ({
            value,
            formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
              location: "tick"
            })) ?? `${value}`,
            offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
            labelOffset: tickLabelPlacement === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement] - offsetRatio[tickPlacement])
          })), ...tickPlacement === "extremities" ? [{
            formattedValue: void 0,
            offset: scale.range()[1],
            labelOffset: 0
          }] : []];
        }
        const filteredDomain = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
        return filteredDomain.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick"
          })) ?? `${value}`,
          offset: scale(value),
          labelOffset: 0
        }));
      }
      const domain = scale.domain();
      if (domain.some(isInfinity)) {
        return [];
      }
      const ticks2 = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
      return ticks2.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick"
        })) ?? scale.tickFormat(tickNumber)(value),
        offset: scale(value),
        labelOffset: 0
      }));
    }, [scale, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacement]);
  }
  function getScale(scaleType, domain, range2) {
    switch (scaleType) {
      case "log":
        return log$1(domain, range2);
      case "pow":
        return pow(domain, range2);
      case "sqrt":
        return sqrt(domain, range2);
      case "time":
        return time(domain, range2);
      case "utc":
        return utcTime(domain, range2);
      default:
        return linear(domain, range2);
    }
  }
  const zoomScaleRange = (scaleRange, zoomRange) => {
    const rangeGap = scaleRange[1] - scaleRange[0];
    const zoomGap = zoomRange[1] - zoomRange[0];
    const min2 = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
    const max2 = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
    return [min2, max2];
  };
  const axisExtremumCallback = (acc, chartType, axis, getters, axisIndex, formattedSeries, getFilters) => {
    var _a;
    const getter = getters[chartType];
    const series = ((_a = formattedSeries[chartType]) == null ? void 0 : _a.series) ?? {};
    const [minChartTypeData, maxChartTypeData] = (getter == null ? void 0 : getter({
      series,
      axis,
      axisIndex,
      isDefaultAxis: axisIndex === 0,
      getFilters
    })) ?? [Infinity, -Infinity];
    const [minData, maxData] = acc;
    return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
  };
  const getAxisExtremum = (axis, getters, axisIndex, formattedSeries, getFilters) => {
    const charTypes = Object.keys(getters);
    const extremums = charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, axisIndex, formattedSeries, getFilters), [Infinity, -Infinity]);
    if (Number.isNaN(extremums[0]) || Number.isNaN(extremums[1])) {
      return [Infinity, -Infinity];
    }
    return extremums;
  };
  function getRange(drawingArea, axisDirection, axis) {
    if (axisDirection === "rotation") {
      const {
        startAngle = 0,
        endAngle = startAngle + 360
      } = axis;
      return axis.reverse ? [Math.PI * startAngle / 180, Math.PI * endAngle / 180] : [Math.PI * endAngle / 180, Math.PI * startAngle / 180];
    }
    if (axisDirection === "radius") {
      const {
        minRadius = 0,
        maxRadius = Math.min(drawingArea.width, drawingArea.height) / 2
      } = axis;
      return [minRadius, maxRadius];
    }
    const range2 = axisDirection === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
    return axis.reverse ? [range2[1], range2[0]] : range2;
  }
  const isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
  function createDateFormatter(axis, range2) {
    const timeScale = time(axis.data, range2);
    return (v2, {
      location
    }) => location === "tick" ? timeScale.tickFormat(axis.tickNumber)(v2) : `${v2.toLocaleString()}`;
  }
  const DEFAULT_CATEGORY_GAP_RATIO = 0.2;
  const DEFAULT_BAR_GAP_RATIO = 0.1;
  function computeAxisValue({
    drawingArea,
    formattedSeries,
    axis: allAxis,
    extremumGetters,
    axisDirection,
    zoomData,
    zoomOptions,
    getFilters
  }) {
    const completeAxis = {};
    allAxis.forEach((eachAxis, axisIndex) => {
      const axis = eachAxis;
      const zoomOption = zoomOptions == null ? void 0 : zoomOptions[axis.id];
      const zoom = zoomData == null ? void 0 : zoomData.find(({
        axisId
      }) => axisId === axis.id);
      const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
      const range2 = getRange(drawingArea, axisDirection, axis);
      const [minData, maxData] = getAxisExtremum(
        axis,
        extremumGetters,
        axisIndex,
        formattedSeries,
        zoom === void 0 && !zoomOption ? getFilters : void 0
        // Do not apply filtering if zoom is already defined.
      );
      const data = axis.data ?? [];
      if (isBandScaleConfig(axis)) {
        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;
        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;
        const scaleRange = axisDirection === "y" ? [range2[1], range2[0]] : range2;
        const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
        completeAxis[axis.id] = _extends({
          categoryGapRatio,
          barGapRatio
        }, axis, {
          data,
          scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
          tickNumber: axis.data.length,
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap))
        });
        if (isDateData(axis.data)) {
          const dateFormatter = createDateFormatter(axis, scaleRange);
          completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
        }
      }
      if (isPointScaleConfig(axis)) {
        const scaleRange = axisDirection === "y" ? [...range2].reverse() : range2;
        const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
        completeAxis[axis.id] = _extends({}, axis, {
          data,
          scale: point(axis.data, zoomedRange2),
          tickNumber: axis.data.length,
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap))
        });
        if (isDateData(axis.data)) {
          const dateFormatter = createDateFormatter(axis, scaleRange);
          completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;
        }
      }
      if (axis.scaleType === "band" || axis.scaleType === "point") {
        return;
      }
      const scaleType = axis.scaleType ?? "linear";
      const axisExtremums = [axis.min ?? minData, axis.max ?? maxData];
      const rawTickNumber = getTickNumber(_extends({}, axis, {
        range: range2,
        domain: axisExtremums
      }));
      const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
      const zoomedRange = zoomScaleRange(range2, zoomRange);
      const scale = getScale(scaleType, axisExtremums, zoomedRange).nice(rawTickNumber);
      const [minDomain, maxDomain] = scale.domain();
      const domain = [axis.min ?? minDomain, axis.max ?? maxDomain];
      completeAxis[axis.id] = _extends({}, axis, {
        data,
        scaleType,
        scale: scale.domain(domain),
        tickNumber,
        colorScale: axis.colorMap && getColorScale(axis.colorMap)
      });
    });
    return {
      axis: completeAxis,
      axisIds: allAxis.map(({
        id: id2
      }) => id2)
    };
  }
  const CartesianContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {
      xAxis: {},
      yAxis: {},
      xAxisIds: [],
      yAxisIds: []
    }
  });
  function CartesianProvider(props) {
    const {
      xAxis,
      yAxis,
      children
    } = props;
    const formattedSeries = useSeries();
    const drawingArea = useDrawingArea();
    const xExtremumGetters = useXExtremumGetter();
    const yExtremumGetters = useYExtremumGetter();
    const xValues = reactExports.useMemo(() => computeAxisValue({
      drawingArea,
      formattedSeries,
      axis: xAxis,
      extremumGetters: xExtremumGetters,
      axisDirection: "x"
    }), [drawingArea, formattedSeries, xAxis, xExtremumGetters]);
    const yValues = reactExports.useMemo(() => computeAxisValue({
      drawingArea,
      formattedSeries,
      axis: yAxis,
      extremumGetters: yExtremumGetters,
      axisDirection: "y"
    }), [drawingArea, formattedSeries, yAxis, yExtremumGetters]);
    const value = reactExports.useMemo(() => ({
      isInitialized: true,
      data: {
        xAxis: xValues.axis,
        yAxis: yValues.axis,
        xAxisIds: xValues.axisIds,
        yAxisIds: yValues.axisIds
      }
    }), [xValues, yValues]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianContext.Provider, {
      value,
      children
    });
  }
  const useCartesianContext = () => {
    const {
      data
    } = reactExports.useContext(CartesianContext);
    return data;
  };
  function getValueToPositionMapper(scale) {
    if (isBandScale(scale)) {
      return (value) => (scale(value) ?? 0) + scale.bandwidth() / 2;
    }
    return (value) => scale(value);
  }
  function useSvgRef() {
    const {
      isInitialized,
      data
    } = reactExports.useContext(SvgContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }
  function ChartsClipPath(props) {
    const {
      id: id2,
      offset: offsetProps
    } = props;
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2
    } = useDrawingArea();
    const offset2 = _extends({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, offsetProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", {
      id: id2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
        x: left2 - offset2.left,
        y: top2 - offset2.top,
        width: width2 + offset2.left + offset2.right,
        height: height2 + offset2.top + offset2.bottom
      })
    });
  }
  function isSsr() {
    return typeof window === "undefined";
  }
  const stringCache = {
    widthCache: {},
    cacheCount: 0
  };
  const MAX_CACHE_NUM = 2e3;
  const SPAN_STYLE = {
    position: "absolute",
    top: "-20000px",
    left: 0,
    padding: 0,
    margin: 0,
    border: "none",
    whiteSpace: "pre"
  };
  const STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
  const MEASUREMENT_SPAN_ID = "mui_measurement_span";
  function autoCompleteStyle(name, value) {
    if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
      return `${value}px`;
    }
    return value;
  }
  function camelToMiddleLine(text) {
    const strs = text.split("");
    const formatStrs = strs.reduce((result, entry) => {
      if (entry === entry.toUpperCase()) {
        return [...result, "-", entry.toLowerCase()];
      }
      return [...result, entry];
    }, []);
    return formatStrs.join("");
  }
  const getStyleString = (style2) => Object.keys(style2).sort().reduce((result, s) => `${result}${camelToMiddleLine(s)}:${autoCompleteStyle(s, style2[s])};`, "");
  let domCleanTimeout;
  const getStringSize = (text, style2 = {}) => {
    if (text === void 0 || text === null || isSsr()) {
      return {
        width: 0,
        height: 0
      };
    }
    const str = `${text}`;
    const styleString = getStyleString(style2);
    const cacheKey2 = `${str}-${styleString}`;
    if (stringCache.widthCache[cacheKey2]) {
      return stringCache.widthCache[cacheKey2];
    }
    try {
      let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
      if (measurementSpan === null) {
        measurementSpan = document.createElement("span");
        measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
        measurementSpan.setAttribute("aria-hidden", "true");
        document.body.appendChild(measurementSpan);
      }
      const measurementSpanStyle = _extends({}, SPAN_STYLE, style2);
      Object.keys(measurementSpanStyle).map((styleKey) => {
        measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
        return styleKey;
      });
      measurementSpan.textContent = str;
      const rect = measurementSpan.getBoundingClientRect();
      const result = {
        width: rect.width,
        height: rect.height
      };
      stringCache.widthCache[cacheKey2] = result;
      if (stringCache.cacheCount + 1 > MAX_CACHE_NUM) {
        stringCache.cacheCount = 0;
        stringCache.widthCache = {};
      } else {
        stringCache.cacheCount += 1;
      }
      if (domCleanTimeout) {
        clearTimeout(domCleanTimeout);
      }
      domCleanTimeout = setTimeout(() => {
        measurementSpan.textContent = "";
      }, 0);
      return result;
    } catch {
      return {
        width: 0,
        height: 0
      };
    }
  };
  function getWordsByLines({
    style: style2,
    needsComputation,
    text
  }) {
    return text.split("\n").map((subText) => _extends({
      text: subText
    }, needsComputation ? getStringSize(subText, style2) : {
      width: 0,
      height: 0
    }));
  }
  const _excluded$o = ["x", "y", "style", "text", "ownerState"], _excluded2$3 = ["angle", "textAnchor", "dominantBaseline"];
  function ChartsText(props) {
    const {
      x: x2,
      y: y2,
      style: styleProps,
      text
    } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded$o);
    const _ref = styleProps ?? {}, {
      angle,
      textAnchor,
      dominantBaseline
    } = _ref, style2 = _objectWithoutPropertiesLoose(_ref, _excluded2$3);
    const wordsByLines = reactExports.useMemo(() => getWordsByLines({
      style: style2,
      needsComputation: text.includes("\n"),
      text
    }), [style2, text]);
    let startDy;
    switch (dominantBaseline) {
      case "hanging":
        startDy = 0;
        break;
      case "central":
        startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
        break;
      default:
        startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
        break;
    }
    const transforms = [];
    if (angle) {
      transforms.push(`rotate(${angle}, ${x2}, ${y2})`);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("text", _extends({}, textProps, {
      transform: transforms.length > 0 ? transforms.join(" ") : void 0,
      x: x2,
      y: y2,
      textAnchor,
      dominantBaseline,
      style: style2,
      children: wordsByLines.map((line2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("tspan", {
        x: x2,
        dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
        dominantBaseline,
        children: line2.text
      }, index))
    }));
  }
  function getAxisUtilityClass(slot) {
    return generateUtilityClass("MuiChartsAxis", slot);
  }
  const axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);
  const AxisRoot = styled("g", {
    name: "MuiChartsAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
      fill: (theme.vars || theme).palette.text.primary
    }),
    [`& .${axisClasses.label}`]: _extends({}, theme.typography.body1, {
      fill: (theme.vars || theme).palette.text.primary
    }),
    [`& .${axisClasses.line}`]: {
      stroke: (theme.vars || theme).palette.text.primary,
      shapeRendering: "crispEdges",
      strokeWidth: 1
    },
    [`& .${axisClasses.tick}`]: {
      stroke: (theme.vars || theme).palette.text.primary,
      shapeRendering: "crispEdges"
    }
  }));
  const ANGLE_APPROX = 5;
  function getMinXTranslation(width2, height2, angle = 0) {
    const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
    if (standardAngle < ANGLE_APPROX) {
      return width2;
    }
    if (standardAngle > 90 - ANGLE_APPROX) {
      return height2;
    }
    const radAngle = standardAngle * Math.PI / 180;
    const angleSwich = Math.atan2(height2, width2);
    if (radAngle < angleSwich) {
      return width2 / Math.cos(radAngle);
    }
    return height2 / Math.sin(radAngle);
  }
  function useMounted(defer = false) {
    const [mountedState, setMountedState] = reactExports.useState(false);
    useEnhancedEffect(() => {
      if (!defer) {
        setMountedState(true);
      }
    }, [defer]);
    reactExports.useEffect(() => {
      if (defer) {
        setMountedState(true);
      }
    }, [defer]);
    return mountedState;
  }
  const _excluded$n = ["scale", "tickNumber", "reverse"];
  const useUtilityClasses$a = (ownerState) => {
    const {
      classes,
      position: position2
    } = ownerState;
    const slots = {
      root: ["root", "directionX", position2],
      line: ["line"],
      tickContainer: ["tickContainer"],
      tick: ["tick"],
      tickLabel: ["tickLabel"],
      label: ["label"]
    };
    return composeClasses(slots, getAxisUtilityClass, classes);
  };
  function addLabelDimension(xTicks, {
    tickLabelStyle: style2,
    tickLabelInterval,
    reverse,
    isMounted
  }) {
    const withDimension = xTicks.map((tick) => {
      if (!isMounted || tick.formattedValue === void 0) {
        return _extends({}, tick, {
          width: 0,
          height: 0
        });
      }
      const tickSizes = getWordsByLines({
        style: style2,
        needsComputation: true,
        text: tick.formattedValue
      });
      return _extends({}, tick, {
        width: Math.max(...tickSizes.map((size) => size.width)),
        height: Math.max(tickSizes.length * tickSizes[0].height)
      });
    });
    if (typeof tickLabelInterval === "function") {
      return withDimension.map((item, index) => _extends({}, item, {
        skipLabel: !tickLabelInterval(item.value, index)
      }));
    }
    let currentTextLimit = 0;
    let previousTextLimit = 0;
    const direction = reverse ? -1 : 1;
    return withDimension.map((item, labelIndex) => {
      const {
        width: width2,
        offset: offset2,
        labelOffset,
        height: height2
      } = item;
      const distance = getMinXTranslation(width2, height2, style2 == null ? void 0 : style2.angle);
      const textPosition = offset2 + labelOffset;
      const gapRatio = 1.2;
      currentTextLimit = textPosition - direction * (gapRatio * distance) / 2;
      if (labelIndex > 0 && direction * currentTextLimit < direction * previousTextLimit) {
        return _extends({}, item, {
          skipLabel: true
        });
      }
      previousTextLimit = textPosition + direction * (gapRatio * distance) / 2;
      return item;
    });
  }
  const XAxisRoot = styled(AxisRoot, {
    name: "MuiChartsXAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const defaultProps$1 = {
    position: "bottom",
    disableLine: false,
    disableTicks: false,
    tickSize: 6
  };
  function ChartsXAxis(inProps) {
    const {
      xAxisIds,
      xAxis
    } = useCartesianContext();
    const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
      scale: xScale,
      tickNumber,
      reverse
    } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded$n);
    const isMounted = useMounted();
    const themedProps = useThemeProps({
      props: _extends({}, settings, inProps),
      name: "MuiChartsXAxis"
    });
    const defaultizedProps = _extends({}, defaultProps$1, themedProps);
    const {
      position: position2,
      disableLine,
      disableTicks,
      tickLabelStyle,
      label,
      labelStyle,
      tickFontSize,
      labelFontSize,
      tickSize: tickSizeProp,
      valueFormatter,
      slots,
      slotProps,
      tickInterval,
      tickLabelInterval,
      tickPlacement,
      tickLabelPlacement,
      sx
    } = defaultizedProps;
    const theme = useTheme();
    const classes = useUtilityClasses$a(_extends({}, defaultizedProps, {
      theme
    }));
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      isPointInside
    } = useDrawingArea();
    const tickSize = disableTicks ? 4 : tickSizeProp;
    const positionSign = position2 === "bottom" ? 1 : -1;
    const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
    const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
    const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
    const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
    const axisTickLabelProps = useSlotProps({
      elementType: TickLabel,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
      additionalProps: {
        style: _extends({
          textAnchor: "middle",
          dominantBaseline: position2 === "bottom" ? "hanging" : "auto",
          fontSize: tickFontSize ?? 12
        }, tickLabelStyle)
      },
      className: classes.tickLabel,
      ownerState: {}
    });
    const xTicks = useTicks({
      scale: xScale,
      tickNumber,
      valueFormatter,
      tickInterval,
      tickPlacement,
      tickLabelPlacement
    });
    const xTicksWithDimension = addLabelDimension(xTicks, {
      tickLabelStyle: axisTickLabelProps.style,
      tickLabelInterval,
      reverse,
      isMounted
    });
    const labelRefPoint = {
      x: left2 + width2 / 2,
      y: positionSign * (tickSize + 22)
    };
    const axisLabelProps = useSlotProps({
      elementType: Label,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
      additionalProps: {
        style: _extends({
          fontSize: labelFontSize ?? 14,
          textAnchor: "middle",
          dominantBaseline: position2 === "bottom" ? "hanging" : "auto"
        }, labelStyle)
      },
      ownerState: {}
    });
    const domain = xScale.domain();
    const ordinalAxis = isBandScale(xScale);
    if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(XAxisRoot, {
      transform: `translate(0, ${position2 === "bottom" ? top2 + height2 : top2})`,
      className: classes.root,
      sx,
      children: [!disableLine && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, _extends({
        x1: left2,
        x2: left2 + width2,
        className: classes.line
      }, slotProps == null ? void 0 : slotProps.axisLine)), xTicksWithDimension.map(({
        formattedValue,
        offset: offset2,
        labelOffset,
        skipLabel
      }, index) => {
        const xTickLabel = labelOffset ?? 0;
        const yTickLabel = positionSign * (tickSize + 3);
        const showTick = isPointInside({
          x: offset2,
          y: -1
        }, {
          direction: "x"
        });
        const showTickLabel = isPointInside({
          x: offset2 + xTickLabel,
          y: -1
        }, {
          direction: "x"
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", {
          transform: `translate(${offset2}, 0)`,
          className: classes.tickContainer,
          children: [!disableTicks && showTick && /* @__PURE__ */ jsxRuntimeExports.jsx(Tick, _extends({
            y2: positionSign * tickSize,
            className: classes.tick
          }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && showTickLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(TickLabel, _extends({
            x: xTickLabel,
            y: yTickLabel
          }, axisTickLabelProps, {
            text: formattedValue.toString()
          }))]
        }, index);
      }), label && /* @__PURE__ */ jsxRuntimeExports.jsx("g", {
        className: classes.label,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label, _extends({}, labelRefPoint, axisLabelProps, {
          text: label
        }))
      })]
    });
  }
  const _excluded$m = ["scale", "tickNumber"];
  const useUtilityClasses$9 = (ownerState) => {
    const {
      classes,
      position: position2
    } = ownerState;
    const slots = {
      root: ["root", "directionY", position2],
      line: ["line"],
      tickContainer: ["tickContainer"],
      tick: ["tick"],
      tickLabel: ["tickLabel"],
      label: ["label"]
    };
    return composeClasses(slots, getAxisUtilityClass, classes);
  };
  const YAxisRoot = styled(AxisRoot, {
    name: "MuiChartsYAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const defaultProps = {
    position: "left",
    disableLine: false,
    disableTicks: false,
    tickFontSize: 12,
    labelFontSize: 14,
    tickSize: 6
  };
  function ChartsYAxis(inProps) {
    const {
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
      scale: yScale,
      tickNumber
    } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded$m);
    const themedProps = useThemeProps({
      props: _extends({}, settings, inProps),
      name: "MuiChartsYAxis"
    });
    const defaultizedProps = _extends({}, defaultProps, themedProps);
    const {
      position: position2,
      disableLine,
      disableTicks,
      tickFontSize,
      label,
      labelFontSize,
      labelStyle,
      tickLabelStyle,
      tickSize: tickSizeProp,
      valueFormatter,
      slots,
      slotProps,
      tickPlacement,
      tickLabelPlacement,
      tickInterval,
      tickLabelInterval,
      sx
    } = defaultizedProps;
    const theme = useTheme();
    const isRtl = useRtl();
    const classes = useUtilityClasses$9(_extends({}, defaultizedProps, {
      theme
    }));
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      isPointInside
    } = useDrawingArea();
    const tickSize = disableTicks ? 4 : tickSizeProp;
    const yTicks = useTicks({
      scale: yScale,
      tickNumber,
      valueFormatter,
      tickPlacement,
      tickLabelPlacement,
      tickInterval
    });
    const positionSign = position2 === "right" ? 1 : -1;
    const labelRefPoint = {
      x: positionSign * (tickFontSize + tickSize + 10),
      y: top2 + height2 / 2
    };
    const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
    const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
    const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
    const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
    const revertAnchor = !isRtl && position2 === "right" || isRtl && position2 !== "right";
    const axisTickLabelProps = useSlotProps({
      elementType: TickLabel,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
      additionalProps: {
        style: _extends({
          fontSize: tickFontSize,
          textAnchor: revertAnchor ? "start" : "end",
          dominantBaseline: "central"
        }, tickLabelStyle)
      },
      className: classes.tickLabel,
      ownerState: {}
    });
    const axisLabelProps = useSlotProps({
      elementType: Label,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
      additionalProps: {
        style: _extends({
          fontSize: labelFontSize,
          angle: positionSign * 90,
          textAnchor: "middle",
          dominantBaseline: "auto"
        }, labelStyle)
      },
      ownerState: {}
    });
    const lineSlotProps = useSlotProps({
      elementType: Line,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
      additionalProps: {
        strokeLinecap: "square"
      },
      ownerState: {}
    });
    const domain = yScale.domain();
    const ordinalAxis = isBandScale(yScale);
    if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(YAxisRoot, {
      transform: `translate(${position2 === "right" ? left2 + width2 : left2}, 0)`,
      className: classes.root,
      sx,
      children: [!disableLine && /* @__PURE__ */ jsxRuntimeExports.jsx(Line, _extends({
        y1: top2,
        y2: top2 + height2,
        className: classes.line
      }, lineSlotProps)), yTicks.map(({
        formattedValue,
        offset: offset2,
        labelOffset,
        value
      }, index) => {
        const xTickLabel = positionSign * (tickSize + 2);
        const yTickLabel = labelOffset;
        const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
        const showLabel = isPointInside({
          x: -1,
          y: offset2
        }, {
          direction: "y"
        });
        if (!showLabel) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", {
          transform: `translate(0, ${offset2})`,
          className: classes.tickContainer,
          children: [!disableTicks && /* @__PURE__ */ jsxRuntimeExports.jsx(Tick, _extends({
            x2: positionSign * tickSize,
            className: classes.tick
          }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(TickLabel, _extends({
            x: xTickLabel,
            y: yTickLabel,
            text: formattedValue.toString()
          }, axisTickLabelProps))]
        }, index);
      }), label && /* @__PURE__ */ jsxRuntimeExports.jsx("g", {
        className: classes.label,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Label, _extends({}, labelRefPoint, axisLabelProps, {
          text: label
        }))
      })]
    });
  }
  const getAxisId = (propsValue, defaultAxisId) => {
    if (propsValue == null) {
      return null;
    }
    if (typeof propsValue === "object") {
      return propsValue.axisId ?? defaultAxisId ?? null;
    }
    return propsValue;
  };
  const mergeProps = (axisConfig, slots, slotProps) => {
    return typeof axisConfig === "object" ? _extends({}, axisConfig, {
      slots: _extends({}, slots, axisConfig == null ? void 0 : axisConfig.slots),
      slotProps: _extends({}, slotProps, axisConfig == null ? void 0 : axisConfig.slotProps)
    }) : {
      slots,
      slotProps
    };
  };
  function ChartsAxis(props) {
    const {
      topAxis,
      leftAxis,
      rightAxis,
      bottomAxis,
      slots,
      slotProps
    } = props;
    const {
      xAxis,
      xAxisIds,
      yAxis,
      yAxisIds
    } = useCartesianContext();
    const leftId = getAxisId(leftAxis === void 0 ? yAxisIds[0] : leftAxis, yAxisIds[0]);
    const bottomId = getAxisId(bottomAxis === void 0 ? xAxisIds[0] : bottomAxis, xAxisIds[0]);
    const topId = getAxisId(topAxis, xAxisIds[0]);
    const rightId = getAxisId(rightAxis, yAxisIds[0]);
    if (topId !== null && !xAxis[topId]) {
      throw new Error([`MUI X: id used for top axis "${topId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
    }
    if (leftId !== null && !yAxis[leftId]) {
      throw new Error([`MUI X: id used for left axis "${leftId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
    }
    if (rightId !== null && !yAxis[rightId]) {
      throw new Error([`MUI X: id used for right axis "${rightId}" is not defined.`, `Available ids are: ${yAxisIds.join(", ")}.`].join("\n"));
    }
    if (bottomId !== null && !xAxis[bottomId]) {
      throw new Error([`MUI X: id used for bottom axis "${bottomId}" is not defined.`, `Available ids are: ${xAxisIds.join(", ")}.`].join("\n"));
    }
    const topAxisProps = mergeProps(topAxis, slots, slotProps);
    const bottomAxisProps = mergeProps(bottomAxis, slots, slotProps);
    const leftAxisProps = mergeProps(leftAxis, slots, slotProps);
    const rightAxisProps = mergeProps(rightAxis, slots, slotProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [topId && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsXAxis, _extends({}, topAxisProps, {
        position: "top",
        axisId: topId
      })), bottomId && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsXAxis, _extends({}, bottomAxisProps, {
        position: "bottom",
        axisId: bottomId
      })), leftId && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsYAxis, _extends({}, leftAxisProps, {
        position: "left",
        axisId: leftId
      })), rightId && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsYAxis, _extends({}, rightAxisProps, {
        position: "right",
        axisId: rightId
      }))]
    });
  }
  function getChartsGridUtilityClass(slot) {
    return generateUtilityClass("MuiChartsGrid", slot);
  }
  const chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);
  const GridRoot = styled("g", {
    name: "MuiChartsGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => [{
      [`&.${chartsGridClasses.verticalLine}`]: styles2.verticalLine
    }, {
      [`&.${chartsGridClasses.horizontalLine}`]: styles2.horizontalLine
    }, styles2.root]
  })({});
  const GridLine = styled("line", {
    name: "MuiChartsGrid",
    slot: "Line",
    overridesResolver: (props, styles2) => styles2.line
  })(({
    theme
  }) => ({
    stroke: (theme.vars || theme).palette.divider,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  }));
  function ChartsGridVertical(props) {
    const {
      axis,
      drawingArea,
      classes
    } = props;
    const {
      scale,
      tickNumber,
      tickInterval
    } = axis;
    const xTicks = useTicks({
      scale,
      tickNumber,
      tickInterval
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: xTicks.map(({
        formattedValue,
        offset: offset2
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridLine, {
        y1: drawingArea.top,
        y2: drawingArea.top + drawingArea.height,
        x1: offset2,
        x2: offset2,
        className: classes.verticalLine
      }, `vertical-${formattedValue}`))
    });
  }
  function ChartsGridHorizontal(props) {
    const {
      axis,
      drawingArea,
      classes
    } = props;
    const {
      scale,
      tickNumber,
      tickInterval
    } = axis;
    const yTicks = useTicks({
      scale,
      tickNumber,
      tickInterval
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: yTicks.map(({
        formattedValue,
        offset: offset2
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridLine, {
        y1: offset2,
        y2: offset2,
        x1: drawingArea.left,
        x2: drawingArea.left + drawingArea.width,
        className: classes.horizontalLine
      }, `horizontal-${formattedValue}`))
    });
  }
  const _excluded$l = ["vertical", "horizontal"];
  const useUtilityClasses$8 = ({
    classes
  }) => {
    const slots = {
      root: ["root"],
      verticalLine: ["line", "verticalLine"],
      horizontalLine: ["line", "horizontalLine"]
    };
    return composeClasses(slots, getChartsGridUtilityClass, classes);
  };
  function ChartsGrid(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiChartsGrid"
    });
    const drawingArea = useDrawingArea();
    const {
      vertical,
      horizontal
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
    const {
      xAxis,
      xAxisIds,
      yAxis,
      yAxisIds
    } = useCartesianContext();
    const classes = useUtilityClasses$8(props);
    const horizontalAxis = yAxis[yAxisIds[0]];
    const verticalAxis = xAxis[xAxisIds[0]];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRoot, _extends({}, other, {
      className: classes.root,
      children: [vertical && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsGridVertical, {
        axis: verticalAxis,
        drawingArea,
        classes
      }), horizontal && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsGridHorizontal, {
        axis: horizontalAxis,
        drawingArea,
        classes
      })]
    }));
  }
  const InteractionContext = /* @__PURE__ */ reactExports.createContext({
    item: null,
    axis: {
      x: null,
      y: null
    },
    useVoronoiInteraction: false,
    dispatch: () => null
  });
  const dataReducer = (prevState, action) => {
    switch (action.type) {
      case "enterItem":
        return _extends({}, prevState, {
          item: action.data
        });
      case "exitChart":
        if (prevState.item === null && prevState.axis.x === null && prevState.axis.y === null) {
          return prevState;
        }
        return _extends({}, prevState, {
          axis: {
            x: null,
            y: null
          },
          item: null
        });
      case "updateVoronoiUsage":
        return _extends({}, prevState, {
          useVoronoiInteraction: action.useVoronoiInteraction
        });
      case "leaveItem":
        if (prevState.item === null || Object.keys(action.data).some((key) => action.data[key] !== prevState.item[key])) {
          return prevState;
        }
        return _extends({}, prevState, {
          item: null
        });
      case "updateAxis":
        if (action.data.x === prevState.axis.x && action.data.y === prevState.axis.y) {
          return prevState;
        }
        return _extends({}, prevState, {
          axis: action.data
        });
      default:
        return prevState;
    }
  };
  function InteractionProvider(props) {
    const {
      children
    } = props;
    const [data, dispatch] = reactExports.useReducer(dataReducer, {
      item: null,
      axis: {
        x: null,
        y: null
      },
      useVoronoiInteraction: false
    });
    const value = reactExports.useMemo(() => _extends({}, data, {
      dispatch
    }), [data]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(InteractionContext.Provider, {
      value,
      children
    });
  }
  function generateVirtualElement(mousePosition) {
    if (mousePosition === null) {
      return {
        getBoundingClientRect: () => ({
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          toJSON: () => ""
        })
      };
    }
    const {
      x: x2,
      y: y2
    } = mousePosition;
    const boundingBox = {
      width: 0,
      height: 0,
      x: x2,
      y: y2,
      top: y2,
      right: x2,
      bottom: y2,
      left: x2
    };
    return {
      getBoundingClientRect: () => _extends({}, boundingBox, {
        toJSON: () => JSON.stringify(boundingBox)
      })
    };
  }
  function useMouseTracker() {
    const svgRef = useSvgRef();
    const [mousePosition, setMousePosition] = reactExports.useState(null);
    reactExports.useEffect(() => {
      const element = svgRef.current;
      if (element === null) {
        return () => {
        };
      }
      const handleOut = (event) => {
        if (event.pointerType !== "mouse") {
          setMousePosition(null);
        }
      };
      const handleMove = (event) => {
        setMousePosition({
          x: event.clientX,
          y: event.clientY,
          height: event.height,
          pointerType: event.pointerType
        });
      };
      element.addEventListener("pointerdown", handleMove);
      element.addEventListener("pointermove", handleMove);
      element.addEventListener("pointerup", handleOut);
      return () => {
        element.removeEventListener("pointerdown", handleMove);
        element.removeEventListener("pointermove", handleMove);
        element.removeEventListener("pointerup", handleOut);
      };
    }, [svgRef]);
    return mousePosition;
  }
  function getTooltipHasData(trigger, displayedData) {
    if (trigger === "item") {
      return displayedData !== null;
    }
    const hasAxisXData = displayedData.x !== null;
    const hasAxisYData = displayedData.y !== null;
    return hasAxisXData || hasAxisYData;
  }
  function utcFormatter(v2) {
    if (v2 instanceof Date) {
      return v2.toUTCString();
    }
    return v2.toLocaleString();
  }
  function getChartsTooltipUtilityClass(slot) {
    return generateUtilityClass("MuiChartsTooltip", slot);
  }
  const chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);
  const ChartsTooltipPaper = styled("div", {
    name: "MuiChartsTooltip",
    slot: "Container",
    overridesResolver: (props, styles2) => styles2.paper
  })(({
    theme
  }) => ({
    boxShadow: theme.shadows[1],
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow"),
    borderRadius: theme.shape.borderRadius
  }));
  const ChartsTooltipTable = styled("table", {
    name: "MuiChartsTooltip",
    slot: "Table",
    overridesResolver: (props, styles2) => styles2.table
  })(({
    theme
  }) => ({
    borderSpacing: 0,
    "& thead td": {
      borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
    }
  }));
  const ChartsTooltipRow = styled("tr", {
    name: "MuiChartsTooltip",
    slot: "Row",
    overridesResolver: (props, styles2) => styles2.row
  })(({
    theme
  }) => ({
    "tr:first-of-type& td": {
      paddingTop: theme.spacing(1)
    },
    "tr:last-of-type& td": {
      paddingBottom: theme.spacing(1)
    }
  }));
  const ChartsTooltipCell = styled("td", {
    name: "MuiChartsTooltip",
    slot: "Cell",
    overridesResolver: (props, styles2) => styles2.cell
  })(({
    theme
  }) => ({
    verticalAlign: "middle",
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${chartsTooltipClasses.labelCell}`]: {
      paddingLeft: theme.spacing(1)
    },
    [`&.${chartsTooltipClasses.valueCell}`]: {
      paddingLeft: theme.spacing(4),
      color: (theme.vars || theme).palette.text.primary
    },
    "td:first-of-type&": {
      paddingLeft: theme.spacing(2)
    },
    "td:last-of-type&": {
      paddingRight: theme.spacing(2)
    }
  }));
  const ChartsTooltipMark = styled("div", {
    name: "MuiChartsTooltip",
    slot: "Mark",
    overridesResolver: (props, styles2) => styles2.mark,
    shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
  })(({
    theme,
    color: color2
  }) => ({
    width: theme.spacing(1),
    height: theme.spacing(1),
    borderRadius: "50%",
    boxShadow: theme.shadows[1],
    backgroundColor: color2,
    borderColor: (theme.vars || theme).palette.background.paper,
    border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
    boxSizing: "content-box"
  }));
  function DefaultChartsItemTooltipContent(props) {
    var _a;
    const {
      series,
      itemData,
      sx,
      classes,
      getColor: getColor2
    } = props;
    if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
      return null;
    }
    const {
      displayedLabel,
      color: color2
    } = series.type === "pie" ? {
      color: getColor2(itemData.dataIndex),
      displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
    } : {
      color: getColor2(itemData.dataIndex),
      displayedLabel: getLabel(series.label, "tooltip")
    };
    const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
      label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
    }) : series.data[itemData.dataIndex];
    const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
      dataIndex: itemData.dataIndex
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipTable, {
        className: classes.table,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", {
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ChartsTooltipRow, {
            className: classes.row,
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
              className: clsx(classes.markCell, classes.cell),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipMark, {
                color: color2,
                className: classes.mark
              })
            }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
              className: clsx(classes.labelCell, classes.cell),
              children: displayedLabel
            }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
              className: clsx(classes.valueCell, classes.cell),
              children: formattedValue
            })]
          })
        })
      })
    });
  }
  function ChartsItemTooltipContent(props) {
    var _a;
    const {
      content,
      itemData,
      sx,
      classes,
      contentProps
    } = props;
    const series = useSeries()[itemData.type].series[itemData.seriesId];
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = useCartesianContext();
    const {
      zAxis,
      zAxisIds
    } = reactExports.useContext(ZAxisContext);
    const colorProcessors = useColorProcessor();
    const xAxisId = series.xAxisId ?? series.xAxisKey ?? xAxisIds[0];
    const yAxisId = series.yAxisId ?? series.yAxisKey ?? yAxisIds[0];
    const zAxisId = series.zAxisId ?? series.zAxisKey ?? zAxisIds[0];
    const getColor2 = ((_a = colorProcessors[series.type]) == null ? void 0 : _a.call(colorProcessors, series, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
    const Content = content ?? DefaultChartsItemTooltipContent;
    const chartTooltipContentProps = useSlotProps({
      elementType: Content,
      externalSlotProps: contentProps,
      additionalProps: {
        itemData,
        series,
        sx,
        classes,
        getColor: getColor2
      },
      ownerState: {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Content, _extends({}, chartTooltipContentProps));
  }
  let instance;
  class CartesianSeriesTypes {
    constructor() {
      this.types = /* @__PURE__ */ new Set();
      if (instance) {
        throw new Error("You can only create one instance!");
      }
      instance = this.types;
    }
    addType(value) {
      this.types.add(value);
    }
    getTypes() {
      return this.types;
    }
  }
  const cartesianSeriesTypes = new CartesianSeriesTypes();
  cartesianSeriesTypes.addType("bar");
  cartesianSeriesTypes.addType("line");
  cartesianSeriesTypes.addType("scatter");
  function isCartesianSeriesType(seriesType) {
    return cartesianSeriesTypes.getTypes().has(seriesType);
  }
  function isCartesianSeries(series) {
    return isCartesianSeriesType(series.type);
  }
  function DefaultChartsAxisTooltipContent(props) {
    const {
      series,
      axis,
      dataIndex,
      axisValue,
      sx,
      classes
    } = props;
    if (dataIndex == null) {
      return null;
    }
    const axisFormatter = axis.valueFormatter ?? ((v2) => axis.scaleType === "utc" ? utcFormatter(v2) : v2.toLocaleString());
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ChartsTooltipTable, {
        className: classes.table,
        children: [axisValue != null && !axis.hideTooltip && /* @__PURE__ */ jsxRuntimeExports.jsx("thead", {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipRow, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
              colSpan: 3,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
                children: axisFormatter(axisValue, {
                  location: "tooltip"
                })
              })
            })
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", {
          children: series.filter(isCartesianSeries).map(({
            id: id2,
            label,
            valueFormatter,
            data,
            getColor: getColor2
          }) => {
            const formattedValue = valueFormatter(data[dataIndex] ?? null, {
              dataIndex
            });
            if (formattedValue == null) {
              return null;
            }
            const formattedLabel = getLabel(label, "tooltip");
            const color2 = getColor2(dataIndex);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChartsTooltipRow, {
              className: classes.row,
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
                className: clsx(classes.markCell, classes.cell),
                children: color2 && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipMark, {
                  color: color2,
                  className: classes.mark
                })
              }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
                className: clsx(classes.labelCell, classes.cell),
                children: formattedLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
                  children: formattedLabel
                }) : null
              }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltipCell, {
                className: clsx(classes.valueCell, classes.cell),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
                  children: formattedValue
                })
              })]
            }, id2);
          })
        })]
      })
    });
  }
  function ChartsAxisTooltipContent(props) {
    const {
      content,
      contentProps,
      axisData,
      sx,
      classes
    } = props;
    const isXaxis = axisData.x && axisData.x.index !== -1;
    const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
    const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const {
      zAxisIds,
      zAxis
    } = reactExports.useContext(ZAxisContext);
    const series = useSeries();
    const colorProcessors = useColorProcessor();
    const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
    const relevantSeries = reactExports.useMemo(() => {
      const rep = [];
      Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
        series[seriesType].seriesOrder.forEach((seriesId) => {
          var _a;
          const item = series[seriesType].series[seriesId];
          const providedXAxisId = item.xAxisId ?? item.xAxisKey;
          const providedYAxisId = item.yAxisId ?? item.yAxisKey;
          const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            const seriesToAdd = series[seriesType].series[seriesId];
            const xAxisId = providedXAxisId ?? xAxisIds[0];
            const yAxisId = providedYAxisId ?? yAxisIds[0];
            const zAxisId = seriesToAdd.zAxisId ?? seriesToAdd.zAxisKey ?? zAxisIds[0];
            const getColor2 = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])) ?? (() => "");
            rep.push(_extends({}, seriesToAdd, {
              getColor: getColor2
            }));
          }
        });
      });
      return rep;
    }, [USED_AXIS_ID, colorProcessors, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
    const relevantAxis = reactExports.useMemo(() => {
      return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
    }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
    const Content = content ?? DefaultChartsAxisTooltipContent;
    const chartTooltipContentProps = useSlotProps({
      elementType: Content,
      externalSlotProps: contentProps,
      additionalProps: {
        axisData,
        series: relevantSeries,
        axis: relevantAxis,
        dataIndex,
        axisValue,
        sx,
        classes
      },
      ownerState: {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Content, _extends({}, chartTooltipContentProps));
  }
  const useUtilityClasses$7 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"],
      table: ["table"],
      row: ["row"],
      cell: ["cell"],
      mark: ["mark"],
      markCell: ["markCell"],
      labelCell: ["labelCell"],
      valueCell: ["valueCell"]
    };
    return composeClasses(slots, getChartsTooltipUtilityClass, classes);
  };
  const ChartsTooltipRoot = styled(Popper, {
    name: "MuiChartsTooltip",
    slot: "Root",
    overridesResolver: (_, styles2) => styles2.root
  })(({
    theme
  }) => ({
    pointerEvents: "none",
    zIndex: theme.zIndex.modal
  }));
  function ChartsTooltip(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiChartsTooltip"
    });
    const {
      trigger = "axis",
      itemContent,
      axisContent,
      slots,
      slotProps
    } = props;
    const mousePosition = useMouseTracker();
    const {
      item,
      axis
    } = reactExports.useContext(InteractionContext);
    const displayedData = trigger === "item" ? item : axis;
    const tooltipHasData = getTooltipHasData(trigger, displayedData);
    const popperOpen = mousePosition !== null && tooltipHasData;
    const classes = useUtilityClasses$7({
      classes: props.classes
    });
    const PopperComponent = (slots == null ? void 0 : slots.popper) ?? ChartsTooltipRoot;
    const popperProps = useSlotProps({
      elementType: PopperComponent,
      externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
      additionalProps: {
        open: popperOpen,
        placement: (mousePosition == null ? void 0 : mousePosition.pointerType) === "mouse" ? "right-start" : "top",
        anchorEl: generateVirtualElement(mousePosition),
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, (mousePosition == null ? void 0 : mousePosition.pointerType) === "touch" ? 40 - mousePosition.height : 0]
          }
        }]
      },
      ownerState: {}
    });
    if (trigger === "none") {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NoSsr, {
      children: popperOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, _extends({}, popperProps, {
        className: classes.root,
        children: trigger === "item" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsItemTooltipContent, {
          itemData: displayedData,
          content: (slots == null ? void 0 : slots.itemContent) ?? itemContent,
          contentProps: slotProps == null ? void 0 : slotProps.itemContent,
          sx: {
            mx: 2
          },
          classes
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisTooltipContent, {
          axisData: displayedData,
          content: (slots == null ? void 0 : slots.axisContent) ?? axisContent,
          contentProps: slotProps == null ? void 0 : slotProps.axisContent,
          sx: {
            mx: 2
          },
          classes
        })
      }))
    });
  }
  const legendGetter$4 = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    return seriesOrder.reduce((acc, seriesId) => {
      const formattedLabel = getLabel(series[seriesId].label, "legend");
      if (formattedLabel === void 0) {
        return acc;
      }
      acc.push({
        id: seriesId,
        seriesId,
        color: series[seriesId].color,
        label: formattedLabel
      });
      return acc;
    }, []);
  };
  const legendGetter$3 = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    return seriesOrder.reduce((acc, seriesId) => {
      const formattedLabel = getLabel(series[seriesId].label, "legend");
      if (formattedLabel === void 0) {
        return acc;
      }
      acc.push({
        id: seriesId,
        seriesId,
        color: series[seriesId].color,
        label: formattedLabel
      });
      return acc;
    }, []);
  };
  const legendGetter$2 = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    return seriesOrder.reduce((acc, seriesId) => {
      const formattedLabel = getLabel(series[seriesId].label, "legend");
      if (formattedLabel === void 0) {
        return acc;
      }
      acc.push({
        id: seriesId,
        seriesId,
        color: series[seriesId].color,
        label: formattedLabel
      });
      return acc;
    }, []);
  };
  const legendGetter$1 = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    return seriesOrder.reduce((acc, seriesId) => {
      series[seriesId].data.forEach((item) => {
        const formattedLabel = getLabel(item.label, "legend");
        if (formattedLabel === void 0) {
          return;
        }
        acc.push({
          id: item.id,
          seriesId,
          color: item.color,
          label: formattedLabel,
          itemId: item.id
        });
      });
      return acc;
    }, []);
  };
  const legendGetter = {
    bar: legendGetter$4,
    scatter: legendGetter$3,
    line: legendGetter$2,
    pie: legendGetter$1
  };
  function getSeriesToDisplay(series) {
    return Object.keys(series).flatMap((seriesType) => {
      const getter = legendGetter[seriesType];
      return getter === void 0 ? [] : getter(series[seriesType]);
    });
  }
  function getLegendUtilityClass(slot) {
    return generateUtilityClass("MuiChartsLegend", slot);
  }
  generateUtilityClasses("MuiChartsLegend", ["root", "series", "itemBackground", "mark", "label", "column", "row"]);
  const _excluded$k = ["label"];
  function legendItemPlacements(itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap) {
    let x2 = 0;
    let y2 = 0;
    let totalWidthUsed = 0;
    let totalHeightUsed = 0;
    let rowIndex = 0;
    const rowMaxHeight = [0];
    const seriesWithRawPosition = itemsToDisplay.map((_ref) => {
      let {
        label
      } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$k);
      const itemSpace = getItemSpace(label, labelStyle);
      const rep = _extends({}, other, {
        label,
        positionX: x2,
        positionY: y2,
        innerHeight: itemSpace.innerHeight,
        innerWidth: itemSpace.innerWidth,
        outerHeight: itemSpace.outerHeight,
        outerWidth: itemSpace.outerWidth,
        rowIndex
      });
      if (direction === "row") {
        if (x2 + itemSpace.innerWidth > availableWidth) {
          x2 = 0;
          y2 += rowMaxHeight[rowIndex];
          rowIndex += 1;
          if (rowMaxHeight.length <= rowIndex) {
            rowMaxHeight.push(0);
          }
          rep.positionX = x2;
          rep.positionY = y2;
          rep.rowIndex = rowIndex;
        }
        totalWidthUsed = Math.max(totalWidthUsed, x2 + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y2 + itemSpace.outerHeight);
        rowMaxHeight[rowIndex] = Math.max(rowMaxHeight[rowIndex], itemSpace.outerHeight);
        x2 += itemSpace.outerWidth;
      }
      if (direction === "column") {
        if (y2 + itemSpace.innerHeight > availableHeight) {
          x2 = totalWidthUsed + itemGap;
          y2 = 0;
          rowIndex = 0;
          rep.positionX = x2;
          rep.positionY = y2;
          rep.rowIndex = rowIndex;
        }
        if (rowMaxHeight.length <= rowIndex) {
          rowMaxHeight.push(0);
        }
        totalWidthUsed = Math.max(totalWidthUsed, x2 + itemSpace.outerWidth);
        totalHeightUsed = Math.max(totalHeightUsed, y2 + itemSpace.outerHeight);
        rowIndex += 1;
        y2 += itemSpace.outerHeight;
      }
      return rep;
    });
    return [seriesWithRawPosition.map((item) => _extends({}, item, {
      positionY: item.positionY + (direction === "row" ? rowMaxHeight[item.rowIndex] / 2 : item.outerHeight / 2)
      // Get the center of the item
    })), totalWidthUsed, totalHeightUsed];
  }
  function ChartsLegendItem(props) {
    const isRTL = useRtl();
    const {
      id: id2,
      positionY,
      label,
      positionX,
      innerHeight,
      innerWidth,
      legendWidth,
      color: color2,
      gapX,
      gapY,
      itemMarkHeight,
      itemMarkWidth,
      markGap,
      labelStyle,
      classes,
      onClick
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", {
      className: clsx(classes == null ? void 0 : classes.series, `${classes == null ? void 0 : classes.series}-${id2}`),
      transform: `translate(${gapX + (isRTL ? legendWidth - positionX : positionX)} ${gapY + positionY})`,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
        x: isRTL ? -(innerWidth + 2) : -2,
        y: -itemMarkHeight / 2 - 2,
        width: innerWidth + 4,
        height: innerHeight + 4,
        fill: "transparent",
        className: classes == null ? void 0 : classes.itemBackground,
        onClick,
        style: {
          pointerEvents: onClick ? "all" : "none",
          cursor: onClick ? "pointer" : "unset"
        }
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
        className: classes == null ? void 0 : classes.mark,
        x: isRTL ? -itemMarkWidth : 0,
        y: -itemMarkHeight / 2,
        width: itemMarkWidth,
        height: itemMarkHeight,
        fill: color2,
        style: {
          pointerEvents: "none"
        }
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsText, {
        style: _extends({
          pointerEvents: "none"
        }, labelStyle),
        text: label,
        x: (isRTL ? -1 : 1) * (itemMarkWidth + markGap),
        y: 0
      })]
    });
  }
  const _excluded$j = ["rotate", "dominantBaseline"];
  const ChartsLegendRoot = styled("g", {
    name: "MuiChartsLegend",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  const getStandardizedPadding = (padding2) => {
    if (typeof padding2 === "number") {
      return {
        left: padding2,
        right: padding2,
        top: padding2,
        bottom: padding2
      };
    }
    return _extends({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, padding2);
  };
  function LegendPerItem(props) {
    const {
      position: position2,
      direction,
      itemsToDisplay,
      classes,
      itemMarkWidth = 20,
      itemMarkHeight = 20,
      markGap = 5,
      itemGap = 10,
      padding: paddingProps = 10,
      labelStyle: inLabelStyle,
      onItemClick
    } = props;
    const theme = useTheme();
    const drawingArea = useDrawingArea();
    const labelStyle = reactExports.useMemo(
      () => _extends({}, theme.typography.subtitle1, {
        color: "inherit",
        dominantBaseline: "central",
        textAnchor: "start",
        fill: (theme.vars || theme).palette.text.primary,
        lineHeight: 1
      }, inLabelStyle),
      // To say to TS that the dominantBaseline and textAnchor are correct
      [inLabelStyle, theme]
    );
    const padding2 = reactExports.useMemo(() => getStandardizedPadding(paddingProps), [paddingProps]);
    const getItemSpace = reactExports.useCallback((label, inStyle = {}) => {
      const style2 = _objectWithoutPropertiesLoose(inStyle, _excluded$j);
      const linesSize = getWordsByLines({
        style: style2,
        needsComputation: true,
        text: label
      });
      const innerSize = {
        innerWidth: itemMarkWidth + markGap + Math.max(...linesSize.map((size) => size.width)),
        innerHeight: Math.max(itemMarkHeight, linesSize.length * linesSize[0].height)
      };
      return _extends({}, innerSize, {
        outerWidth: innerSize.innerWidth + itemGap,
        outerHeight: innerSize.innerHeight + itemGap
      });
    }, [itemGap, itemMarkHeight, itemMarkWidth, markGap]);
    const totalWidth = drawingArea.left + drawingArea.width + drawingArea.right;
    const totalHeight = drawingArea.top + drawingArea.height + drawingArea.bottom;
    const availableWidth = totalWidth - padding2.left - padding2.right;
    const availableHeight = totalHeight - padding2.top - padding2.bottom;
    const [itemsWithPosition, legendWidth, legendHeight] = reactExports.useMemo(() => legendItemPlacements(itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap), [itemsToDisplay, getItemSpace, labelStyle, direction, availableWidth, availableHeight, itemGap]);
    const gapX = reactExports.useMemo(() => {
      switch (position2.horizontal) {
        case "left":
          return padding2.left;
        case "right":
          return totalWidth - padding2.right - legendWidth;
        default:
          return (totalWidth - legendWidth) / 2;
      }
    }, [position2.horizontal, padding2.left, padding2.right, totalWidth, legendWidth]);
    const gapY = reactExports.useMemo(() => {
      switch (position2.vertical) {
        case "top":
          return padding2.top;
        case "bottom":
          return totalHeight - padding2.bottom - legendHeight;
        default:
          return (totalHeight - legendHeight) / 2;
      }
    }, [position2.vertical, padding2.top, padding2.bottom, totalHeight, legendHeight]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NoSsr, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsLegendRoot, {
        className: classes == null ? void 0 : classes.root,
        children: itemsWithPosition.map((item, i) => /* @__PURE__ */ reactExports.createElement(ChartsLegendItem, _extends({}, item, {
          key: item.id,
          gapX,
          gapY,
          legendWidth,
          itemMarkHeight,
          itemMarkWidth,
          markGap,
          labelStyle,
          classes,
          onClick: onItemClick ? (event) => onItemClick(event, i) : void 0
        })))
      })
    });
  }
  const _excluded$i = ["drawingArea", "seriesToDisplay", "hidden", "onItemClick"];
  const seriesContextBuilder = (context) => ({
    type: "series",
    color: context.color,
    label: context.label,
    seriesId: context.seriesId,
    itemId: context.itemId
  });
  function DefaultChartsLegend(props) {
    const {
      seriesToDisplay,
      hidden,
      onItemClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
    if (hidden) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LegendPerItem, _extends({}, other, {
      itemsToDisplay: seriesToDisplay,
      onItemClick: onItemClick ? (event, i) => onItemClick(event, seriesContextBuilder(seriesToDisplay[i]), i) : void 0
    }));
  }
  const _excluded$h = ["slots", "slotProps"];
  const useUtilityClasses$6 = (ownerState) => {
    const {
      classes,
      direction
    } = ownerState;
    const slots = {
      root: ["root", direction],
      mark: ["mark"],
      label: ["label"],
      series: ["series"],
      itemBackground: ["itemBackground"]
    };
    return composeClasses(slots, getLegendUtilityClass, classes);
  };
  function ChartsLegend(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiChartsLegend"
    });
    const defaultizedProps = _extends({
      direction: "row"
    }, props, {
      position: _extends({
        horizontal: "middle",
        vertical: "top"
      }, props.position)
    });
    const {
      slots,
      slotProps
    } = defaultizedProps, other = _objectWithoutPropertiesLoose(defaultizedProps, _excluded$h);
    const theme = useTheme();
    const classes = useUtilityClasses$6(_extends({}, defaultizedProps, {
      theme
    }));
    const drawingArea = useDrawingArea();
    const series = useSeries();
    const seriesToDisplay = getSeriesToDisplay(series);
    const ChartLegendRender = (slots == null ? void 0 : slots.legend) ?? DefaultChartsLegend;
    const chartLegendRenderProps = useSlotProps({
      elementType: ChartLegendRender,
      externalSlotProps: slotProps == null ? void 0 : slotProps.legend,
      additionalProps: _extends({}, other, {
        classes,
        drawingArea,
        series,
        seriesToDisplay
      }),
      ownerState: {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartLegendRender, _extends({}, chartLegendRenderProps));
  }
  const PX_PRECISION = 10;
  function ChartsContinuousGradient(props) {
    const {
      gradientUnits,
      isReversed,
      gradientId,
      size,
      direction,
      scale,
      colorScale,
      colorMap
    } = props;
    const extremValues = [colorMap.min ?? 0, colorMap.max ?? 100];
    const extremPositions = extremValues.map(scale).filter((p2) => p2 !== void 0);
    if (extremPositions.length !== 2) {
      return null;
    }
    const interpolator = typeof extremValues[0] === "number" ? interpolateNumber(extremValues[0], extremValues[1]) : interpolateDate(extremValues[0], extremValues[1]);
    const numberOfPoints = Math.round((Math.max(...extremPositions) - Math.min(...extremPositions)) / PX_PRECISION);
    const keyPrefix = `${extremValues[0]}-${extremValues[1]}-`;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("linearGradient", {
      id: gradientId,
      x1: "0",
      x2: "0",
      y1: "0",
      y2: "0",
      [`${direction}${isReversed ? 1 : 2}`]: gradientUnits === "objectBoundingBox" ? 1 : `${size}px`,
      gradientUnits: gradientUnits ?? "userSpaceOnUse",
      children: Array.from({
        length: numberOfPoints + 1
      }, (_, index) => {
        const value = interpolator(index / numberOfPoints);
        if (value === void 0) {
          return null;
        }
        const x2 = scale(value);
        if (x2 === void 0) {
          return null;
        }
        const offset2 = isReversed ? 1 - x2 / size : x2 / size;
        const color2 = colorScale(value);
        if (color2 === null) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx("stop", {
          offset: offset2,
          stopColor: color2,
          stopOpacity: 1
        }, keyPrefix + index);
      })
    });
  }
  function getPercentageValue(value, refValue) {
    if (typeof value === "number") {
      return value;
    }
    if (value === "100%") {
      return refValue;
    }
    if (value.endsWith("%")) {
      const percentage = Number.parseFloat(value.slice(0, value.length - 1));
      if (!Number.isNaN(percentage)) {
        return percentage * refValue / 100;
      }
    }
    if (value.endsWith("px")) {
      const val = Number.parseFloat(value.slice(0, value.length - 2));
      if (!Number.isNaN(val)) {
        return val;
      }
    }
    throw new Error(`MUI X: Received an unknown value "${value}". It should be a number, or a string with a percentage value.`);
  }
  function getAxisHighlightUtilityClass(slot) {
    return generateUtilityClass("MuiChartsAxisHighlight", slot);
  }
  generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);
  const useUtilityClasses$5 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getAxisHighlightUtilityClass);
  };
  const ChartsAxisHighlightPath = styled("path", {
    name: "MuiChartsAxisHighlight",
    slot: "Root",
    overridesResolver: (_, styles2) => styles2.root
  })(({
    theme
  }) => ({
    pointerEvents: "none",
    variants: [{
      props: {
        axisHighlight: "band"
      },
      style: _extends({
        fill: "white",
        fillOpacity: 0.1
      }, theme.applyStyles("light", {
        fill: "gray"
      }))
    }, {
      props: {
        axisHighlight: "line"
      },
      style: _extends({
        strokeDasharray: "5 2",
        stroke: "#ffffff"
      }, theme.applyStyles("light", {
        stroke: "#000000"
      }))
    }]
  }));
  function ChartsAxisHighlight(props) {
    const {
      x: xAxisHighlight,
      y: yAxisHighlight
    } = props;
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const classes = useUtilityClasses$5();
    const USED_X_AXIS_ID = xAxisIds[0];
    const USED_Y_AXIS_ID = yAxisIds[0];
    const xScale = xAxis[USED_X_AXIS_ID].scale;
    const yScale = yAxis[USED_Y_AXIS_ID].scale;
    const {
      axis
    } = reactExports.useContext(InteractionContext);
    const getXPosition = getValueToPositionMapper(xScale);
    const getYPosition = getValueToPositionMapper(yScale);
    const axisX = axis.x;
    const axisY = axis.y;
    const isBandScaleX = xAxisHighlight === "band" && axisX !== null && isBandScale(xScale);
    const isBandScaleY = yAxisHighlight === "band" && axisY !== null && isBandScale(yScale);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [isBandScaleX && xScale(axisX.value) !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChartsAxisHighlightPath,
        {
          d: `M ${xScale(axisX.value) - (xScale.step() - xScale.bandwidth()) / 2} ${yScale.range()[0]} l ${xScale.step()} 0 l 0 ${yScale.range()[1] - yScale.range()[0]} l ${-xScale.step()} 0 Z`,
          className: classes.root,
          ownerState: {
            axisHighlight: "band"
          }
        }
      ), isBandScaleY && yScale(axisY.value) !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisHighlightPath, {
        d: `M ${xScale.range()[0]} ${// @ts-expect-error, yScale value is checked in the statement above
        yScale(axisY.value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${xScale.range()[1] - xScale.range()[0]} 0 l 0 ${-yScale.step()} Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }), xAxisHighlight === "line" && axis.x !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisHighlightPath, {
        d: `M ${getXPosition(axis.x.value)} ${yScale.range()[0]} L ${getXPosition(axis.x.value)} ${yScale.range()[1]}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      }), yAxisHighlight === "line" && axis.y !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisHighlightPath, {
        d: `M ${xScale.range()[0]} ${getYPosition(axis.y.value)} L ${xScale.range()[1]} ${getYPosition(axis.y.value)}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      })]
    });
  }
  function getSVGPoint(svg, event) {
    const pt = svg.createSVGPoint();
    pt.x = event.clientX;
    pt.y = event.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }
  function ChartsOnAxisClickHandler(props) {
    const {
      onAxisClick
    } = props;
    const svgRef = useSvgRef();
    const series = useSeries();
    const {
      axis
    } = reactExports.useContext(InteractionContext);
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    reactExports.useEffect(() => {
      const element = svgRef.current;
      if (element === null || !onAxisClick) {
        return () => {
        };
      }
      const handleMouseClick = (event) => {
        var _a;
        event.preventDefault();
        const isXaxis = axis.x && axis.x.index !== -1;
        const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
        const dataIndex = isXaxis ? axis.x && axis.x.index : axis.y && axis.y.index;
        if (dataIndex == null) {
          return;
        }
        const seriesValues = {};
        Object.keys(series).filter((seriesType) => ["bar", "line"].includes(seriesType)).forEach((seriesType) => {
          var _a2;
          (_a2 = series[seriesType]) == null ? void 0 : _a2.seriesOrder.forEach((seriesId) => {
            const seriesItem = series[seriesType].series[seriesId];
            const providedXAxisId = seriesItem.xAxisId ?? seriesItem.xAxisKey;
            const providedYAxisId = seriesItem.yAxisId ?? seriesItem.yAxisKey;
            const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
            if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
              seriesValues[seriesId] = seriesItem.data[dataIndex];
            }
          });
        });
        const axisValue = (_a = (isXaxis ? xAxis : yAxis)[USED_AXIS_ID].data) == null ? void 0 : _a[dataIndex];
        onAxisClick(event, {
          dataIndex,
          axisValue,
          seriesValues
        });
      };
      element.addEventListener("click", handleMouseClick);
      return () => {
        element.removeEventListener("click", handleMouseClick);
      };
    }, [axis.x, axis.y, onAxisClick, series, svgRef, xAxis, xAxisIds, yAxis, yAxisIds]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {});
  }
  var updateQueue = makeQueue();
  var raf = (fn) => schedule(fn, updateQueue);
  var writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  var onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  var onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  var onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  var timeouts = [];
  raf.setTimeout = (handler, ms) => {
    const time2 = raf.now() + ms;
    const cancel = () => {
      const i = timeouts.findIndex((t2) => t2.cancel == cancel);
      if (~i)
        timeouts.splice(i, 1);
      pendingCount -= ~i ? 1 : 0;
    };
    const timeout = { time: time2, handler, cancel };
    timeouts.splice(findTimeout(time2), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  var findTimeout = (time2) => ~(~timeouts.findIndex((t2) => t2.time > time2) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    () => {
    }
  );
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn(
        "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
      );
    } else {
      update();
    }
  };
  var ts = -1;
  var pendingCount = 0;
  var sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    const prevTs = ts;
    ts = raf.now();
    const count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t2) => t2.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next2 = /* @__PURE__ */ new Set();
    let current2 = next2;
    return {
      add(fn) {
        pendingCount += current2 == next2 && !next2.has(fn) ? 1 : 0;
        next2.add(fn);
      },
      delete(fn) {
        pendingCount -= current2 == next2 && next2.has(fn) ? 1 : 0;
        return next2.delete(fn);
      },
      flush(arg2) {
        if (current2.size) {
          next2 = /* @__PURE__ */ new Set();
          pendingCount -= current2.size;
          eachSafely(current2, (fn) => fn(arg2) && next2.add(fn));
          pendingCount += next2.size;
          current2 = next2;
        }
      }
    };
  }
  function eachSafely(values2, each2) {
    values2.forEach((value) => {
      try {
        each2(value);
      } catch (e3) {
        raf.catch(e3);
      }
    });
  }
  var __defProp2 = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var globals_exports = {};
  __export(globals_exports, {
    assign: () => assign,
    colors: () => colors,
    createStringInterpolator: () => createStringInterpolator,
    skipAnimation: () => skipAnimation,
    to: () => to$1,
    willAdvance: () => willAdvance
  });
  function noop$1() {
  }
  var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
  var is$1 = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b2) {
    if (is$1.arr(a)) {
      if (!is$1.arr(b2) || a.length !== b2.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b2[i])
          return false;
      }
      return true;
    }
    return a === b2;
  }
  var each$1 = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is$1.arr(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn.call(ctx2, obj[i], `${i}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  var toArray = (a) => is$1.und(a) ? [] : is$1.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each$1(items, iterator);
    }
  }
  var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  var createStringInterpolator;
  var to$1;
  var colors = null;
  var skipAnimation = false;
  var willAdvance = noop$1;
  var assign = (globals) => {
    if (globals.to)
      to$1 = globals.to;
    if (globals.now)
      raf.now = globals.now;
    if (globals.colors !== void 0)
      colors = globals.colors;
    if (globals.skipAnimation != null)
      skipAnimation = globals.skipAnimation;
    if (globals.createStringInterpolator)
      createStringInterpolator = globals.createStringInterpolator;
    if (globals.requestAnimationFrame)
      raf.use(globals.requestAnimationFrame);
    if (globals.batchedUpdates)
      raf.batchedUpdates = globals.batchedUpdates;
    if (globals.willAdvance)
      willAdvance = globals.willAdvance;
    if (globals.frameLoop)
      raf.frameLoop = globals.frameLoop;
  };
  var startQueue = /* @__PURE__ */ new Set();
  var currentFrame = [];
  var prevFrame = [];
  var priority = 0;
  var frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    /** Advance the given animation on every frame until idle. */
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    /** Advance all animations by the given time. */
    advance,
    /** Call this when an animation's priority changes. */
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    /**
     * Clear all animations. For testing purposes.
     *
     * ☠️ Never call this from within the frameloop.
     */
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation))
      startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(
      findIndex(currentFrame, (other) => other.priority > animation.priority),
      0,
      animation
    );
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i = 0; i < currentFrame.length; i++) {
      const animation = currentFrame[i];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index = arr.findIndex(test);
    return index < 0 ? arr.length : index;
  }
  var clamp = (min2, max2, v2) => Math.min(Math.max(v2, min2), max2);
  var colors2 = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  var NUMBER = "[-+]?\\d*\\.?\\d+";
  var PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  var hsla = new RegExp(
    "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
  );
  var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex6 = /^#([0-9a-fA-F]{6})$/;
  var hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color2) {
    let match2;
    if (typeof color2 === "number") {
      return color2 >>> 0 === color2 && color2 >= 0 && color2 <= 4294967295 ? color2 : null;
    }
    if (match2 = hex6.exec(color2))
      return parseInt(match2[1] + "ff", 16) >>> 0;
    if (colors && colors[color2] !== void 0) {
      return colors[color2];
    }
    if (match2 = rgb.exec(color2)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match2 = rgba.exec(color2)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      parse1(match2[4])) >>> // a
      0;
    }
    if (match2 = hex3.exec(color2)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match2 = hex8.exec(color2))
      return parseInt(match2[1], 16) >>> 0;
    if (match2 = hex4.exec(color2)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        match2[4] + match2[4],
        // a
        16
      ) >>> 0;
    }
    if (match2 = hsl.exec(color2)) {
      return (hslToRgb(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match2 = hsla.exec(color2)) {
      return (hslToRgb(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | parse1(match2[4])) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  function hslToRgb(h2, s, l2) {
    const q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    const p2 = 2 * l2 - q2;
    const r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    const g2 = hue2rgb(p2, q2, h2);
    const b2 = hue2rgb(p2, q2, h2 - 1 / 3);
    return Math.round(r2 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0)
      return 0;
    if (int > 255)
      return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0)
      return 0;
    if (num > 1)
      return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0)
      return 0;
    if (int > 100)
      return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null)
      return input;
    int32Color = int32Color || 0;
    const r2 = (int32Color & 4278190080) >>> 24;
    const g2 = (int32Color & 16711680) >>> 16;
    const b2 = (int32Color & 65280) >>> 8;
    const a = (int32Color & 255) / 255;
    return `rgba(${r2}, ${g2}, ${b2}, ${a})`;
  }
  var createInterpolator = (range2, output, extrapolate) => {
    if (is$1.fun(range2)) {
      return range2;
    }
    if (is$1.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is$1.str(range2.output[0])) {
      return createStringInterpolator(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing2 = config2.easing || ((t2) => t2);
    return (input) => {
      const range22 = findRange(input, inputRange);
      return interpolate(
        input,
        inputRange[range22],
        inputRange[range22 + 1],
        outputRange[range22],
        outputRange[range22 + 1],
        easing2,
        extrapolateLeft,
        extrapolateRight,
        config2.map
      );
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing2, extrapolateLeft, extrapolateRight, map2) {
    let result = map2 ? map2(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity")
        return result;
      else if (extrapolateLeft === "clamp")
        result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity")
        return result;
      else if (extrapolateRight === "clamp")
        result = inputMax;
    }
    if (outputMin === outputMax)
      return outputMin;
    if (inputMin === inputMax)
      return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity)
      result = -result;
    else if (inputMax === Infinity)
      result = result - inputMin;
    else
      result = (result - inputMin) / (inputMax - inputMin);
    result = easing2(result);
    if (outputMin === -Infinity)
      result = -result;
    else if (outputMax === Infinity)
      result = result + outputMin;
    else
      result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i = 1; i < inputRange.length - 1; ++i)
      if (inputRange[i] >= input)
        break;
    return i - 1;
  }
  var steps = (steps2, direction = "end") => (progress2) => {
    progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
    const expanded = progress2 * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp(0, 1, rounded / steps2);
  };
  var c1 = 1.70158;
  var c2 = c1 * 1.525;
  var c3 = c1 + 1;
  var c4 = 2 * Math.PI / 3;
  var c5 = 2 * Math.PI / 4.5;
  var bounceOut = (x2) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x2 < 1 / d1) {
      return n1 * x2 * x2;
    } else if (x2 < 2 / d1) {
      return n1 * (x2 -= 1.5 / d1) * x2 + 0.75;
    } else if (x2 < 2.5 / d1) {
      return n1 * (x2 -= 2.25 / d1) * x2 + 0.9375;
    } else {
      return n1 * (x2 -= 2.625 / d1) * x2 + 0.984375;
    }
  };
  var easings = {
    linear: (x2) => x2,
    easeInQuad: (x2) => x2 * x2,
    easeOutQuad: (x2) => 1 - (1 - x2) * (1 - x2),
    easeInOutQuad: (x2) => x2 < 0.5 ? 2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 2) / 2,
    easeInCubic: (x2) => x2 * x2 * x2,
    easeOutCubic: (x2) => 1 - Math.pow(1 - x2, 3),
    easeInOutCubic: (x2) => x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2,
    easeInQuart: (x2) => x2 * x2 * x2 * x2,
    easeOutQuart: (x2) => 1 - Math.pow(1 - x2, 4),
    easeInOutQuart: (x2) => x2 < 0.5 ? 8 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 4) / 2,
    easeInQuint: (x2) => x2 * x2 * x2 * x2 * x2,
    easeOutQuint: (x2) => 1 - Math.pow(1 - x2, 5),
    easeInOutQuint: (x2) => x2 < 0.5 ? 16 * x2 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 5) / 2,
    easeInSine: (x2) => 1 - Math.cos(x2 * Math.PI / 2),
    easeOutSine: (x2) => Math.sin(x2 * Math.PI / 2),
    easeInOutSine: (x2) => -(Math.cos(Math.PI * x2) - 1) / 2,
    easeInExpo: (x2) => x2 === 0 ? 0 : Math.pow(2, 10 * x2 - 10),
    easeOutExpo: (x2) => x2 === 1 ? 1 : 1 - Math.pow(2, -10 * x2),
    easeInOutExpo: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? Math.pow(2, 20 * x2 - 10) / 2 : (2 - Math.pow(2, -20 * x2 + 10)) / 2,
    easeInCirc: (x2) => 1 - Math.sqrt(1 - Math.pow(x2, 2)),
    easeOutCirc: (x2) => Math.sqrt(1 - Math.pow(x2 - 1, 2)),
    easeInOutCirc: (x2) => x2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x2 + 2, 2)) + 1) / 2,
    easeInBack: (x2) => c3 * x2 * x2 * x2 - c1 * x2 * x2,
    easeOutBack: (x2) => 1 + c3 * Math.pow(x2 - 1, 3) + c1 * Math.pow(x2 - 1, 2),
    easeInOutBack: (x2) => x2 < 0.5 ? Math.pow(2 * x2, 2) * ((c2 + 1) * 2 * x2 - c2) / 2 : (Math.pow(2 * x2 - 2, 2) * ((c2 + 1) * (x2 * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : -Math.pow(2, 10 * x2 - 10) * Math.sin((x2 * 10 - 10.75) * c4),
    easeOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : Math.pow(2, -10 * x2) * Math.sin((x2 * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? -(Math.pow(2, 20 * x2 - 10) * Math.sin((20 * x2 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x2 + 10) * Math.sin((20 * x2 - 11.125) * c5) / 2 + 1,
    easeInBounce: (x2) => 1 - bounceOut(1 - x2),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x2) => x2 < 0.5 ? (1 - bounceOut(1 - 2 * x2)) / 2 : (1 + bounceOut(2 * x2 - 1)) / 2,
    steps
  };
  var $get = Symbol.for("FluidValue.get");
  var $observers = Symbol.for("FluidValue.observers");
  var hasFluidValue = (arg2) => Boolean(arg2 && arg2[$get]);
  var getFluidValue = (arg2) => arg2 && arg2[$get] ? arg2[$get]() : arg2;
  var getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer2, event) {
    if (observer2.eventObserved) {
      observer2.eventObserved(event);
    } else {
      observer2(event);
    }
  }
  function callFluidObservers(target, event) {
    const observers = target[$observers];
    if (observers) {
      observers.forEach((observer2) => {
        callFluidObserver(observer2, event);
      });
    }
  }
  var FluidValue = class {
    constructor(get) {
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  };
  var setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer2) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer2)) {
        observers.add(observer2);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer2);
        }
      }
    }
    return observer2;
  }
  function removeFluidObserver(target, observer2) {
    const observers = target[$observers];
    if (observers && observers.has(observer2)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer2);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer2);
      }
    }
  }
  var setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  var variableToRgba = (input) => {
    const [token2, fallback] = parseCSSVariable(input);
    if (!token2 || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token2);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (value2) {
        return value2;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  var parseCSSVariable = (current2) => {
    const match2 = cssVariableRegex.exec(current2);
    if (!match2)
      return [,];
    const [, token2, fallback] = match2;
    return [token2, fallback];
  };
  var namedColorRegex;
  var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  var createStringInterpolator2 = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors ? (
        // match color names, ignore partial matches
        new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
      ) : (
        // never match
        /^\b$/
      );
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes2 = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes2[0].map(
      (_, i) => keyframes2.map((values2) => {
        if (!(i in values2)) {
          throw Error('The arity of each "output" value must be equal');
        }
        return values2[i];
      })
    );
    const interpolators = outputRanges.map(
      (output2) => createInterpolator({ ...config2, output: output2 })
    );
    return (input) => {
      var _a;
      const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
      let i = 0;
      return output[0].replace(
        numberRegex,
        () => `${interpolators[i++](input)}${missingUnit || ""}`
      ).replace(rgbaRegex, rgbaRound);
    };
  };
  var prefix = "react-spring: ";
  var once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  var warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(
      `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
    );
  }
  var warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(
      `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
    );
  }
  function isAnimatedString(value) {
    return is$1.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
    !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
  }
  var useIsomorphicLayoutEffect = isSSR() ? reactExports.useEffect : reactExports.useLayoutEffect;
  var useIsMounted = () => {
    const isMounted = reactExports.useRef(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update2 = reactExports.useState()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update2(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = reactExports.useState(
      () => ({
        inputs,
        result: getResult()
      })
    );
    const committed = reactExports.useRef();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(
        inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
      );
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    reactExports.useEffect(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next2, prev2) {
    if (next2.length !== prev2.length) {
      return false;
    }
    for (let i = 0; i < next2.length; i++) {
      if (next2[i] !== prev2[i]) {
        return false;
      }
    }
    return true;
  }
  var useOnce = (effect2) => reactExports.useEffect(effect2, emptyDeps);
  var emptyDeps = [];
  function usePrev(value) {
    const prevRef = reactExports.useRef();
    reactExports.useEffect(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }
  var $node = Symbol.for("Animated:node");
  var isAnimated = (value) => !!value && value[$node] === value;
  var getAnimated = (owner) => owner && owner[$node];
  var setAnimated = (owner, node2) => defineHidden(owner, $node, node2);
  var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  var Animated = class {
    constructor() {
      setAnimated(this, this);
    }
    /** Get every `AnimatedValue` used by this node. */
    getPayload() {
      return this.payload || [];
    }
  };
  var AnimatedValue = class extends Animated {
    constructor(_value) {
      super();
      this._value = _value;
      this.done = true;
      this.durationProgress = 0;
      if (is$1.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    /** @internal */
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is$1.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const { done } = this;
      this.done = false;
      if (is$1.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done)
          this.lastVelocity = null;
        this.v0 = null;
      }
    }
  };
  var AnimatedString = class extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    /** @internal */
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      const value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is$1.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  };
  var TreeContext = { dependencies: null };
  var AnimatedObject = class extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values2 = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values2[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values2[key] = getFluidValue(source);
        } else if (!animated2) {
          values2[key] = source;
        }
      });
      return values2;
    }
    /** Replace the raw object data */
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each$1(this.payload, (node2) => node2.reset());
      }
    }
    /** Create a payload set. */
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    /** Add to a payload set. */
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each$1(payload, (node2) => this.add(node2));
      }
    }
  };
  var AnimatedArray = class extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    /** @internal */
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node2) => node2.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node2, i) => node2.setValue(source[i])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  };
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is$1.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  var withAnimated = (Component, host2) => {
    const hasInstance = (
      // Function components must use "forwardRef" to avoid being
      // re-rendered on every animation frame.
      !is$1.fun(Component) || Component.prototype && Component.prototype.isReactComponent
    );
    return reactExports.forwardRef((givenProps, givenRef) => {
      const instanceRef = reactExports.useRef(null);
      const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
      reactExports.useCallback(
        (value) => {
          instanceRef.current = updateRef(givenRef, value);
        },
        [givenRef]
      );
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance2 = instanceRef.current;
        if (hasInstance && !instance2) {
          return;
        }
        const didUpdate = instance2 ? host2.applyAnimatedValues(instance2, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = reactExports.useRef();
      useIsomorphicLayoutEffect(() => {
        observerRef.current = observer;
        each$1(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each$1(
              observerRef.current.deps,
              (dep) => removeFluidObserver(dep, observerRef.current)
            );
            raf.cancel(observerRef.current.update);
          }
        };
      });
      reactExports.useEffect(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each$1(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return /* @__PURE__ */ reactExports.createElement(Component, { ...usedProps, ref });
    });
  };
  var PropsObserver = class {
    constructor(update2, deps) {
      this.update = update2;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  };
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = {
        ...props,
        style: host2.createAnimatedStyle(props.style)
      };
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is$1.fun(ref))
        ref(value);
      else
        ref.current = value;
    }
    return value;
  }
  var cacheKey = Symbol.for("AnimatedComponent");
  var createHost = (components, {
    applyAnimatedValues: applyAnimatedValues2 = () => false,
    createAnimatedStyle = (style2) => new AnimatedObject(style2),
    getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: applyAnimatedValues2,
      createAnimatedStyle,
      getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is$1.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components, (Component, key) => {
      if (is$1.arr(components)) {
        key = getDisplayName(Component);
      }
      animated2[key] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  var getDisplayName = (arg2) => is$1.str(arg2) ? arg2 : arg2 && is$1.str(arg2.displayName) ? arg2.displayName : is$1.fun(arg2) && arg2.name || null;
  function callProp(value, ...args) {
    return is$1.fun(value) ? value(...args) : value;
  }
  var matchProp = (value, key) => value === true || !!(key && value && (is$1.fun(value) ? value(key) : toArray(value).includes(key)));
  var resolveProp = (prop, key) => is$1.obj(prop) ? key && prop[key] : prop;
  var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  var noopTransform = (value) => value;
  var getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is$1.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  var DEFAULT_PROPS = [
    "config",
    "onProps",
    "onStart",
    "onChange",
    "onPause",
    "onResume",
    "onRest"
  ];
  var RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    // Transition props
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    // Internal props
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = { to: to2 };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return { ...props };
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is$1.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _ in props)
      return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is$1.fun(to2) || is$1.arr(to2) && is$1.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _a;
    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    var _a;
    if (ref && ctrl.ref !== ref) {
      (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  var config = {
    default: { tension: 170, friction: 26 },
    gentle: { tension: 120, friction: 14 },
    wobbly: { tension: 180, friction: 12 },
    stiff: { tension: 210, friction: 20 },
    slow: { tension: 280, friction: 60 },
    molasses: { tension: 280, friction: 120 }
  };
  var defaults = {
    ...config.default,
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  };
  var AnimationConfig = class {
    constructor() {
      this.velocity = 0;
      Object.assign(this, defaults);
    }
  };
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = { ...defaultConfig };
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = { ...defaultConfig, ...newConfig };
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let { frequency, damping } = config2;
    const { mass } = config2;
    if (!is$1.und(frequency)) {
      if (frequency < 0.01)
        frequency = 0.01;
      if (damping < 0)
        damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is$1.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is$1.und(props.tension) || !is$1.und(props.friction);
      if (isTensionConfig || !is$1.und(props.frequency) || !is$1.und(props.damping) || !is$1.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  var emptyArray = [];
  var Animation = class {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  };
  function scheduleProps(callId, { key, props, defaultProps: defaultProps2, state, actions }) {
    return new Promise((resolve, reject) => {
      let delay;
      let timeout;
      let cancel = matchProp(props.cancel ?? (defaultProps2 == null ? void 0 : defaultProps2.cancel), key);
      if (cancel) {
        onStart();
      } else {
        if (!is$1.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals_exports.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start({ ...props, callId, cancel }, resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
    target.get(),
    results.every((result) => result.finished)
  );
  var getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  var getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  var getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const { callId, parentId, onRest } = props;
    const { asyncTo: prevTo, promise: prevPromise } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps2 = getDefaultProps(
        props,
        (value, key) => (
          // The `onRest` prop is only called when the `runAsync` promise is resolved.
          key === "onRest" ? void 0 : value
        )
      );
      let preventBail;
      let bail;
      const bailPromise = new Promise(
        (resolve, reject) => (preventBail = resolve, bail = reject)
      );
      const bailIfEnded = (bailSignal) => {
        const bailResult = (
          // The `cancel` prop or `stop` method was used.
          callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
          callId !== state.asyncId && getFinishedResult(target, false)
        );
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate2 = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals_exports.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is$1.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
          props2.parentId = callId;
          eachProp(defaultProps2, (value, key) => {
            if (is$1.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals_exports.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is$1.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate2(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate2, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is$1.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t2) => t2.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId)
      state.cancelId = cancelId;
  }
  var BailSignal = class extends Error {
    constructor() {
      super(
        "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
      );
    }
  };
  var SkipAnimationSignal = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
    }
  };
  var isFrameValue = (value) => value instanceof FrameValue;
  var nextId = 1;
  var FrameValue = class extends FluidValue {
    constructor() {
      super(...arguments);
      this.id = nextId++;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    /** Get the current value */
    get() {
      const node2 = getAnimated(this);
      return node2 && node2.getValue();
    }
    /** Create a spring that maps our value to another value */
    to(...args) {
      return globals_exports.to(this, args);
    }
    /** @deprecated Use the `to` method instead. */
    interpolate(...args) {
      deprecateInterpolate();
      return globals_exports.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1)
        this._attach();
    }
    observerRemoved(count) {
      if (count == 0)
        this._detach();
    }
    /** Called when the first child is added. */
    _attach() {
    }
    /** Called when the last child is removed. */
    _detach() {
    }
    /** Tell our children about our new value */
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    /** Tell our children about our new priority */
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  };
  var $P = Symbol.for("SpringPhase");
  var HAS_ANIMATED = 1;
  var IS_ANIMATING = 2;
  var IS_PAUSED = 4;
  var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  var SpringValue = class extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.animation = new Animation();
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is$1.und(arg1) || !is$1.und(arg2)) {
        const props = is$1.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
        if (is$1.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    /** Equals true when not advancing on each frame. */
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node2 = getAnimated(this);
      return node2 instanceof AnimatedValue ? node2.lastVelocity || 0 : node2.getPayload().map((node22) => node22.lastVelocity || 0);
    }
    /**
     * When true, this value has been animated at least once.
     */
    get hasAnimated() {
      return hasAnimated(this);
    }
    /**
     * When true, this value has an unfinished animation,
     * which is either active or paused.
     */
    get isAnimating() {
      return isAnimating(this);
    }
    /**
     * When true, all current and future animations are paused.
     */
    get isPaused() {
      return isPaused(this);
    }
    /**
     *
     *
     */
    get isDelayed() {
      return this._state.delayed;
    }
    /** Advance the current animation by a number of milliseconds */
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let { toValues } = anim;
      const { config: config2 } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node22, i) => {
        if (node22.done)
          return;
        const to2 = (
          // Animated strings always go from 0 to 1.
          node22.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
        );
        let finished = anim.immediate;
        let position2 = to2;
        if (!finished) {
          position2 = node22.lastPosition;
          if (config2.tension <= 0) {
            node22.done = true;
            return;
          }
          let elapsed = node22.elapsedTime += dt;
          const from2 = anim.fromValues[i];
          const v0 = node22.v0 != null ? node22.v0 : node22.v0 = is$1.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from2 == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from2) * 1e-3));
          if (!is$1.und(config2.duration)) {
            let p2 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node22.durationProgress > 0) {
                  node22.elapsedTime = config2.duration * node22.durationProgress;
                  elapsed = node22.elapsedTime += dt;
                }
              }
              p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
              node22.durationProgress = p2;
            }
            position2 = from2 + config2.easing(p2) * (to2 - from2);
            velocity = (position2 - node22.lastPosition) / dt;
            finished = p2 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e3 = Math.exp(-(1 - decay) * elapsed);
            position2 = from2 + v0 / (1 - decay) * (1 - e3);
            finished = Math.abs(node22.lastPosition - position2) <= precision;
            velocity = v0 * e3;
          } else {
            velocity = node22.lastVelocity == null ? v0 : node22.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is$1.und(bounceFactor);
            const isGrowing = from2 == to2 ? node22.v0 > 0 : from2 < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position2) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position2 == to2 || position2 > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position2 = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position2 - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position2 = position2 + velocity * step;
            }
          }
          node22.lastVelocity = velocity;
          if (Number.isNaN(position2)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i].done) {
          finished = false;
        }
        if (finished) {
          node22.done = true;
        } else {
          idle = false;
        }
        if (node22.setValue(position2, config2.round)) {
          changed = true;
        }
      });
      const node2 = getAnimated(this);
      const currVal = node2.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node2.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    /** Set the current value, while stopping the current animation */
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    /**
     * Freeze the active animation in time, as well as any updates merged
     * before `resume` is called.
     */
    pause() {
      this._update({ pause: true });
    }
    /** Resume the animation if paused. */
    resume() {
      this._update({ pause: false });
    }
    /** Skip to the end of the current animation. */
    finish() {
      if (isAnimating(this)) {
        const { to: to2, config: config2 } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    /** Push props into the pending queue. */
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is$1.und(to2)) {
        queue = [is$1.obj(to2) ? to2 : { ...arg2, to: to2 }];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(
        queue.map((props) => {
          const up = this._update(props);
          return up;
        })
      ).then((results) => getCombinedResult(this, results));
    }
    /**
     * Stop the current animation, and cancel any delayed updates.
     *
     * Pass `true` to call `onRest` with `cancelled: true`.
     */
    stop(cancel) {
      const { to: to2 } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    /** Restart the animation. */
    reset() {
      this._update({ reset: true });
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    /**
     * Parse the `to` and `from` range from the given `props` object.
     *
     * This also ensures the initial value is available to animated components
     * during the render phase.
     */
    _prepareNode(props) {
      const key = this.key || "";
      let { to: to2, from: from2 } = props;
      to2 = is$1.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from2 = is$1.obj(from2) ? from2[key] : from2;
      if (from2 == null) {
        from2 = void 0;
      }
      const range2 = { to: to2, from: from2 };
      if (!hasAnimated(this)) {
        if (props.reverse)
          [to2, from2] = [from2, to2];
        from2 = getFluidValue(from2);
        if (!is$1.und(from2)) {
          this._set(from2);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    /** Every update is processed by this method before merging. */
    _update({ ...props }, isLoop) {
      const { key, defaultProps: defaultProps2 } = this;
      if (props.default)
        Object.assign(
          defaultProps2,
          getDefaultProps(
            props,
            (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
          )
        );
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error(
          "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
        );
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps: defaultProps2,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(
                this,
                "onPause",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(
                this,
                "onResume",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    /** Merge props into the current animation */
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is$1.und(range2.to);
      const hasFromProp = !is$1.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const { key, defaultProps: defaultProps2, animation: anim } = this;
      const { to: prevTo, from: prevFrom } = anim;
      let { to: to2 = prevTo, from: from2 = prevFrom } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is$1.und(to2))) {
        to2 = from2;
      }
      if (props.reverse)
        [to2, from2] = [from2, to2];
      const hasFromChanged = !isEqual(from2, prevFrom);
      if (hasFromChanged) {
        anim.from = from2;
      }
      from2 = getFluidValue(from2);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const { config: config2 } = anim;
      const { decay, velocity } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(
          config2,
          callProp(props.config, key),
          // Avoid calling the same "config" prop twice.
          props.config !== defaultProps2.config ? callProp(defaultProps2.config, key) : void 0
        );
      }
      let node2 = getAnimated(this);
      if (!node2 || is$1.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = (
        // When `reset` is undefined, the `from` prop implies `reset: true`,
        // except for declarative updates. When `reset` is defined, there
        // must exist a value to animate from.
        is$1.und(props.reset) ? hasFromProp && !props.default : !is$1.und(from2) && matchProp(props.reset, key)
      );
      const value = reset ? from2 : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is$1.num(goal) || is$1.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node2.constructor) {
          if (immediate) {
            node2 = this._set(goal);
          } else
            throw Error(
              `Cannot animate between ${node2.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
            );
        }
      }
      const goalType = node2.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node2.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const { onRest } = anim;
          each$1(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              var _a;
              anim.changed = !reset;
              onRest == null ? void 0 : onRest(result, this);
              if (reset) {
                callProp(defaultProps2.onRest, result);
              } else {
                (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
              }
            });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    /** Update the `animation.to` value, which might be a `FluidValue` */
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    /**
     * Update the current value from outside the frameloop,
     * and return the `Animated` node.
     */
    _set(arg2, idle = true) {
      const value = getFluidValue(arg2);
      if (!is$1.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(
          this,
          "onStart",
          getFinishedResult(this, checkFinished(this, anim.to)),
          this
        );
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    // This method resets the animation state (even if already animating) to
    // ensure the latest from/to range is used, and it also ensures this spring
    // is added to the frameloop.
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node2) => node2.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals_exports.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    /**
     * Exit the frameloop and notify `onRest` listeners.
     *
     * Always wrap `_stop` calls with `batchedUpdates`.
     */
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each$1(anim.values, (node2) => {
          node2.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  };
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    const loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate({
        ...props,
        loop: loop2,
        // Avoid updating default props when looping.
        default: false,
        // Never loop the `pause` prop.
        pause: void 0,
        // For the "reverse" prop to loop as expected, the "to" prop
        // must be undefined. The "reverse" prop is ignored when the
        // "to" prop is an array or function.
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        // Ignore the "from" prop except on reset.
        from: reset ? props.from : void 0,
        reset,
        // The "loop" prop can return a "useSpring" props object to
        // override any of the original props.
        ...overrides
      });
    }
  }
  function createUpdate(props) {
    const { to: to2, from: from2 } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is$1.obj(to2))
      findDefined(to2, keys);
    if (is$1.obj(from2))
      findDefined(from2, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function findDefined(values2, keys) {
    eachProp(values2, (value, key) => value != null && keys.add(key));
  }
  var ACTIVE_EVENTS = [
    "onStart",
    "onRest",
    "onChange",
    "onPause",
    "onResume"
  ];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _a, _b, _c, _d;
    (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
    (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
  }
  var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  var nextId2 = 1;
  var Controller = class {
    constructor(props, flush3) {
      this.id = nextId2++;
      this.springs = {};
      this.queue = [];
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush3) {
        this._flush = flush3;
      }
      if (props) {
        this.start({ default: true, ...props });
      }
    }
    /**
     * Equals `true` when no spring values are in the frameloop, and
     * no async animation is currently active.
     */
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    /** Get the current values of our springs */
    get() {
      const values2 = {};
      this.each((spring, key) => values2[key] = spring.get());
      return values2;
    }
    /** Set the current values without animating. */
    set(values2) {
      for (const key in values2) {
        const value = values2[key];
        if (!is$1.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    /** Push an update onto the queue of each value. */
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    /**
     * Start the queued animations for every spring, and resolve the returned
     * promise once all queued animations have finished or been cancelled.
     *
     * When you pass a queue (instead of nothing), that queue is used instead of
     * the queued animations added with the `update` method, which are left alone.
     */
    start(props) {
      let { queue } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    /** @internal */
    stop(arg2, keys) {
      if (arg2 !== !!arg2) {
        keys = arg2;
      }
      if (keys) {
        const springs = this.springs;
        each$1(toArray(keys), (key) => springs[key].stop(!!arg2));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg2));
      }
      return this;
    }
    /** Freeze the active animation in time */
    pause(keys) {
      if (is$1.und(keys)) {
        this.start({ pause: true });
      } else {
        const springs = this.springs;
        each$1(toArray(keys), (key) => springs[key].pause());
      }
      return this;
    }
    /** Resume the animation if paused. */
    resume(keys) {
      if (is$1.und(keys)) {
        this.start({ pause: false });
      } else {
        const springs = this.springs;
        each$1(toArray(keys), (key) => springs[key].resume());
      }
      return this;
    }
    /** Call a function once per spring value */
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    /** @internal Called at the end of every animation frame */
    _onFrame() {
      const { onStart, onChange, onRest } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values2 = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values2;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values2;
          onRest2(result, this, this._item);
        });
      }
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else
        return;
      raf.onFrame(this._onFrame);
    }
  };
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
      (results) => getCombinedResult(ctrl, results)
    );
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const { keys, to: to2, from: from2, loop: loop2, onRest, onResolve } = props;
    const defaults2 = is$1.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false)
      props.to = null;
    if (from2 === false)
      props.from = null;
    const asyncTo = is$1.arr(to2) || is$1.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each$1(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is$1.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({ finished, cancelled }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished)
                result2.finished = false;
              if (cancelled)
                result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map(
      (key) => ctrl.springs[key].start(props)
    );
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(
        scheduleProps(++ctrl["_lastAsyncId"], {
          props,
          state,
          actions: {
            pause: noop$1,
            resume: noop$1,
            start(props2, resolve) {
              if (cancel) {
                stopAsync(state, ctrl["_lastAsyncId"]);
                resolve(getCancelledResult(ctrl));
              } else {
                props2.onRest = onRest;
                resolve(
                  runAsync(
                    asyncTo,
                    props2,
                    state,
                    ctrl
                  )
                );
              }
            }
          }
        })
      );
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = { ...ctrl.springs };
    if (props) {
      each$1(toArray(props), (props2) => {
        if (is$1.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is$1.obj(props2.to)) {
          props2 = { ...props2, to: void 0 };
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each$1(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each$1(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  var SpringContext = ({
    children,
    ...props
  }) => {
    const inherited = reactExports.useContext(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
    const { Provider: Provider2 } = ctx;
    return /* @__PURE__ */ reactExports.createElement(Provider2, { value: props }, children);
  };
  var ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, reactExports.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  var SpringRef = () => {
    const current2 = [];
    const SpringRef2 = function(props) {
      deprecateDirectCall();
      const results = [];
      each$1(current2, (ctrl, i) => {
        if (is$1.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = _getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current2;
    SpringRef2.add = function(ctrl) {
      if (!current2.includes(ctrl)) {
        current2.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i = current2.indexOf(ctrl);
      if (~i)
        current2.splice(i, 1);
    };
    SpringRef2.pause = function() {
      each$1(current2, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each$1(current2, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values2) {
      each$1(current2, (ctrl, i) => {
        const update2 = is$1.fun(values2) ? values2(i, ctrl) : values2;
        if (update2) {
          ctrl.set(update2);
        }
      });
    };
    SpringRef2.start = function(props) {
      const results = [];
      each$1(current2, (ctrl, i) => {
        if (is$1.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = this._getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each$1(current2, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each$1(current2, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
      return this;
    };
    const _getProps = function(arg2, ctrl, index) {
      return is$1.fun(arg2) ? arg2(index, ctrl) : arg2;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useTransition(data, props, deps) {
    const propsFn = is$1.fun(props) && props;
    const {
      reset,
      sort,
      trail = 0,
      expires = true,
      exitBeforeEnter = false,
      onDestroyed,
      ref: propsRef,
      config: propsConfig
    } = propsFn ? propsFn() : props;
    const ref = reactExports.useMemo(
      () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
      []
    );
    const items = toArray(data);
    const transitions = [];
    const usedTransitions = reactExports.useRef(null);
    const prevTransitions = reset ? null : usedTransitions.current;
    useIsomorphicLayoutEffect(() => {
      usedTransitions.current = transitions;
    });
    useOnce(() => {
      each$1(transitions, (t2) => {
        ref == null ? void 0 : ref.add(t2.ctrl);
        t2.ctrl.ref = ref;
      });
      return () => {
        each$1(usedTransitions.current, (t2) => {
          if (t2.expired) {
            clearTimeout(t2.expirationId);
          }
          detachRefs(t2.ctrl, ref);
          t2.ctrl.stop(true);
        });
      };
    });
    const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
    const expired = reset && usedTransitions.current || [];
    useIsomorphicLayoutEffect(
      () => each$1(expired, ({ ctrl, item, key }) => {
        detachRefs(ctrl, ref);
        callProp(onDestroyed, item, key);
      })
    );
    const reused = [];
    if (prevTransitions)
      each$1(prevTransitions, (t2, i) => {
        if (t2.expired) {
          clearTimeout(t2.expirationId);
          expired.push(t2);
        } else {
          i = reused[i] = keys.indexOf(t2.key);
          if (~i)
            transitions[i] = t2;
        }
      });
    each$1(items, (item, i) => {
      if (!transitions[i]) {
        transitions[i] = {
          key: keys[i],
          item,
          phase: "mount",
          ctrl: new Controller()
        };
        transitions[i].ctrl.item = item;
      }
    });
    if (reused.length) {
      let i = -1;
      const { leave } = propsFn ? propsFn() : props;
      each$1(reused, (keyIndex, prevIndex) => {
        const t2 = prevTransitions[prevIndex];
        if (~keyIndex) {
          i = transitions.indexOf(t2);
          transitions[i] = { ...t2, item: items[keyIndex] };
        } else if (leave) {
          transitions.splice(++i, 0, t2);
        }
      });
    }
    if (is$1.fun(sort)) {
      transitions.sort((a, b2) => sort(a.item, b2.item));
    }
    let delay = -trail;
    const forceUpdate = useForceUpdate();
    const defaultProps2 = getDefaultProps(props);
    const changes = /* @__PURE__ */ new Map();
    const exitingTransitions = reactExports.useRef(/* @__PURE__ */ new Map());
    const forceChange = reactExports.useRef(false);
    each$1(transitions, (t2, i) => {
      const key = t2.key;
      const prevPhase = t2.phase;
      const p2 = propsFn ? propsFn() : props;
      let to2;
      let phase;
      const propsDelay = callProp(p2.delay || 0, key);
      if (prevPhase == "mount") {
        to2 = p2.enter;
        phase = "enter";
      } else {
        const isLeave = keys.indexOf(key) < 0;
        if (prevPhase != "leave") {
          if (isLeave) {
            to2 = p2.leave;
            phase = "leave";
          } else if (to2 = p2.update) {
            phase = "update";
          } else
            return;
        } else if (!isLeave) {
          to2 = p2.enter;
          phase = "enter";
        } else
          return;
      }
      to2 = callProp(to2, t2.item, i);
      to2 = is$1.obj(to2) ? inferTo(to2) : { to: to2 };
      if (!to2.config) {
        const config2 = propsConfig || defaultProps2.config;
        to2.config = callProp(config2, t2.item, i, phase);
      }
      delay += trail;
      const payload = {
        ...defaultProps2,
        // we need to add our props.delay value you here.
        delay: propsDelay + delay,
        ref: propsRef,
        immediate: p2.immediate,
        // This prevents implied resets.
        reset: false,
        // Merge any phase-specific props.
        ...to2
      };
      if (phase == "enter" && is$1.und(payload.from)) {
        const p22 = propsFn ? propsFn() : props;
        const from2 = is$1.und(p22.initial) || prevTransitions ? p22.from : p22.initial;
        payload.from = callProp(from2, t2.item, i);
      }
      const { onResolve } = payload;
      payload.onResolve = (result) => {
        callProp(onResolve, result);
        const transitions2 = usedTransitions.current;
        const t22 = transitions2.find((t3) => t3.key === key);
        if (!t22)
          return;
        if (result.cancelled && t22.phase != "update") {
          return;
        }
        if (t22.ctrl.idle) {
          const idle = transitions2.every((t3) => t3.ctrl.idle);
          if (t22.phase == "leave") {
            const expiry = callProp(expires, t22.item);
            if (expiry !== false) {
              const expiryMs = expiry === true ? 0 : expiry;
              t22.expired = true;
              if (!idle && expiryMs > 0) {
                if (expiryMs <= 2147483647)
                  t22.expirationId = setTimeout(forceUpdate, expiryMs);
                return;
              }
            }
          }
          if (idle && transitions2.some((t3) => t3.expired)) {
            exitingTransitions.current.delete(t22);
            if (exitBeforeEnter) {
              forceChange.current = true;
            }
            forceUpdate();
          }
        }
      };
      const springs = getSprings(t2.ctrl, payload);
      if (phase === "leave" && exitBeforeEnter) {
        exitingTransitions.current.set(t2, { phase, springs, payload });
      } else {
        changes.set(t2, { phase, springs, payload });
      }
    });
    const context = reactExports.useContext(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useIsomorphicLayoutEffect(() => {
      if (hasContext) {
        each$1(transitions, (t2) => {
          t2.ctrl.start({ default: context });
        });
      }
    }, [context]);
    each$1(changes, (_, t2) => {
      if (exitingTransitions.current.size) {
        const ind = transitions.findIndex((state) => state.key === t2.key);
        transitions.splice(ind, 1);
      }
    });
    useIsomorphicLayoutEffect(
      () => {
        each$1(
          exitingTransitions.current.size ? exitingTransitions.current : changes,
          ({ phase, payload }, t2) => {
            const { ctrl } = t2;
            t2.phase = phase;
            ref == null ? void 0 : ref.add(ctrl);
            if (hasContext && phase == "enter") {
              ctrl.start({ default: context });
            }
            if (payload) {
              replaceRef(ctrl, payload.ref);
              if ((ctrl.ref || ref) && !forceChange.current) {
                ctrl.update(payload);
              } else {
                ctrl.start(payload);
                if (forceChange.current) {
                  forceChange.current = false;
                }
              }
            }
          }
        );
      },
      reset ? void 0 : deps
    );
    const renderTransitions = (render) => /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, transitions.map((t2, i) => {
      const { springs } = changes.get(t2) || t2.ctrl;
      const elem = render({ ...springs }, t2.item, t2, i);
      return elem && elem.type ? /* @__PURE__ */ reactExports.createElement(
        elem.type,
        {
          ...elem.props,
          key: is$1.str(t2.key) || is$1.num(t2.key) ? t2.key : t2.ctrl.id,
          ref: elem.ref
        }
      ) : elem;
    }));
    return ref ? [renderTransitions, ref] : renderTransitions;
  }
  var nextKey = 1;
  function getKeys(items, { key, keys = key }, prevTransitions) {
    if (keys === null) {
      const reused = /* @__PURE__ */ new Set();
      return items.map((item) => {
        const t2 = prevTransitions && prevTransitions.find(
          (t22) => t22.item === item && t22.phase !== "leave" && !reused.has(t22)
        );
        if (t2) {
          reused.add(t2);
          return t2.key;
        }
        return nextKey++;
      });
    }
    return is$1.und(keys) ? items : is$1.fun(keys) ? items.map(keys) : toArray(keys);
  }
  var Interpolation = class extends FrameValue {
    constructor(source, args) {
      super();
      this.source = source;
      this.idle = true;
      this._active = /* @__PURE__ */ new Set();
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is$1.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each$1(getPayload(this), (node2) => {
          node2.done = false;
        });
        if (globals_exports.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    // Observe our sources only when we're observed.
    _attach() {
      let priority2 = 1;
      each$1(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    // Stop observing our sources once we have no observers.
    _detach() {
      each$1(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce(
          (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
          0
        );
      }
    }
  };
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each$1(getPayload(self2), (node2) => {
        node2.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  var to = (source, ...args) => new Interpolation(source, args);
  globals_exports.assign({
    createStringInterpolator: createStringInterpolator2,
    to: (source, args) => new Interpolation(source, args)
  });
  var isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "")
      return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  var attributeCache = {};
  function applyAnimatedValues(instance2, props) {
    if (!instance2.nodeType || !instance2.setAttribute) {
      return false;
    }
    const isFilterElement = instance2.nodeName === "filter" || instance2.parentNode && instance2.parentNode.nodeName === "filter";
    const {
      className,
      style: style2,
      children,
      scrollTop,
      scrollLeft,
      viewBox,
      ...attributes
    } = props;
    const values2 = Object.values(attributes);
    const names = Object.keys(attributes).map(
      (name) => isFilterElement || instance2.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
        /([A-Z])/g,
        // Attributes are written in dash case
        (n2) => "-" + n2.toLowerCase()
      ))
    );
    if (children !== void 0) {
      instance2.textContent = children;
    }
    for (const name in style2) {
      if (style2.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style2[name]);
        if (isCustomPropRE.test(name)) {
          instance2.style.setProperty(name, value);
        } else {
          instance2.style[name] = value;
        }
      }
    }
    names.forEach((name, i) => {
      instance2.setAttribute(name, values2[i]);
    });
    if (className !== void 0) {
      instance2.className = className;
    }
    if (scrollTop !== void 0) {
      instance2.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance2.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance2.setAttribute("viewBox", viewBox);
    }
  }
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  var prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  var pxTransforms = /^(translate)/;
  var degTransforms = /^(rotate|skew)/;
  var addUnit = (value, unit2) => is$1.num(value) && value !== 0 ? value + unit2 : value;
  var isValueIdentity = (value, id2) => is$1.arr(value) ? value.every((v2) => isValueIdentity(v2, id2)) : is$1.num(value) ? value === id2 : parseFloat(value) === id2;
  var AnimatedStyle = class extends AnimatedObject {
    constructor({ x: x2, y: y2, z: z2, ...style2 }) {
      const inputs = [];
      const transforms = [];
      if (x2 || y2 || z2) {
        inputs.push([x2 || 0, y2 || 0, z2 || 0]);
        transforms.push((xyz) => [
          `translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`,
          // prettier-ignore
          isValueIdentity(xyz, 0)
        ]);
      }
      eachProp(style2, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style2[key];
          if (is$1.und(value))
            return;
          const unit2 = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray(value));
          transforms.push(
            key === "rotate3d" ? ([x22, y22, z22, deg]) => [
              `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit2)})`,
              isValueIdentity(deg, 0)
            ] : (input) => [
              `${key}(${input.map((v2) => addUnit(v2, unit2)).join(",")})`,
              isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
            ]
          );
        }
      });
      if (inputs.length) {
        style2.transform = new FluidTransform(inputs, transforms);
      }
      super(style2);
    }
  };
  var FluidTransform = class extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this.inputs = inputs;
      this.transforms = transforms;
      this._value = null;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each$1(this.inputs, (input, i) => {
        const arg1 = getFluidValue(input[0]);
        const [t2, id2] = this.transforms[i](
          is$1.arr(arg1) ? arg1 : input.map(getFluidValue)
        );
        transform += " " + t2;
        identity2 = identity2 && id2;
      });
      return identity2 ? "none" : transform;
    }
    // Start observing our inputs once we have an observer.
    observerAdded(count) {
      if (count == 1)
        each$1(
          this.inputs,
          (input) => each$1(
            input,
            (value) => hasFluidValue(value) && addFluidObserver(value, this)
          )
        );
    }
    // Stop observing our inputs once we have no observers.
    observerRemoved(count) {
      if (count == 0)
        each$1(
          this.inputs,
          (input) => each$1(
            input,
            (value) => hasFluidValue(value) && removeFluidObserver(value, this)
          )
        );
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  };
  var primitives = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  globals_exports.assign({
    batchedUpdates: reactDomExports.unstable_batchedUpdates,
    createStringInterpolator: createStringInterpolator2,
    colors: colors2
  });
  var host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style2) => new AnimatedStyle(style2),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
  });
  var animated = host.animated;
  const useInteractionItemProps = (skip) => {
    const {
      dispatch: dispatchInteraction
    } = reactExports.useContext(InteractionContext);
    const {
      setHighlighted,
      clearHighlighted
    } = useHighlighted();
    const getInteractionItemProps = (data) => {
      const onPointerDown = (event) => {
        if (event.currentTarget.hasPointerCapture(event.pointerId)) {
          event.currentTarget.releasePointerCapture(event.pointerId);
        }
      };
      const onPointerEnter = () => {
        dispatchInteraction({
          type: "enterItem",
          data
        });
        setHighlighted({
          seriesId: data.seriesId,
          dataIndex: data.dataIndex
        });
      };
      const onPointerLeave = (event) => {
        event.currentTarget.releasePointerCapture(event.pointerId);
        dispatchInteraction({
          type: "leaveItem",
          data
        });
        clearHighlighted();
      };
      return {
        onPointerEnter,
        onPointerLeave,
        onPointerDown
      };
    };
    return getInteractionItemProps;
  };
  const _excluded$g = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick"];
  function getBarElementUtilityClass(slot) {
    return generateUtilityClass("MuiBarElement", slot);
  }
  generateUtilityClasses("MuiBarElement", ["root"]);
  const useUtilityClasses$4 = (ownerState) => {
    const {
      classes,
      id: id2
    } = ownerState;
    const slots = {
      root: ["root", `series-${id2}`]
    };
    return composeClasses(slots, getBarElementUtilityClass, classes);
  };
  const BarElementPath = styled(animated.rect, {
    name: "MuiBarElement",
    slot: "Root",
    overridesResolver: (_, styles2) => styles2.root
  })(({
    ownerState
  }) => ({
    stroke: "none",
    fill: ownerState.isHighlighted ? color(ownerState.color).brighter(0.5).formatHex() : ownerState.color,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    opacity: ownerState.isFaded && 0.3 || 1
  }));
  function BarElement(props) {
    const {
      id: id2,
      dataIndex,
      classes: innerClasses,
      color: color2,
      slots,
      slotProps,
      style: style2,
      onClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
    const getInteractionItemProps = useInteractionItemProps();
    const {
      isFaded,
      isHighlighted
    } = useItemHighlighted({
      seriesId: id2,
      dataIndex
    });
    const ownerState = {
      id: id2,
      dataIndex,
      classes: innerClasses,
      color: color2,
      isFaded,
      isHighlighted
    };
    const classes = useUtilityClasses$4(ownerState);
    const Bar = (slots == null ? void 0 : slots.bar) ?? BarElementPath;
    const barProps = useSlotProps({
      elementType: Bar,
      externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
      externalForwardedProps: other,
      additionalProps: _extends({}, getInteractionItemProps({
        type: "bar",
        seriesId: id2,
        dataIndex
      }), {
        style: style2,
        onClick,
        cursor: onClick ? "pointer" : "unset"
      }),
      className: classes.root,
      ownerState
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Bar, _extends({}, barProps));
  }
  const getRadius = (corner, {
    hasNegative,
    hasPositive,
    borderRadius: borderRadius2,
    layout
  }) => {
    if (!borderRadius2) {
      return 0;
    }
    const isVertical = layout === "vertical";
    if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
      return borderRadius2;
    }
    if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
      return borderRadius2;
    }
    if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
      return borderRadius2;
    }
    if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
      return borderRadius2;
    }
    return 0;
  };
  const _excluded$f = ["style", "maskId"];
  const buildInset = (corners) => `inset(0px round ${corners.topLeft}px ${corners.topRight}px ${corners.bottomRight}px ${corners.bottomLeft}px)`;
  function BarClipRect(props) {
    var _a, _b;
    const radiusData = props.ownerState;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(animated.rect, {
      style: _extends({}, props.style, {
        clipPath: (props.ownerState.layout === "vertical" ? (_a = props.style) == null ? void 0 : _a.height : (_b = props.style) == null ? void 0 : _b.width).to((value) => buildInset({
          topLeft: Math.min(value, getRadius("top-left", radiusData)),
          topRight: Math.min(value, getRadius("top-right", radiusData)),
          bottomRight: Math.min(value, getRadius("bottom-right", radiusData)),
          bottomLeft: Math.min(value, getRadius("bottom-left", radiusData))
        }))
      })
    });
  }
  function BarClipPath(props) {
    const {
      style: style2,
      maskId
    } = props, rest = _objectWithoutPropertiesLoose(props, _excluded$f);
    if (!props.borderRadius || props.borderRadius <= 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", {
      id: maskId,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(BarClipRect, {
        ownerState: rest,
        style: style2
      })
    });
  }
  function getBarLabelUtilityClass(slot) {
    return generateUtilityClass("MuiBarLabel", slot);
  }
  const barLabelClasses = generateUtilityClasses("MuiBarLabel", ["root", "highlighted", "faded"]);
  const useUtilityClasses$3 = (ownerState) => {
    const {
      classes,
      seriesId,
      isFaded,
      isHighlighted
    } = ownerState;
    const slots = {
      root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded"]
    };
    return composeClasses(slots, getBarLabelUtilityClass, classes);
  };
  const getBarLabel = (options) => {
    const {
      barLabel,
      value,
      dataIndex,
      seriesId,
      height: height2,
      width: width2
    } = options;
    if (barLabel === "value") {
      return value ? value == null ? void 0 : value.toString() : null;
    }
    return barLabel({
      seriesId,
      dataIndex,
      value
    }, {
      bar: {
        height: height2,
        width: width2
      }
    });
  };
  const _excluded$e = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes"];
  const BarLabelComponent = styled(animated.text, {
    name: "MuiBarLabel",
    slot: "Root",
    overridesResolver: (_, styles2) => [{
      [`&.${barLabelClasses.faded}`]: styles2.faded
    }, {
      [`&.${barLabelClasses.highlighted}`]: styles2.highlighted
    }, styles2.root]
  })(({
    theme
  }) => {
    var _a, _b, _c, _d;
    return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
      stroke: "none",
      fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
      transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
      textAnchor: "middle",
      dominantBaseline: "central",
      pointerEvents: "none",
      opacity: 1,
      [`&.${barLabelClasses.faded}`]: {
        opacity: 0.3
      }
    });
  });
  function BarLabel(inProps) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiBarLabel"
    });
    const otherProps = _objectWithoutPropertiesLoose(props, _excluded$e);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BarLabelComponent, _extends({}, otherProps));
  }
  const _excluded$d = ["seriesId", "classes", "color", "style", "dataIndex", "barLabel", "slots", "slotProps", "height", "width", "value"], _excluded2$2 = ["ownerState"];
  function BarLabelItem(props) {
    const {
      seriesId,
      classes: innerClasses,
      color: color2,
      style: style2,
      dataIndex,
      barLabel,
      slots,
      slotProps,
      height: height2,
      width: width2,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
    const {
      isFaded,
      isHighlighted
    } = useItemHighlighted({
      seriesId,
      dataIndex
    });
    const ownerState = {
      seriesId,
      classes: innerClasses,
      color: color2,
      isFaded,
      isHighlighted,
      dataIndex
    };
    const classes = useUtilityClasses$3(ownerState);
    const Component = (slots == null ? void 0 : slots.barLabel) ?? BarLabel;
    const _useSlotProps = useSlotProps({
      elementType: Component,
      externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
      additionalProps: _extends({}, other, {
        style: style2,
        className: classes.root
      }),
      ownerState
    }), {
      ownerState: barLabelOwnerState
    } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$2);
    if (!barLabel) {
      return null;
    }
    const formattedLabelText = getBarLabel({
      barLabel,
      value,
      dataIndex,
      seriesId,
      height: height2,
      width: width2
    });
    if (!formattedLabelText) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, _extends({}, barLabelProps, barLabelOwnerState, {
      children: formattedLabelText
    }));
  }
  const _excluded$c = ["bars", "skipAnimation"];
  const leaveStyle$1 = ({
    layout,
    yOrigin,
    x: x2,
    width: width2,
    y: y2,
    xOrigin,
    height: height2
  }) => _extends({}, layout === "vertical" ? {
    y: yOrigin,
    x: x2 + width2 / 2,
    height: 0,
    width: width2
  } : {
    y: y2 + height2 / 2,
    x: xOrigin,
    height: height2,
    width: 0
  });
  const enterStyle$1 = ({
    x: x2,
    width: width2,
    y: y2,
    height: height2
  }) => ({
    x: x2 + width2 / 2,
    y: y2 + height2 / 2,
    height: height2,
    width: width2
  });
  function BarLabelPlot(props) {
    const {
      bars,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
    const barLabelTransition = useTransition(bars, {
      keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
      from: leaveStyle$1,
      leave: null,
      enter: enterStyle$1,
      update: enterStyle$1,
      immediate: skipAnimation2
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: barLabelTransition((style2, {
        seriesId,
        dataIndex,
        color: color2,
        value,
        width: width2,
        height: height2
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(BarLabelItem, _extends({
        seriesId,
        dataIndex,
        value,
        color: color2,
        width: width2,
        height: height2
      }, other, {
        style: style2
      })))
    });
  }
  const getAxisMessage = (axisDirection, axisId) => {
    const axisName = `${axisDirection}-axis`;
    const axisIdName = `${axisDirection}Axis`;
    const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
    return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
  };
  function checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis) {
    const xAxisConfig = xAxis[xAxisId];
    const yAxisConfig = yAxis[yAxisId];
    const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
    const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
    const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
    const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
    const discreteAxisDirection = verticalLayout ? "x" : "y";
    const continuousAxisDirection = verticalLayout ? "y" : "x";
    if (!isBandScaleConfig(discreteAxisConfig)) {
      throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
    }
    if (discreteAxisConfig.data === void 0) {
      throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
    }
    if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
      throw new Error(`MUI X: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
    }
  }
  const AnimationContext = /* @__PURE__ */ reactExports.createContext({
    isInitialized: false,
    data: {
      skipAnimation: void 0
    }
  });
  function AnimationProvider(props) {
    const {
      children,
      skipAnimation: inSkipAnimation
    } = props;
    const isAnimationDisabledEnvironment = typeof window === "undefined" || !(window == null ? void 0 : window.matchMedia);
    const [skipAnimation2, setSkipAnimation] = reactExports.useState(isAnimationDisabledEnvironment || void 0);
    useIsomorphicLayoutEffect(() => {
      var _a;
      if (isAnimationDisabledEnvironment) {
        return void 0;
      }
      const handleMediaChange = (event) => {
        const inputValue = event.matches || void 0;
        setSkipAnimation(inputValue);
        globals_exports.assign({
          skipAnimation: inputValue
        });
      };
      const mql = window.matchMedia("(prefers-reduced-motion)");
      handleMediaChange(mql);
      (_a = mql == null ? void 0 : mql.addEventListener) == null ? void 0 : _a.call(mql, "change", handleMediaChange);
      return () => {
        var _a2;
        (_a2 = mql == null ? void 0 : mql.removeEventListener) == null ? void 0 : _a2.call(mql, "change", handleMediaChange);
      };
    }, []);
    const value = reactExports.useMemo(() => ({
      isInitialized: true,
      data: {
        // If dev sets `skipAnimation` to true, it will skip all animations.
        // If dev sets `skipAnimation` to false, it will use user's preference.
        skipAnimation: inSkipAnimation || skipAnimation2
      }
    }), [skipAnimation2, inSkipAnimation]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimationContext.Provider, {
      value,
      children
    });
  }
  function useSkipAnimation(skipAnimation2) {
    const {
      isInitialized,
      data
    } = reactExports.useContext(AnimationContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the animation ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return skipAnimation2 || data.skipAnimation;
  }
  const _excluded$b = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
  function getBandSize({
    bandWidth: W2,
    numberOfGroups: N2,
    gapRatio: r2
  }) {
    if (r2 === 0) {
      return {
        barWidth: W2 / N2,
        offset: 0
      };
    }
    const barWidth = W2 / (N2 + (N2 - 1) * r2);
    const offset2 = r2 * barWidth;
    return {
      barWidth,
      offset: offset2
    };
  }
  const useAggregatedData = () => {
    const seriesData = useBarSeries() ?? {
      series: {},
      stackingGroups: [],
      seriesOrder: []
    };
    const axisData = useCartesianContext();
    const chartId = useChartId();
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    const masks = {};
    const data = stackingGroups.flatMap(({
      ids: groupIds
    }, groupIndex) => {
      return groupIds.flatMap((seriesId) => {
        const xAxisId = series[seriesId].xAxisId ?? series[seriesId].xAxisKey ?? defaultXAxisId;
        const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey ?? defaultYAxisId;
        const xAxisConfig = xAxis[xAxisId];
        const yAxisConfig = yAxis[yAxisId];
        const verticalLayout = series[seriesId].layout === "vertical";
        checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis);
        const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
        const xScale = xAxisConfig.scale;
        const yScale = yAxisConfig.scale;
        const colorGetter = getColor$3(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        const bandWidth = baseScaleConfig.scale.bandwidth();
        const {
          barWidth,
          offset: offset2
        } = getBandSize({
          bandWidth,
          numberOfGroups: stackingGroups.length,
          gapRatio: baseScaleConfig.barGapRatio
        });
        const barOffset = groupIndex * (barWidth + offset2);
        const {
          stackedData
        } = series[seriesId];
        return stackedData.map((values2, dataIndex) => {
          var _a, _b;
          const valueCoordinates = values2.map((v2) => verticalLayout ? yScale(v2) : xScale(v2));
          const minValueCoord = Math.round(Math.min(...valueCoordinates));
          const maxValueCoord = Math.round(Math.max(...valueCoordinates));
          const stackId = series[seriesId].stack;
          const result = {
            seriesId,
            dataIndex,
            layout: series[seriesId].layout,
            x: verticalLayout ? xScale((_a = xAxis[xAxisId].data) == null ? void 0 : _a[dataIndex]) + barOffset : minValueCoord,
            y: verticalLayout ? minValueCoord : yScale((_b = yAxis[yAxisId].data) == null ? void 0 : _b[dataIndex]) + barOffset,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
            width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
            color: colorGetter(dataIndex),
            value: series[seriesId].data[dataIndex],
            maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
          };
          if (!masks[result.maskId]) {
            masks[result.maskId] = {
              id: result.maskId,
              width: 0,
              height: 0,
              hasNegative: false,
              hasPositive: false,
              layout: result.layout,
              xOrigin: xScale(0),
              yOrigin: yScale(0),
              x: 0,
              y: 0
            };
          }
          const mask = masks[result.maskId];
          mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
          mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
          mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
          mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
          mask.hasNegative = mask.hasNegative || (result.value ?? 0) < 0;
          mask.hasPositive = mask.hasPositive || (result.value ?? 0) > 0;
          return result;
        });
      });
    });
    return {
      completedData: data,
      masksData: Object.values(masks)
    };
  };
  const leaveStyle = ({
    layout,
    yOrigin,
    x: x2,
    width: width2,
    y: y2,
    xOrigin,
    height: height2
  }) => _extends({}, layout === "vertical" ? {
    y: yOrigin,
    x: x2,
    height: 0,
    width: width2
  } : {
    y: y2,
    x: xOrigin,
    height: height2,
    width: 0
  });
  const enterStyle = ({
    x: x2,
    width: width2,
    y: y2,
    height: height2
  }) => ({
    y: y2,
    x: x2,
    height: height2,
    width: width2
  });
  function BarPlot(props) {
    const {
      completedData,
      masksData
    } = useAggregatedData();
    const {
      skipAnimation: inSkipAnimation,
      onItemClick,
      borderRadius: borderRadius2,
      barLabel
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
    const skipAnimation2 = useSkipAnimation(inSkipAnimation);
    const withoutBorderRadius = !borderRadius2 || borderRadius2 <= 0;
    const transition = useTransition(completedData, {
      keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
      from: leaveStyle,
      leave: leaveStyle,
      enter: enterStyle,
      update: enterStyle,
      immediate: skipAnimation2
    });
    const maskTransition = useTransition(withoutBorderRadius ? [] : masksData, {
      keys: (v2) => v2.id,
      from: leaveStyle,
      leave: leaveStyle,
      enter: enterStyle,
      update: enterStyle,
      immediate: skipAnimation2
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [!withoutBorderRadius && maskTransition((style2, {
        id: id2,
        hasPositive,
        hasNegative,
        layout
      }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(BarClipPath, {
          maskId: id2,
          borderRadius: borderRadius2,
          hasNegative,
          hasPositive,
          layout,
          style: style2
        });
      }), transition((style2, {
        seriesId,
        dataIndex,
        color: color2,
        maskId
      }) => {
        const barElement = /* @__PURE__ */ jsxRuntimeExports.jsx(BarElement, _extends({
          id: seriesId,
          dataIndex,
          color: color2
        }, other, {
          onClick: onItemClick && ((event) => {
            onItemClick(event, {
              type: "bar",
              seriesId,
              dataIndex
            });
          }),
          style: style2
        }));
        if (withoutBorderRadius) {
          return barElement;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx("g", {
          clipPath: `url(#${maskId})`,
          children: barElement
        });
      }), barLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(BarLabelPlot, _extends({
        bars: completedData,
        skipAnimation: skipAnimation2,
        barLabel
      }, other))]
    });
  }
  function getAsANumber(value) {
    return value instanceof Date ? value.getTime() : value;
  }
  const useAxisEvents = (disableAxisListener) => {
    const svgRef = useSvgRef();
    const drawingArea = useDrawingArea();
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = useCartesianContext();
    const {
      dispatch
    } = reactExports.useContext(InteractionContext);
    const usedXAxis = xAxisIds[0];
    const usedYAxis = yAxisIds[0];
    const mousePosition = reactExports.useRef({
      isInChart: false,
      x: -1,
      y: -1
    });
    reactExports.useEffect(() => {
      const element = svgRef.current;
      if (element === null || disableAxisListener) {
        return () => {
        };
      }
      function getNewAxisState(axisConfig, mouseValue) {
        const {
          scale,
          data: axisData,
          reverse
        } = axisConfig;
        if (!isBandScale(scale)) {
          const value = scale.invert(mouseValue);
          if (axisData === void 0) {
            return {
              value,
              index: -1
            };
          }
          const valueAsNumber = getAsANumber(value);
          const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index) => {
            const v2 = getAsANumber(pointValue);
            if (v2 > valueAsNumber) {
              if (index === 0 || Math.abs(valueAsNumber - v2) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {
                return true;
              }
            }
            if (v2 <= valueAsNumber) {
              if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v2) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {
                return true;
              }
            }
            return false;
          });
          return {
            value: closestIndex !== void 0 && closestIndex >= 0 ? axisData[closestIndex] : value,
            index: closestIndex
          };
        }
        const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());
        if (dataIndex < 0 || dataIndex >= axisData.length) {
          return null;
        }
        if (reverse) {
          const reverseIndex = axisData.length - 1 - dataIndex;
          return {
            index: reverseIndex,
            value: axisData[reverseIndex]
          };
        }
        return {
          index: dataIndex,
          value: axisData[dataIndex]
        };
      }
      const handleOut = () => {
        mousePosition.current = {
          isInChart: false,
          x: -1,
          y: -1
        };
        dispatch({
          type: "exitChart"
        });
      };
      const handleMove = (event) => {
        const target = "targetTouches" in event ? event.targetTouches[0] : event;
        const svgPoint = getSVGPoint(element, target);
        mousePosition.current.x = svgPoint.x;
        mousePosition.current.y = svgPoint.y;
        if (!drawingArea.isPointInside(svgPoint, {
          targetElement: event.target
        })) {
          if (mousePosition.current.isInChart) {
            dispatch({
              type: "exitChart"
            });
            mousePosition.current.isInChart = false;
          }
          return;
        }
        mousePosition.current.isInChart = true;
        const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);
        const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);
        dispatch({
          type: "updateAxis",
          data: {
            x: newStateX,
            y: newStateY
          }
        });
      };
      const handleDown = (event) => {
        const target = event.currentTarget;
        if (!target) {
          return;
        }
        if (target.hasPointerCapture(event.pointerId)) {
          target.releasePointerCapture(event.pointerId);
        }
      };
      element.addEventListener("pointerdown", handleDown);
      element.addEventListener("pointermove", handleMove);
      element.addEventListener("pointerout", handleOut);
      element.addEventListener("pointercancel", handleOut);
      element.addEventListener("pointerleave", handleOut);
      return () => {
        element.removeEventListener("pointerdown", handleDown);
        element.removeEventListener("pointermove", handleMove);
        element.removeEventListener("pointerout", handleOut);
        element.removeEventListener("pointercancel", handleOut);
        element.removeEventListener("pointerleave", handleOut);
      };
    }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);
  };
  const _excluded$a = ["children", "width", "height", "viewBox", "disableAxisListener", "className", "title", "desc"];
  const ChartChartsSurfaceStyles = styled("svg", {
    name: "MuiChartsSurface",
    slot: "Root"
  })(() => ({
    // This prevents default touch actions when using the svg on mobile devices.
    // For example, prevent page scroll & zoom.
    touchAction: "none"
  }));
  const ChartsSurface = /* @__PURE__ */ reactExports.forwardRef(function ChartsSurface2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiChartsSurface"
    });
    const {
      children,
      width: width2,
      height: height2,
      viewBox,
      disableAxisListener = false,
      className,
      title,
      desc
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
    const svgView = _extends({
      width: width2,
      height: height2,
      x: 0,
      y: 0
    }, viewBox);
    useAxisEvents(disableAxisListener);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChartChartsSurfaceStyles, _extends({
      width: width2,
      height: height2,
      viewBox: `${svgView.x} ${svgView.y} ${svgView.width} ${svgView.height}`,
      ref,
      className
    }, other, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("title", {
        children: title
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("desc", {
        children: desc
      }), children]
    }));
  });
  function ChartsPiecewiseGradient(props) {
    const {
      isReversed,
      gradientId,
      size,
      direction,
      scale,
      colorMap
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("linearGradient", {
      id: gradientId,
      x1: "0",
      x2: "0",
      y1: "0",
      y2: "0",
      [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
      gradientUnits: "userSpaceOnUse",
      children: colorMap.thresholds.map((threshold2, index) => {
        const x2 = scale(threshold2);
        if (x2 === void 0) {
          return null;
        }
        const offset2 = isReversed ? 1 - x2 / size : x2 / size;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("stop", {
            offset: offset2,
            stopColor: colorMap.colors[index],
            stopOpacity: 1
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("stop", {
            offset: offset2,
            stopColor: colorMap.colors[index + 1],
            stopOpacity: 1
          })]
        }, threshold2.toString() + index);
      })
    });
  }
  function useChartGradient() {
    const {
      chartId
    } = reactExports.useContext(DrawingContext);
    return reactExports.useCallback((axisId, direction) => `${chartId}-gradient-${direction}-${axisId}`, [chartId]);
  }
  function ChartsAxesGradients() {
    const {
      top: top2,
      height: height2,
      bottom: bottom2,
      left: left2,
      width: width2,
      right: right2
    } = useDrawingArea();
    const svgHeight = top2 + height2 + bottom2;
    const svgWidth = left2 + width2 + right2;
    const getGradientId = useChartGradient();
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", {
      children: [yAxisIds.filter((axisId) => yAxis[axisId].colorMap !== void 0).map((axisId) => {
        const gradientId = getGradientId(axisId, "y");
        const {
          colorMap,
          scale,
          colorScale,
          reverse
        } = yAxis[axisId];
        if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsPiecewiseGradient, {
            isReversed: !reverse,
            scale,
            colorMap,
            size: svgHeight,
            gradientId,
            direction: "y"
          }, gradientId);
        }
        if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsContinuousGradient, {
            isReversed: !reverse,
            scale,
            colorScale,
            colorMap,
            size: svgHeight,
            gradientId,
            direction: "y"
          }, gradientId);
        }
        return null;
      }), xAxisIds.filter((axisId) => xAxis[axisId].colorMap !== void 0).map((axisId) => {
        const gradientId = getGradientId(axisId, "x");
        const {
          colorMap,
          scale,
          reverse,
          colorScale
        } = xAxis[axisId];
        if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsPiecewiseGradient, {
            isReversed: reverse,
            scale,
            colorMap,
            size: svgWidth,
            gradientId,
            direction: "x"
          }, gradientId);
        }
        if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsContinuousGradient, {
            isReversed: reverse,
            scale,
            colorScale,
            colorMap,
            size: svgWidth,
            gradientId,
            direction: "x"
          }, gradientId);
        }
        return null;
      })]
    });
  }
  const defaultizeAxis = (inAxis, dataset, axisName) => {
    const DEFAULT_AXIS_KEY = axisName === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
    return [...(inAxis == null ? void 0 : inAxis.map((axis, index) => _extends({
      id: `defaultized-${axisName}-axis-${index}`
    }, axis))) ?? [], ...inAxis === void 0 || inAxis.findIndex(({
      id: id2
    }) => id2 === DEFAULT_AXIS_KEY) === -1 ? [{
      id: DEFAULT_AXIS_KEY,
      scaleType: "linear"
    }] : []].map((axisConfig) => {
      const dataKey = axisConfig.dataKey;
      if (dataKey === void 0 || axisConfig.data !== void 0) {
        return axisConfig;
      }
      if (dataset === void 0) {
        throw new Error(`MUI X: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
      }
      return _extends({}, axisConfig, {
        data: dataset.map((d2) => d2[dataKey])
      });
    });
  };
  const useDefaultizeAxis = (inXAxis, inYAxis, dataset) => {
    const xAxis = reactExports.useMemo(() => defaultizeAxis(inXAxis, dataset, "x"), [inXAxis, dataset]);
    const yAxis = reactExports.useMemo(() => defaultizeAxis(inYAxis, dataset, "y"), [inYAxis, dataset]);
    return [xAxis, yAxis];
  };
  const _excluded$9 = ["width", "height", "series", "margin", "xAxis", "yAxis", "zAxis", "colors", "dataset", "sx", "title", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "children", "skipAnimation"];
  const useChartContainerProps = (props, ref) => {
    const {
      width: width2,
      height: height2,
      series,
      margin: margin2,
      xAxis,
      yAxis,
      zAxis,
      colors: colors3,
      dataset,
      sx,
      title,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins: plugins2,
      children,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
    const svgRef = reactExports.useRef(null);
    const chartSurfaceRef = useForkRef(ref, svgRef);
    const [defaultizedXAxis, defaultizedYAxis] = useDefaultizeAxis(xAxis, yAxis, dataset);
    const drawingProviderProps = {
      width: width2,
      height: height2,
      margin: margin2,
      svgRef
    };
    const animationProviderProps = {
      skipAnimation: skipAnimation2
    };
    const pluginProviderProps = {
      plugins: plugins2
    };
    const seriesProviderProps = {
      series,
      colors: colors3,
      dataset
    };
    const cartesianProviderProps = {
      xAxis: defaultizedXAxis,
      yAxis: defaultizedYAxis,
      dataset
    };
    const zAxisContextProps = {
      zAxis,
      dataset
    };
    const highlightedProviderProps = {
      highlightedItem,
      onHighlightChange
    };
    const chartsSurfaceProps = _extends({}, other, {
      width: width2,
      height: height2,
      ref: chartSurfaceRef,
      sx,
      title,
      desc,
      disableAxisListener
    });
    return {
      children,
      drawingProviderProps,
      seriesProviderProps,
      cartesianProviderProps,
      zAxisContextProps,
      highlightedProviderProps,
      chartsSurfaceProps,
      pluginProviderProps,
      animationProviderProps,
      xAxis: defaultizedXAxis,
      yAxis: defaultizedYAxis
    };
  };
  const ChartContainer = /* @__PURE__ */ reactExports.forwardRef(function ChartContainer2(props, ref) {
    const {
      children,
      drawingProviderProps,
      seriesProviderProps,
      cartesianProviderProps,
      zAxisContextProps,
      highlightedProviderProps,
      chartsSurfaceProps,
      pluginProviderProps,
      animationProviderProps
    } = useChartContainerProps(props, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawingProvider, _extends({}, drawingProviderProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PluginProvider, _extends({}, pluginProviderProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SeriesProvider, _extends({}, seriesProviderProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CartesianProvider, _extends({}, cartesianProviderProps, {
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ZAxisContextProvider, _extends({}, zAxisContextProps, {
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(InteractionProvider, {
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(HighlightedProvider, _extends({}, highlightedProviderProps, {
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ChartsSurface, _extends({}, chartsSurfaceProps, {
                    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxesGradients, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(AnimationProvider, _extends({}, animationProviderProps, {
                      children
                    }))]
                  }))
                }))
              })
            }))
          }))
        }))
      }))
    }));
  });
  const ResizableContainer = styled("div", {
    name: "MuiResponsiveChart",
    slot: "Container"
  })(({
    ownerState
  }) => ({
    width: ownerState.width ?? "100%",
    height: ownerState.height ?? "100%",
    display: "flex",
    position: "relative",
    flexGrow: 1,
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    "&>svg": {
      width: "100%",
      height: "100%"
    }
  }));
  const useChartContainerDimensions = (inWidth, inHeight, resolveSizeBeforeRender) => {
    const stateRef = reactExports.useRef({
      displayError: false,
      initialCompute: true,
      computeRun: 0
    });
    const rootRef = reactExports.useRef(null);
    const [width2, setWidth] = reactExports.useState(0);
    const [height2, setHeight] = reactExports.useState(0);
    const computeSize = reactExports.useCallback(() => {
      const mainEl = rootRef == null ? void 0 : rootRef.current;
      if (!mainEl) {
        return {};
      }
      const win = ownerWindow(mainEl);
      const computedStyle = win.getComputedStyle(mainEl);
      const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
      const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
      setWidth(newWidth);
      setHeight(newHeight);
      return {
        width: newWidth,
        height: newHeight
      };
    }, []);
    reactExports.useEffect(() => {
      stateRef.current.displayError = true;
    }, []);
    useEnhancedEffect(() => {
      if (!resolveSizeBeforeRender || !stateRef.current.initialCompute || stateRef.current.computeRun > 20) {
        return;
      }
      const computedSize = computeSize();
      if (computedSize.width !== width2 || computedSize.height !== height2) {
        stateRef.current.computeRun += 1;
      } else if (stateRef.current.initialCompute) {
        stateRef.current.initialCompute = false;
      }
    }, [width2, height2, computeSize, resolveSizeBeforeRender]);
    useEnhancedEffect(() => {
      if (inWidth !== void 0 && inHeight !== void 0) {
        return () => {
        };
      }
      computeSize();
      const elementToObserve = rootRef.current;
      if (typeof ResizeObserver === "undefined") {
        return () => {
        };
      }
      let animationFrame;
      const observer = new ResizeObserver(() => {
        animationFrame = requestAnimationFrame(() => {
          computeSize();
        });
      });
      if (elementToObserve) {
        observer.observe(elementToObserve);
      }
      return () => {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
        if (elementToObserve) {
          observer.unobserve(elementToObserve);
        }
      };
    }, [computeSize, inHeight, inWidth]);
    return {
      containerRef: rootRef,
      width: inWidth ?? width2,
      height: inHeight ?? height2
    };
  };
  const _excluded$8 = ["width", "height", "resolveSizeBeforeRender", "margin", "children", "series", "colors", "dataset", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "sx", "title", "viewBox", "xAxis", "yAxis", "zAxis", "skipAnimation"];
  const useResponsiveChartContainerProps = (props, ref) => {
    const {
      width: width2,
      height: height2,
      resolveSizeBeforeRender,
      margin: margin2,
      children,
      series,
      colors: colors3,
      dataset,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins: plugins2,
      sx,
      title,
      viewBox,
      xAxis,
      yAxis,
      zAxis,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
    const {
      containerRef,
      width: dWidth,
      height: dHeight
    } = useChartContainerDimensions(width2, height2, resolveSizeBeforeRender);
    const resizableChartContainerProps = _extends({}, other, {
      ownerState: {
        width: width2,
        height: height2
      },
      ref: containerRef
    });
    const chartContainerProps = {
      margin: margin2,
      children,
      series,
      colors: colors3,
      dataset,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins: plugins2,
      sx,
      title,
      viewBox,
      xAxis,
      yAxis,
      zAxis,
      skipAnimation: skipAnimation2,
      width: dWidth,
      height: dHeight,
      ref
    };
    return {
      hasIntrinsicSize: dWidth && dHeight,
      chartContainerProps,
      resizableChartContainerProps
    };
  };
  const ResponsiveChartContainer = /* @__PURE__ */ reactExports.forwardRef(function ResponsiveChartContainer2(props, ref) {
    const {
      hasIntrinsicSize,
      chartContainerProps,
      resizableChartContainerProps
    } = useResponsiveChartContainerProps(props, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ResizableContainer, _extends({}, resizableChartContainerProps, {
      children: hasIntrinsicSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(ChartContainer, _extends({}, chartContainerProps)) : null
    }));
  });
  const _excluded$7 = ["message"];
  const StyledText$1 = styled("text")(({
    theme
  }) => _extends({}, theme.typography.body2, {
    stroke: "none",
    fill: theme.palette.text.primary,
    shapeRendering: "crispEdges",
    textAnchor: "middle",
    dominantBaseline: "middle"
  }));
  function ChartsLoadingOverlay(props) {
    const {
      message
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
    const {
      top: top2,
      left: left2,
      height: height2,
      width: width2
    } = useDrawingArea();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledText$1, _extends({
      x: left2 + width2 / 2,
      y: top2 + height2 / 2
    }, other, {
      children: message ?? "Loading data…"
    }));
  }
  const _excluded$6 = ["message"];
  const StyledText = styled("text")(({
    theme
  }) => _extends({}, theme.typography.body2, {
    stroke: "none",
    fill: theme.palette.text.primary,
    shapeRendering: "crispEdges",
    textAnchor: "middle",
    dominantBaseline: "middle"
  }));
  function ChartsNoDataOverlay(props) {
    const {
      message
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
    const {
      top: top2,
      left: left2,
      height: height2,
      width: width2
    } = useDrawingArea();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledText, _extends({
      x: left2 + width2 / 2,
      y: top2 + height2 / 2
    }, other, {
      children: message ?? "No data to display"
    }));
  }
  function useNoData() {
    const seriesPerType = useSeries();
    return Object.values(seriesPerType).every((seriesOfGivenType) => {
      if (!seriesOfGivenType) {
        return true;
      }
      const {
        series,
        seriesOrder
      } = seriesOfGivenType;
      return seriesOrder.every((seriesId) => series[seriesId].data.length === 0);
    });
  }
  function ChartsOverlay(props) {
    var _a, _b, _c, _d;
    const noData = useNoData();
    if (props.loading) {
      const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
    }
    if (noData) {
      const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
    }
    return null;
  }
  const _excluded$5 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "tooltip", "onAxisClick", "axisHighlight", "legend", "grid", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "children", "slots", "slotProps", "skipAnimation", "loading", "layout", "onItemClick", "highlightedItem", "onHighlightChange", "borderRadius", "barLabel", "className"];
  const useBarChartProps = (props) => {
    const {
      xAxis,
      yAxis,
      series,
      width: width2,
      height: height2,
      margin: margin2,
      colors: colors3,
      dataset,
      sx,
      tooltip,
      onAxisClick,
      axisHighlight,
      legend,
      grid,
      topAxis,
      leftAxis,
      rightAxis,
      bottomAxis,
      children,
      slots,
      slotProps,
      skipAnimation: skipAnimation2,
      loading,
      layout,
      onItemClick,
      highlightedItem,
      onHighlightChange,
      borderRadius: borderRadius2,
      barLabel,
      className
    } = props, rest = _objectWithoutPropertiesLoose(props, _excluded$5);
    const id2 = useId();
    const clipPathId = `${id2}-clip-path`;
    const hasHorizontalSeries = layout === "horizontal" || layout === void 0 && series.some((item) => item.layout === "horizontal");
    const defaultAxisConfig = {
      scaleType: "band",
      data: Array.from({
        length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
      }, (_, index) => index)
    };
    const chartContainerProps = _extends({}, rest, {
      series: series.map((s) => _extends({
        type: "bar"
      }, s, {
        layout: hasHorizontalSeries ? "horizontal" : "vertical"
      })),
      width: width2,
      height: height2,
      margin: margin2,
      colors: colors3,
      dataset,
      xAxis: xAxis ?? (hasHorizontalSeries ? void 0 : [_extends({
        id: DEFAULT_X_AXIS_KEY
      }, defaultAxisConfig)]),
      yAxis: yAxis ?? (hasHorizontalSeries ? [_extends({
        id: DEFAULT_Y_AXIS_KEY
      }, defaultAxisConfig)] : void 0),
      sx,
      highlightedItem,
      onHighlightChange,
      disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none" && !onAxisClick,
      className,
      skipAnimation: skipAnimation2
    });
    const barPlotProps = {
      onItemClick,
      slots,
      slotProps,
      borderRadius: borderRadius2,
      barLabel
    };
    const axisClickHandlerProps = {
      onAxisClick
    };
    const gridProps = {
      vertical: grid == null ? void 0 : grid.vertical,
      horizontal: grid == null ? void 0 : grid.horizontal
    };
    const clipPathGroupProps = {
      clipPath: `url(#${clipPathId})`
    };
    const clipPathProps = {
      id: clipPathId
    };
    const overlayProps = {
      slots,
      slotProps,
      loading
    };
    const chartsAxisProps = {
      topAxis,
      leftAxis,
      rightAxis,
      bottomAxis,
      slots,
      slotProps
    };
    const axisHighlightProps = _extends({}, hasHorizontalSeries ? {
      y: "band"
    } : {
      x: "band"
    }, axisHighlight);
    const legendProps = _extends({}, legend, {
      slots,
      slotProps
    });
    const tooltipProps = _extends({}, tooltip, {
      slots,
      slotProps
    });
    return {
      chartContainerProps,
      barPlotProps,
      axisClickHandlerProps,
      gridProps,
      clipPathProps,
      clipPathGroupProps,
      overlayProps,
      chartsAxisProps,
      axisHighlightProps,
      legendProps,
      tooltipProps,
      children
    };
  };
  const BarChart = /* @__PURE__ */ reactExports.forwardRef(function BarChart2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiBarChart"
    });
    const {
      chartContainerProps,
      barPlotProps,
      axisClickHandlerProps,
      gridProps,
      clipPathProps,
      clipPathGroupProps,
      overlayProps,
      chartsAxisProps,
      axisHighlightProps,
      legendProps,
      tooltipProps,
      children
    } = useBarChartProps(props);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ResponsiveChartContainer, _extends({
      ref
    }, chartContainerProps, {
      children: [props.onAxisClick && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsOnAxisClickHandler, _extends({}, axisClickHandlerProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsGrid, _extends({}, gridProps)), /* @__PURE__ */ jsxRuntimeExports.jsxs("g", _extends({}, clipPathGroupProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(BarPlot, _extends({}, barPlotProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsOverlay, _extends({}, overlayProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxis, _extends({}, chartsAxisProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsLegend, _extends({}, legendProps)), !props.loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltip, _extends({}, tooltipProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsClipPath, _extends({}, clipPathProps)), children]
    }));
  });
  const _excluded$4 = ["classes", "color", "cornerRadius", "dataIndex", "endAngle", "id", "innerRadius", "isFaded", "isHighlighted", "onClick", "outerRadius", "paddingAngle", "startAngle", "highlightScope"];
  function getPieArcUtilityClass(slot) {
    return generateUtilityClass("MuiPieArc", slot);
  }
  generateUtilityClasses("MuiPieArc", ["root", "highlighted", "faded"]);
  const useUtilityClasses$2 = (ownerState) => {
    const {
      classes,
      id: id2,
      isFaded,
      isHighlighted
    } = ownerState;
    const slots = {
      root: ["root", `series-${id2}`, isHighlighted && "highlighted", isFaded && "faded"]
    };
    return composeClasses(slots, getPieArcUtilityClass, classes);
  };
  const PieArcRoot = styled(animated.path, {
    name: "MuiPieArc",
    slot: "Root",
    overridesResolver: (_, styles2) => styles2.arc
  })(({
    theme
  }) => ({
    stroke: (theme.vars || theme).palette.background.paper,
    strokeWidth: 1,
    strokeLinejoin: "round"
  }));
  function PieArc(props) {
    const {
      classes: innerClasses,
      color: color2,
      cornerRadius,
      dataIndex,
      endAngle,
      id: id2,
      innerRadius,
      isFaded,
      isHighlighted,
      onClick,
      outerRadius,
      paddingAngle,
      startAngle
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
    const ownerState = {
      id: id2,
      dataIndex,
      classes: innerClasses,
      color: color2,
      isFaded,
      isHighlighted
    };
    const classes = useUtilityClasses$2(ownerState);
    const getInteractionItemProps = useInteractionItemProps();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PieArcRoot, _extends({
      d: to([startAngle, endAngle, paddingAngle, innerRadius, outerRadius, cornerRadius], (sA, eA, pA, iR, oR, cR) => d3Arc().cornerRadius(cR)({
        padAngle: pA,
        startAngle: sA,
        endAngle: eA,
        innerRadius: iR,
        outerRadius: oR
      })),
      visibility: to([startAngle, endAngle], (sA, eA) => sA === eA ? "hidden" : "visible"),
      onClick,
      cursor: onClick ? "pointer" : "unset",
      ownerState,
      className: classes.root
    }, other, getInteractionItemProps({
      type: "pie",
      seriesId: id2,
      dataIndex
    })));
  }
  const defaultTransitionConfig = {
    keys: (item) => item.id,
    from: ({
      innerRadius,
      outerRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle,
      color: color2,
      isFaded
    }) => ({
      innerRadius,
      outerRadius: (innerRadius + outerRadius) / 2,
      cornerRadius,
      startAngle: (startAngle + endAngle) / 2,
      endAngle: (startAngle + endAngle) / 2,
      paddingAngle,
      fill: color2,
      opacity: isFaded ? 0.3 : 1
    }),
    leave: ({
      innerRadius,
      startAngle,
      endAngle
    }) => ({
      innerRadius,
      outerRadius: innerRadius,
      startAngle: (startAngle + endAngle) / 2,
      endAngle: (startAngle + endAngle) / 2
    }),
    enter: ({
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }) => ({
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }),
    update: ({
      innerRadius,
      outerRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle,
      color: color2,
      isFaded
    }) => ({
      innerRadius,
      outerRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle,
      fill: color2,
      opacity: isFaded ? 0.3 : 1
    }),
    config: {
      tension: 120,
      friction: 14,
      clamp: true
    }
  };
  const defaultLabelTransitionConfig = {
    keys: (item) => item.id,
    from: ({
      innerRadius,
      outerRadius,
      arcLabelRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle
    }) => ({
      innerRadius,
      outerRadius: (innerRadius + outerRadius) / 2,
      cornerRadius,
      arcLabelRadius,
      startAngle: (startAngle + endAngle) / 2,
      endAngle: (startAngle + endAngle) / 2,
      paddingAngle,
      opacity: 0
    }),
    leave: ({
      innerRadius,
      startAngle,
      endAngle
    }) => ({
      innerRadius,
      outerRadius: innerRadius,
      arcLabelRadius: innerRadius,
      startAngle: (startAngle + endAngle) / 2,
      endAngle: (startAngle + endAngle) / 2,
      opacity: 0
    }),
    enter: ({
      innerRadius,
      outerRadius,
      startAngle,
      endAngle,
      arcLabelRadius
    }) => ({
      innerRadius,
      outerRadius,
      startAngle,
      endAngle,
      arcLabelRadius,
      opacity: 1
    }),
    update: ({
      innerRadius,
      outerRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle,
      arcLabelRadius
    }) => ({
      innerRadius,
      outerRadius,
      cornerRadius,
      startAngle,
      endAngle,
      paddingAngle,
      arcLabelRadius,
      opacity: 1
    }),
    config: {
      tension: 120,
      friction: 14,
      clamp: true
    }
  };
  function useTransformData(series) {
    const {
      id: seriesId,
      data,
      faded,
      highlighted,
      paddingAngle: basePaddingAngle = 0,
      innerRadius: baseInnerRadius = 0,
      arcLabelRadius: baseArcLabelRadius,
      outerRadius: baseOuterRadius,
      cornerRadius: baseCornerRadius = 0
    } = series;
    const {
      isFaded: isItemFaded,
      isHighlighted: isItemHighlighted
    } = useHighlighted();
    const dataWithHighlight = reactExports.useMemo(() => data.map((item, itemIndex) => {
      const currentItem = {
        seriesId,
        dataIndex: itemIndex
      };
      const isHighlighted = isItemHighlighted(currentItem);
      const isFaded = !isHighlighted && isItemFaded(currentItem);
      const attributesOverride = _extends({
        additionalRadius: 0
      }, isFaded && faded || isHighlighted && highlighted || {});
      const paddingAngle = Math.max(0, Math.PI * (attributesOverride.paddingAngle ?? basePaddingAngle) / 180);
      const innerRadius = Math.max(0, attributesOverride.innerRadius ?? baseInnerRadius);
      const outerRadius = Math.max(0, attributesOverride.outerRadius ?? baseOuterRadius + attributesOverride.additionalRadius);
      const cornerRadius = attributesOverride.cornerRadius ?? baseCornerRadius;
      const arcLabelRadius = attributesOverride.arcLabelRadius ?? baseArcLabelRadius ?? (innerRadius + outerRadius) / 2;
      return _extends({}, item, attributesOverride, {
        isFaded,
        isHighlighted,
        paddingAngle,
        innerRadius,
        outerRadius,
        cornerRadius,
        arcLabelRadius
      });
    }), [baseCornerRadius, baseInnerRadius, baseOuterRadius, basePaddingAngle, baseArcLabelRadius, data, faded, highlighted, isItemFaded, isItemHighlighted, seriesId]);
    return dataWithHighlight;
  }
  const _excluded$3 = ["slots", "slotProps", "innerRadius", "outerRadius", "cornerRadius", "paddingAngle", "id", "highlighted", "faded", "data", "onItemClick", "skipAnimation"], _excluded2$1 = ["startAngle", "endAngle", "paddingAngle", "innerRadius", "arcLabelRadius", "outerRadius", "cornerRadius"];
  function PieArcPlot(props) {
    const {
      slots,
      slotProps,
      innerRadius = 0,
      outerRadius,
      cornerRadius = 0,
      paddingAngle = 0,
      id: id2,
      highlighted,
      faded = {
        additionalRadius: -5
      },
      data,
      onItemClick,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
    const transformedData = useTransformData({
      innerRadius,
      outerRadius,
      cornerRadius,
      paddingAngle,
      id: id2,
      highlighted,
      faded,
      data
    });
    const transition = useTransition(transformedData, _extends({}, defaultTransitionConfig, {
      immediate: skipAnimation2
    }));
    const {
      highlightScope
    } = useHighlighted();
    if (data.length === 0) {
      return null;
    }
    const Arc = (slots == null ? void 0 : slots.pieArc) ?? PieArc;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", _extends({}, other, {
      children: transition((_ref, item, _, index) => {
        let {
          startAngle,
          endAngle,
          paddingAngle: pA,
          innerRadius: iR,
          outerRadius: oR,
          cornerRadius: cR
        } = _ref, style2 = _objectWithoutPropertiesLoose(_ref, _excluded2$1);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Arc, _extends({
          startAngle,
          endAngle,
          paddingAngle: pA,
          innerRadius: iR,
          outerRadius: oR,
          cornerRadius: cR,
          style: style2,
          id: id2,
          color: item.color,
          dataIndex: index,
          highlightScope,
          isFaded: item.isFaded,
          isHighlighted: item.isHighlighted,
          onClick: onItemClick && ((event) => {
            onItemClick(event, {
              type: "pie",
              seriesId: id2,
              dataIndex: index
            }, item);
          })
        }, slotProps == null ? void 0 : slotProps.pieArc));
      })
    }));
  }
  const _excluded$2 = ["id", "classes", "color", "startAngle", "endAngle", "paddingAngle", "arcLabelRadius", "innerRadius", "outerRadius", "cornerRadius", "formattedArcLabel", "isHighlighted", "isFaded", "style"];
  function getPieArcLabelUtilityClass(slot) {
    return generateUtilityClass("MuiPieArcLabel", slot);
  }
  generateUtilityClasses("MuiPieArcLabel", ["root", "highlighted", "faded"]);
  const useUtilityClasses$1 = (ownerState) => {
    const {
      classes,
      id: id2,
      isFaded,
      isHighlighted
    } = ownerState;
    const slots = {
      root: ["root", `series-${id2}`, isHighlighted && "highlighted", isFaded && "faded"]
    };
    return composeClasses(slots, getPieArcLabelUtilityClass, classes);
  };
  const PieArcLabelRoot = styled(animated.text, {
    name: "MuiPieArcLabel",
    slot: "Root",
    overridesResolver: (_, styles2) => styles2.root
  })(({
    theme
  }) => ({
    fill: (theme.vars || theme).palette.text.primary,
    textAnchor: "middle",
    dominantBaseline: "middle",
    pointerEvents: "none"
  }));
  const getLabelPosition = (formattedArcLabel, variable) => (startAngle, endAngle, padAngle, arcLabelRadius, cornerRadius) => {
    if (!formattedArcLabel) {
      return 0;
    }
    const [x2, y2] = d3Arc().cornerRadius(cornerRadius).centroid({
      padAngle,
      startAngle,
      endAngle,
      innerRadius: arcLabelRadius,
      outerRadius: arcLabelRadius
    });
    if (variable === "x") {
      return x2;
    }
    return y2;
  };
  function PieArcLabel(props) {
    const {
      id: id2,
      classes: innerClasses,
      color: color2,
      startAngle,
      endAngle,
      paddingAngle,
      arcLabelRadius,
      cornerRadius,
      formattedArcLabel,
      isHighlighted,
      isFaded,
      style: style2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
    const ownerState = {
      id: id2,
      classes: innerClasses,
      color: color2,
      isFaded,
      isHighlighted
    };
    const classes = useUtilityClasses$1(ownerState);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PieArcLabelRoot, _extends({
      className: classes.root
    }, other, {
      style: _extends({
        x: to([startAngle, endAngle, paddingAngle, arcLabelRadius, cornerRadius], getLabelPosition(formattedArcLabel, "x")),
        y: to([startAngle, endAngle, paddingAngle, arcLabelRadius, cornerRadius], getLabelPosition(formattedArcLabel, "y"))
      }, style2),
      children: formattedArcLabel
    }));
  }
  const _excluded$1 = ["arcLabel", "arcLabelMinAngle", "arcLabelRadius", "cornerRadius", "data", "faded", "highlighted", "id", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation", "slotProps", "slots"], _excluded2 = ["startAngle", "endAngle", "paddingAngle", "innerRadius", "outerRadius", "arcLabelRadius", "cornerRadius"];
  const RATIO = 180 / Math.PI;
  function getItemLabel(arcLabel, arcLabelMinAngle, item) {
    var _a;
    if (!arcLabel) {
      return null;
    }
    const angle = (item.endAngle - item.startAngle) * RATIO;
    if (angle < arcLabelMinAngle) {
      return null;
    }
    switch (arcLabel) {
      case "label":
        return getLabel(item.label, "arc");
      case "value":
        return (_a = item.value) == null ? void 0 : _a.toString();
      case "formattedValue":
        return item.formattedValue;
      default:
        return arcLabel(_extends({}, item, {
          label: getLabel(item.label, "arc")
        }));
    }
  }
  function PieArcLabelPlot(props) {
    const {
      arcLabel,
      arcLabelMinAngle = 0,
      arcLabelRadius,
      cornerRadius = 0,
      data,
      faded = {
        additionalRadius: -5
      },
      highlighted,
      id: id2,
      innerRadius,
      outerRadius,
      paddingAngle = 0,
      skipAnimation: skipAnimation2,
      slotProps,
      slots
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
    const transformedData = useTransformData({
      innerRadius,
      outerRadius,
      arcLabelRadius,
      cornerRadius,
      paddingAngle,
      id: id2,
      highlighted,
      faded,
      data
    });
    const transition = useTransition(transformedData, _extends({}, defaultLabelTransitionConfig, {
      immediate: skipAnimation2
    }));
    if (data.length === 0) {
      return null;
    }
    const ArcLabel = (slots == null ? void 0 : slots.pieArcLabel) ?? PieArcLabel;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", _extends({}, other, {
      children: transition((_ref, item) => {
        let {
          startAngle,
          endAngle,
          paddingAngle: pA,
          innerRadius: iR,
          outerRadius: oR,
          arcLabelRadius: aLR,
          cornerRadius: cR
        } = _ref, style2 = _objectWithoutPropertiesLoose(_ref, _excluded2);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ArcLabel, _extends({
          startAngle,
          endAngle,
          paddingAngle: pA,
          innerRadius: iR,
          outerRadius: oR,
          arcLabelRadius: aLR,
          cornerRadius: cR,
          style: style2,
          id: id2,
          color: item.color,
          isFaded: item.isFaded,
          isHighlighted: item.isHighlighted,
          formattedArcLabel: getItemLabel(arcLabel, arcLabelMinAngle, item)
        }, slotProps == null ? void 0 : slotProps.pieArcLabel));
      })
    }));
  }
  function getPieCoordinates(series, drawing) {
    const {
      height: height2,
      width: width2
    } = drawing;
    const {
      cx: cxParam,
      cy: cyParam
    } = series;
    const availableRadius = Math.min(width2, height2) / 2;
    const cx = getPercentageValue(cxParam ?? "50%", width2);
    const cy = getPercentageValue(cyParam ?? "50%", height2);
    return {
      cx,
      cy,
      availableRadius
    };
  }
  function PiePlot(props) {
    const {
      skipAnimation: inSkipAnimation,
      slots,
      slotProps,
      onItemClick
    } = props;
    const seriesData = usePieSeries();
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2
    } = reactExports.useContext(DrawingContext);
    const skipAnimation2 = useSkipAnimation(inSkipAnimation);
    if (seriesData === void 0) {
      return null;
    }
    const {
      series,
      seriesOrder
    } = seriesData;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", {
      children: [seriesOrder.map((seriesId) => {
        const {
          innerRadius: innerRadiusParam,
          outerRadius: outerRadiusParam,
          cornerRadius,
          paddingAngle,
          data,
          cx: cxParam,
          cy: cyParam,
          highlighted,
          faded
        } = series[seriesId];
        const {
          cx,
          cy,
          availableRadius
        } = getPieCoordinates({
          cx: cxParam,
          cy: cyParam
        }, {
          width: width2,
          height: height2
        });
        const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
        const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("g", {
          transform: `translate(${left2 + cx}, ${top2 + cy})`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PieArcPlot, {
            innerRadius,
            outerRadius,
            cornerRadius,
            paddingAngle,
            id: seriesId,
            data,
            skipAnimation: skipAnimation2,
            highlighted,
            faded,
            onItemClick,
            slots,
            slotProps
          })
        }, seriesId);
      }), seriesOrder.map((seriesId) => {
        const {
          innerRadius: innerRadiusParam,
          outerRadius: outerRadiusParam,
          arcLabelRadius: arcLabelRadiusParam,
          cornerRadius,
          paddingAngle,
          arcLabel,
          arcLabelMinAngle,
          data,
          cx: cxParam,
          cy: cyParam
        } = series[seriesId];
        const {
          cx,
          cy,
          availableRadius
        } = getPieCoordinates({
          cx: cxParam,
          cy: cyParam
        }, {
          width: width2,
          height: height2
        });
        const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
        const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
        const arcLabelRadius = arcLabelRadiusParam === void 0 ? (outerRadius + innerRadius) / 2 : getPercentageValue(arcLabelRadiusParam, availableRadius);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("g", {
          transform: `translate(${left2 + cx}, ${top2 + cy})`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PieArcLabelPlot, {
            innerRadius,
            outerRadius: outerRadius ?? availableRadius,
            arcLabelRadius,
            cornerRadius,
            paddingAngle,
            id: seriesId,
            data,
            skipAnimation: skipAnimation2,
            arcLabel,
            arcLabelMinAngle,
            slots,
            slotProps
          })
        }, seriesId);
      })]
    });
  }
  const _excluded = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "sx", "tooltip", "axisHighlight", "skipAnimation", "legend", "topAxis", "leftAxis", "rightAxis", "bottomAxis", "children", "slots", "slotProps", "onItemClick", "loading", "highlightedItem", "onHighlightChange", "className"];
  const defaultMargin = {
    top: 5,
    bottom: 5,
    left: 5,
    right: 100
  };
  const defaultRTLMargin = {
    top: 5,
    bottom: 5,
    left: 100,
    right: 5
  };
  const PieChart = /* @__PURE__ */ reactExports.forwardRef(function PieChart2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiPieChart"
    });
    const {
      xAxis,
      yAxis,
      series,
      width: width2,
      height: height2,
      margin: marginProps,
      colors: colors3,
      sx,
      tooltip = {
        trigger: "item"
      },
      axisHighlight = {
        x: "none",
        y: "none"
      },
      skipAnimation: skipAnimation2,
      legend: legendProps,
      topAxis = null,
      leftAxis = null,
      rightAxis = null,
      bottomAxis = null,
      children,
      slots,
      slotProps,
      onItemClick,
      loading,
      highlightedItem,
      onHighlightChange,
      className
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
    const isRtl = useRtl();
    const margin2 = _extends({}, isRtl ? defaultRTLMargin : defaultMargin, marginProps);
    const legend = _extends({
      direction: "column",
      position: {
        vertical: "middle",
        horizontal: isRtl ? "left" : "right"
      }
    }, legendProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ResponsiveChartContainer, _extends({}, other, {
      ref,
      series: series.map((s) => _extends({
        type: "pie"
      }, s)),
      width: width2,
      height: height2,
      margin: margin2,
      xAxis: xAxis ?? [{
        id: DEFAULT_X_AXIS_KEY,
        scaleType: "point",
        data: [...new Array(Math.max(...series.map((s) => s.data.length)))].map((_, index) => index)
      }],
      yAxis,
      colors: colors3,
      sx,
      disableAxisListener: (tooltip == null ? void 0 : tooltip.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
      highlightedItem,
      onHighlightChange,
      className,
      skipAnimation: skipAnimation2,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxis, {
        topAxis,
        leftAxis,
        rightAxis,
        bottomAxis,
        slots,
        slotProps
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(PiePlot, {
        slots,
        slotProps,
        onItemClick
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsOverlay, {
        loading,
        slots,
        slotProps
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsLegend, _extends({}, legend, {
        slots,
        slotProps
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsAxisHighlight, _extends({}, axisHighlight)), !loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ChartsTooltip, _extends({}, tooltip, {
        slots,
        slotProps
      })), children]
    }));
  });
  const Context = /* @__PURE__ */ reactExports.createContext(null);
  function useUniquePrefix() {
    const [id2, setId] = reactExports.useState(null);
    reactExports.useEffect(() => {
      setId(`mui-p-${Math.round(Math.random() * 1e5)}`);
    }, []);
    return id2;
  }
  function TabContext(props) {
    const {
      children,
      value
    } = props;
    const idPrefix = useUniquePrefix();
    const context = reactExports.useMemo(() => {
      return {
        idPrefix,
        value
      };
    }, [idPrefix, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
      value: context,
      children
    });
  }
  function useTabContext() {
    return reactExports.useContext(Context);
  }
  function getPanelId(context, value) {
    const {
      idPrefix
    } = context;
    if (idPrefix === null) {
      return null;
    }
    return `${context.idPrefix}-P-${value}`;
  }
  function getTabId(context, value) {
    const {
      idPrefix
    } = context;
    if (idPrefix === null) {
      return null;
    }
    return `${context.idPrefix}-T-${value}`;
  }
  const TabList = /* @__PURE__ */ reactExports.forwardRef(function TabList2(props, ref) {
    const {
      children: childrenProp,
      ...other
    } = props;
    const context = useTabContext();
    if (context === null) {
      throw new TypeError("No TabContext provided");
    }
    const children = reactExports.Children.map(childrenProp, (child) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        // SOMEDAY: `Tabs` will set those themselves
        "aria-controls": getPanelId(context, child.props.value),
        id: getTabId(context, child.props.value)
      });
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, {
      ...other,
      ref,
      value: context.value,
      children
    });
  });
  function getTabPanelUtilityClass(slot) {
    return generateUtilityClass("MuiTabPanel", slot);
  }
  generateUtilityClasses("MuiTabPanel", ["root", "hidden"]);
  const useUtilityClasses = (ownerState) => {
    const {
      classes,
      hidden
    } = ownerState;
    const slots = {
      root: ["root", hidden && "hidden"]
    };
    return composeClasses(slots, getTabPanelUtilityClass, classes);
  };
  const TabPanelRoot = styled("div", {
    name: "MuiTabPanel",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    padding: theme.spacing(3)
  }));
  const TabPanel = /* @__PURE__ */ reactExports.forwardRef(function TabPanel2(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: "MuiTabPanel"
    });
    const {
      children,
      className,
      value,
      keepMounted = false,
      ...other
    } = props;
    const ownerState = {
      ...props
    };
    const classes = useUtilityClasses(ownerState);
    const context = useTabContext();
    if (context === null) {
      throw new TypeError("No TabContext provided");
    }
    const id2 = getPanelId(context, value);
    const tabId = getTabId(context, value);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanelRoot, {
      "aria-labelledby": tabId,
      className: clsx(classes.root, className),
      hidden: value !== context.value,
      id: id2,
      ref,
      role: "tabpanel",
      ownerState,
      ...other,
      children: (keepMounted || value === context.value) && children
    });
  });
  const SinglesSection = () => {
    const { singles, isLoading: isLoadingSingles } = useSingles();
    const [value, setValue] = React$1.useState("1");
    const handleChange = (event, newValue) => {
      setValue(newValue);
    };
    const filteredSingles = singles.filter((single) => single.lastSell && single.lastSell > 0);
    return /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Singles" }, isLoadingSingles ? /* @__PURE__ */ React$1.createElement("div", null, /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "circular", width: 100, height: 100 })) : /* @__PURE__ */ React$1.createElement(TabContext, { value }, /* @__PURE__ */ React$1.createElement(TabList, { variant: "fullWidth", onChange: handleChange, "aria-label": "lab API tabs example" }, /* @__PURE__ */ React$1.createElement(Tab, { label: "Last Sells", value: "1" }), /* @__PURE__ */ React$1.createElement(Tab, { label: "Storage", value: "2" }), /* @__PURE__ */ React$1.createElement(Tab, { label: "Total Sells", value: "3" })), /* @__PURE__ */ React$1.createElement(TabPanel, { value: "1" }, /* @__PURE__ */ React$1.createElement(Typography, { variant: "h6" }, "Vendas em ", filteredSingles.length > 0 ? filteredSingles[0].lastSellDate.toLocaleDateString() : "Data não disponível"), /* @__PURE__ */ React$1.createElement(
      PieChart,
      {
        series: [
          {
            data: filteredSingles.map((single, index) => ({
              id: index,
              value: single.lastSell,
              label: single.title
            })),
            highlightScope: { fade: "global", highlight: "item" }
          }
        ],
        height: 150
      }
    )), /* @__PURE__ */ React$1.createElement(TabPanel, { value: "2" }, /* @__PURE__ */ React$1.createElement(Table, null, /* @__PURE__ */ React$1.createElement(TableHead, null, /* @__PURE__ */ React$1.createElement(TableRow, null, /* @__PURE__ */ React$1.createElement(TableCell, null, "Single"), /* @__PURE__ */ React$1.createElement(TableCell, { align: "right" }, "Remaining Stock"))), /* @__PURE__ */ React$1.createElement(TableBody, null, filteredSingles.map((single) => /* @__PURE__ */ React$1.createElement(TableRow, { key: single.title }, /* @__PURE__ */ React$1.createElement(TableCell, null, single.title), /* @__PURE__ */ React$1.createElement(TableCell, { align: "right" }, single.stock)))))), /* @__PURE__ */ React$1.createElement(TabPanel, { value: "3" }, /* @__PURE__ */ React$1.createElement(
      BarChart,
      {
        sx: {
          "& .MuiChartsLegend-series text": { fontSize: "0.7em !important" },
          "& .MuiChartsAxis-tickLabel": { fontSize: "0.7em !important" }
        },
        series: [
          {
            data: filteredSingles.map((single) => single.sells)
          }
        ],
        xAxis: [{
          scaleType: "band",
          data: filteredSingles.map((single) => {
            const maxLabelLength = 7;
            return single.title.length > maxLabelLength ? `${single.title.slice(0, maxLabelLength)}...` : single.title;
          })
        }],
        height: 200,
        layout: "vertical"
      }
    ))));
  };
  class BandmateImpl {
    constructor(id2, name, sq, friendship, romance, hate, instruments) {
      this.id = id2;
      this.name = name;
      this.sq = sq;
      this.friendship = friendship;
      this.romance = romance;
      this.hate = hate;
      this.instruments = instruments;
    }
  }
  class InstrumentImpl {
    constructor(id2, name) {
      this.id = id2;
      this.name = name;
    }
  }
  function useBandmate() {
    const [bandmates, setBandmates] = reactExports.useState([]);
    const [isLoading, setIsLoading] = reactExports.useState(true);
    const artistId = useSelector((state) => state.artist.artistId);
    reactExports.useEffect(() => {
      if (!artistId) return;
      function getUrlDomain() {
        return window.location.hostname;
      }
      function getBandmates() {
        const bandmates2 = [];
        const members = document.querySelectorAll("#ctl00_cphLeftColumn_ctl01_divCurrentMembers .clear");
        members.forEach((member) => {
          const hrefElement = member.querySelector("a[href*='/World/Popmundo.aspx/Character/']");
          const idHolder = member.querySelector(".idHolder");
          const nameElement = member.querySelector("p.float_left a");
          if (hrefElement && idHolder && nameElement && idHolder.textContent && nameElement.textContent) {
            const id2 = parseInt(idHolder.textContent.trim(), 10);
            const name = nameElement.textContent.trim();
            if (!isNaN(id2)) {
              const bandmate = new BandmateImpl(id2, name, 0, 0, 0, 0);
              bandmates2.push(bandmate);
            }
          }
        });
        return bandmates2;
      }
      async function fetchBandmateSq(bandmate) {
        return new Promise((resolve, reject) => {
          const iframe = $('<iframe id="iframe-bandmate-sq" style="display:none;"></iframe>');
          $("body").append(iframe);
          const urlDomain = getUrlDomain();
          const url = `https://${urlDomain}/World/Popmundo.aspx/Character/${bandmate.id}`;
          $("#iframe-bandmate-sq").attr("src", url);
          $("#iframe-bandmate-sq").on("load", function() {
            const iframeContents = $("#iframe-bandmate-sq").contents();
            const sqElement = iframeContents.find(".charMainValues table.width100 tbody tr").eq(2).find("td span.sortkey");
            if (sqElement.length > 0) {
              const sqValue = parseInt(sqElement.text().trim(), 10);
              bandmate.sq = !isNaN(sqValue) ? sqValue : 0;
              resolve(bandmate);
            } else {
              reject(new Error("Elemento de Star Quality (SQ) não encontrado."));
            }
            $("#iframe-bandmate-sq").remove();
          });
        });
      }
      async function fetchBandmateRelationship(bandmate) {
        return new Promise((resolve, reject) => {
          const iframe = $('<iframe id="iframe-bandmate-relationship" style="display:none;"></iframe>');
          $("body").append(iframe);
          const urlDomain = getUrlDomain();
          const url = `https://${urlDomain}/World/Popmundo.aspx/Interact/Details/${bandmate.id}`;
          $("#iframe-bandmate-relationship").attr("src", url);
          $("#iframe-bandmate-relationship").on("load", function() {
            const iframeContents = $("#iframe-bandmate-relationship").contents();
            try {
              const romanceElement = iframeContents.find("table.width100 tbody tr").eq(0).find("td").eq(1).find("span.sortkey");
              const romance = parseInt(romanceElement.text().trim(), 10);
              const friendshipElement = iframeContents.find("table.width100 tbody tr").eq(1).find("td").eq(1).find("span.sortkey");
              const friendship = parseInt(friendshipElement.text().trim(), 10);
              const hateElement = iframeContents.find("table.width100 tbody tr").eq(2).find("td").eq(1).find("span.sortkey");
              const hate = parseInt(hateElement.text().trim(), 10);
              bandmate.romance = !isNaN(romance) ? romance : 0;
              bandmate.friendship = !isNaN(friendship) ? friendship : 0;
              bandmate.hate = !isNaN(hate) ? hate : 0;
              resolve(bandmate);
            } catch (error) {
              reject(new Error("Error extracting relationship data"));
            }
            $("#iframe-bandmate-relationship").remove();
          });
        });
      }
      async function fetchInstrumentQuality(instrument) {
        console.log(`Fetching quality for instrument: ${instrument.name} (ID: ${instrument.id})`);
        return new Promise((resolve) => {
          const iframeId = `iframe-instrument-quality-${instrument.id}`;
          const iframe = $(`<iframe id="${iframeId}" style="display:none;"></iframe>`);
          $("body").append(iframe);
          const urlDomain = getUrlDomain();
          const url = `https://${urlDomain}/World/Popmundo.aspx/Character/ItemDetails/${instrument.id}`;
          $(`#${iframeId}`).attr("src", url);
          $(`#${iframeId}`).on("load", function() {
            const iframeContents = $(`#${iframeId}`).contents();
            const qualityText = iframeContents.find('tr:contains("Qualidade") td:nth-child(2) a').attr("title") || iframeContents.find('tr:contains("Quality") td:nth-child(2) a').attr("title");
            if (qualityText) {
              const qualityValue = parseInt(qualityText.split("/")[0], 10);
              instrument.quality = qualityValue;
              console.log(`Quality fetched for instrument: ${instrument.name} (ID: ${instrument.id}) - Quality: ${qualityValue}`);
            } else {
              console.log(`Quality not found for instrument: ${instrument.name} (ID: ${instrument.id})`);
            }
            $(`#${iframeId}`).remove();
            resolve(instrument);
          });
        });
      }
      async function fetchInstruments(bandmate) {
        console.log(`Fetching instruments for bandmate: ${bandmate.name} (ID: ${bandmate.id})`);
        return new Promise((resolve) => {
          const iframeId = `iframe-instruments-${bandmate.id}`;
          const iframe = $(`<iframe id="${iframeId}" style="display:none;"></iframe>`);
          $("body").append(iframe);
          const urlDomain = getUrlDomain();
          const url = `https://${urlDomain}/World/Popmundo.aspx/Character/Items/${bandmate.id}`;
          $(`#${iframeId}`).attr("src", url);
          $(`#${iframeId}`).on("load", async function() {
            const iframeContents = $(`#${iframeId}`).contents();
            const rows = iframeContents.find("#checkedlist tbody tr");
            const instruments = [];
            let isInstrumentGroup = false;
            rows.each(function() {
              const row = $(this);
              if (row.hasClass("group") && row.find("td").text().trim() === "Instrumentos musicais" || row.find("td").text().trim() === "Musical Instrument") {
                isInstrumentGroup = true;
                return;
              }
              if (row.hasClass("group") && isInstrumentGroup) {
                isInstrumentGroup = false;
              }
              if (isInstrumentGroup && !row.hasClass("group")) {
                const name = row.find("td a").text().trim();
                const url2 = row.find("td a").attr("href");
                const idMatch = url2 ? url2.match(/(\d+)$/) : null;
                const id2 = idMatch ? parseInt(idMatch[0], 10) : null;
                if (name && id2) {
                  const instrument = new InstrumentImpl(id2, name);
                  instruments.push(instrument);
                  console.log(`Instrument added: ${name} (ID: ${id2}) for bandmate: ${bandmate.name}`);
                }
              }
            });
            for (const instrument of instruments) {
              await fetchInstrumentQuality(instrument);
            }
            $(`#${iframeId}`).remove();
            console.log(`Finished fetching instruments for bandmate: ${bandmate.name}`);
            resolve(instruments);
          });
        });
      }
      async function loadBandmatesData() {
        setIsLoading(true);
        const initialBandmates = getBandmates();
        for (const bandmate of initialBandmates) {
          await fetchBandmateSq(bandmate);
          const instruments = await fetchInstruments(bandmate);
          bandmate.instruments = instruments;
          await fetchBandmateRelationship(bandmate);
        }
        setBandmates(initialBandmates);
        setIsLoading(false);
      }
      loadBandmatesData();
    }, [artistId]);
    return { bandmates, isLoading };
  }
  const BandmatesSection = () => {
    const { bandmates, isLoading: isLoadingBandmates } = useBandmate();
    const sortedBandmates = [...bandmates].sort((a, b2) => b2.sq - a.sq);
    return /* @__PURE__ */ React$1.createElement("div", { style: { display: "flex", flexDirection: "row", gap: 14, flexWrap: "wrap", justifyContent: "center", alignItems: "flex-start" } }, /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Bandmates' Details", toggleOpen: false }, isLoadingBandmates ? /* @__PURE__ */ React$1.createElement("div", null, "Esta tarefa pode demorar um pouco mais. Mas não se preocupe, estamos colhendo as informações!", /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } })) : /* @__PURE__ */ React$1.createElement("table", { style: { width: "100%", borderCollapse: "collapse" } }, /* @__PURE__ */ React$1.createElement("thead", null, /* @__PURE__ */ React$1.createElement("tr", null, /* @__PURE__ */ React$1.createElement("th", { style: { borderBottom: "1px solid #ddd", padding: "4px", textAlign: "left" } }, "Name"), /* @__PURE__ */ React$1.createElement("th", { style: { borderBottom: "1px solid #ddd", padding: "4px", textAlign: "left" } }, "SQ"), /* @__PURE__ */ React$1.createElement("th", { style: { borderBottom: "1px solid #ddd", padding: "4px", textAlign: "left" } }, "Friend"), /* @__PURE__ */ React$1.createElement("th", { style: { borderBottom: "1px solid #ddd", padding: "4px", textAlign: "left" } }, "Love"))), /* @__PURE__ */ React$1.createElement("tbody", null, sortedBandmates.map((bandmate, index) => /* @__PURE__ */ React$1.createElement("tr", { key: index }, /* @__PURE__ */ React$1.createElement("td", { style: { borderBottom: "1px solid #ddd", padding: "4px" } }, bandmate.name.split(" ")[0]), /* @__PURE__ */ React$1.createElement("td", { style: { borderBottom: "1px solid #ddd", padding: "4px" } }, bandmate.sq, "%"), /* @__PURE__ */ React$1.createElement("td", { style: { borderBottom: "1px solid #ddd", padding: "4px" } }, bandmate.friendship, "%"), /* @__PURE__ */ React$1.createElement("td", { style: { borderBottom: "1px solid #ddd", padding: "4px" } }, bandmate.romance, "%")))))), /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Bandmates's Instruments", toggleOpen: false }, isLoadingBandmates ? /* @__PURE__ */ React$1.createElement("div", null, "Esta tarefa pode demorar um pouco mais. Mas não se preocupe, estamos colhendo as informações!", /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } }), /* @__PURE__ */ React$1.createElement(Skeleton, { variant: "rectangular", width: 300, height: 20, style: { marginTop: 8 } })) : sortedBandmates.map((bandmate, index) => /* @__PURE__ */ React$1.createElement("div", { key: index }, bandmate.name.split(" ")[0], ":", " ", (bandmate.instruments || []).map((inst, i) => {
      var _a;
      return /* @__PURE__ */ React$1.createElement("span", { key: i }, inst.name, "(", /* @__PURE__ */ React$1.createElement("strong", null, inst.quality), ")", i < (((_a = bandmate.instruments) == null ? void 0 : _a.length) || 0) - 1 && ", ");
    })))));
  };
  function App() {
    return /* @__PURE__ */ React$1.createElement(BoxDiv, { title: "Artist's Dashboard", togglable: false }, /* @__PURE__ */ React$1.createElement(FameAndPopularitySection, null), /* @__PURE__ */ React$1.createElement(Divider, { sx: { margin: 1 } }), /* @__PURE__ */ React$1.createElement(SinglesSection, null), /* @__PURE__ */ React$1.createElement(Divider, { sx: { margin: 1 } }), /* @__PURE__ */ React$1.createElement(BandmatesSection, null));
  }
  function log(...args) {
    console.log(
      "%cUserscript (React Mode):",
      "color: purple; font-weight: bold",
      ...args
    );
  }
  function addLocationChangeCallback(callback) {
    window.setTimeout(callback, 0);
    let oldHref = window.location.href;
    const body = document.querySelector("body");
    const observer = new MutationObserver((mutations) => {
      if (mutations.some(() => oldHref !== document.location.href)) {
        oldHref = document.location.href;
        callback();
      }
    });
    observer.observe(body, { childList: true, subtree: true });
    return observer;
  }
  async function awaitElement(selector) {
    const MAX_TRIES = 60;
    let tries = 0;
    return new Promise((resolve, reject) => {
      function probe() {
        tries++;
        return document.querySelector(selector);
      }
      function delayedProbe() {
        if (tries >= MAX_TRIES) {
          log("Can't find element with selector", selector);
          reject();
          return;
        }
        const elm = probe();
        if (elm) {
          resolve(elm);
          return;
        }
        window.setTimeout(delayedProbe, 250);
      }
      delayedProbe();
    });
  }
  function getArtistId() {
    let artistId = $(".entityLogo .idHolder").text();
    return artistId !== "" && artistId !== null ? artistId : null;
  }
  function formatProdErrorMessage$1(code) {
    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
  }
  var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
  var symbol_observable_default = $$observable;
  var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
  var ActionTypes = {
    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
  };
  var actionTypes_default = ActionTypes;
  function isPlainObject$1(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    let proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
  }
  function createStore(reducer, preloadedState, enhancer) {
    if (typeof reducer !== "function") {
      throw new Error(formatProdErrorMessage$1(2));
    }
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(formatProdErrorMessage$1(0));
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(formatProdErrorMessage$1(1));
      }
      return enhancer(createStore)(reducer, preloadedState);
    }
    let currentReducer = reducer;
    let currentState = preloadedState;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = /* @__PURE__ */ new Map();
        currentListeners.forEach((listener, key) => {
          nextListeners.set(key, listener);
        });
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(3));
      }
      return currentState;
    }
    function subscribe(listener) {
      if (typeof listener !== "function") {
        throw new Error(formatProdErrorMessage$1(4));
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(5));
      }
      let isSubscribed = true;
      ensureCanMutateNextListeners();
      const listenerId = listenerIdCounter++;
      nextListeners.set(listenerId, listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(6));
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        nextListeners.delete(listenerId);
        currentListeners = null;
      };
    }
    function dispatch(action) {
      if (!isPlainObject$1(action)) {
        throw new Error(formatProdErrorMessage$1(7));
      }
      if (typeof action.type === "undefined") {
        throw new Error(formatProdErrorMessage$1(8));
      }
      if (typeof action.type !== "string") {
        throw new Error(formatProdErrorMessage$1(17));
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage$1(9));
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      const listeners = currentListeners = nextListeners;
      listeners.forEach((listener) => {
        listener();
      });
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(formatProdErrorMessage$1(10));
      }
      currentReducer = nextReducer;
      dispatch({
        type: actionTypes_default.REPLACE
      });
    }
    function observable() {
      const outerSubscribe = subscribe;
      return {
        /**
         * The minimal observable subscription method.
         * @param observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(formatProdErrorMessage$1(11));
          }
          function observeState() {
            const observerAsObserver = observer;
            if (observerAsObserver.next) {
              observerAsObserver.next(getState());
            }
          }
          observeState();
          const unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        },
        [symbol_observable_default]() {
          return this;
        }
      };
    }
    dispatch({
      type: actionTypes_default.INIT
    });
    const store2 = {
      dispatch,
      subscribe,
      getState,
      replaceReducer,
      [symbol_observable_default]: observable
    };
    return store2;
  }
  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key) => {
      const reducer = reducers[key];
      const initialState = reducer(void 0, {
        type: actionTypes_default.INIT
      });
      if (typeof initialState === "undefined") {
        throw new Error(formatProdErrorMessage$1(12));
      }
      if (typeof reducer(void 0, {
        type: actionTypes_default.PROBE_UNKNOWN_ACTION()
      }) === "undefined") {
        throw new Error(formatProdErrorMessage$1(13));
      }
    });
  }
  function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      if (typeof reducers[key] === "function") {
        finalReducers[key] = reducers[key];
      }
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let shapeAssertionError;
    try {
      assertReducerShape(finalReducers);
    } catch (e3) {
      shapeAssertionError = e3;
    }
    return function combination(state = {}, action) {
      if (shapeAssertionError) {
        throw shapeAssertionError;
      }
      let hasChanged = false;
      const nextState = {};
      for (let i = 0; i < finalReducerKeys.length; i++) {
        const key = finalReducerKeys[i];
        const reducer = finalReducers[key];
        const previousStateForKey = state[key];
        const nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === "undefined") {
          action && action.type;
          throw new Error(formatProdErrorMessage$1(14));
        }
        nextState[key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  function compose(...funcs) {
    if (funcs.length === 0) {
      return (arg2) => arg2;
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce((a, b2) => (...args) => a(b2(...args)));
  }
  function applyMiddleware(...middlewares) {
    return (createStore2) => (reducer, preloadedState) => {
      const store2 = createStore2(reducer, preloadedState);
      let dispatch = () => {
        throw new Error(formatProdErrorMessage$1(15));
      };
      const middlewareAPI = {
        getState: store2.getState,
        dispatch: (action, ...args) => dispatch(action, ...args)
      };
      const chain = middlewares.map((middleware2) => middleware2(middlewareAPI));
      dispatch = compose(...chain)(store2.dispatch);
      return {
        ...store2,
        dispatch
      };
    };
  }
  function isAction(action) {
    return isPlainObject$1(action) && "type" in action && typeof action.type === "string";
  }
  var NOTHING = Symbol.for("immer-nothing");
  var DRAFTABLE = Symbol.for("immer-draftable");
  var DRAFT_STATE = Symbol.for("immer-state");
  function die(error, ...args) {
    throw new Error(
      `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
    );
  }
  var getPrototypeOf = Object.getPrototypeOf;
  function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
  }
  function isDraftable(value) {
    var _a;
    if (!value)
      return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);
  }
  var objectCtorString = Object.prototype.constructor.toString();
  function isPlainObject(value) {
    if (!value || typeof value !== "object")
      return false;
    const proto = getPrototypeOf(value);
    if (proto === null) {
      return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object)
      return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
  }
  function each(obj, iter) {
    if (getArchtype(obj) === 0) {
      Reflect.ownKeys(obj).forEach((key) => {
        iter(key, obj[key], obj);
      });
    } else {
      obj.forEach((entry, index) => iter(index, entry, obj));
    }
  }
  function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
  }
  function has(thing, prop) {
    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
  }
  function set(thing, propOrOldValue, value) {
    const t2 = getArchtype(thing);
    if (t2 === 2)
      thing.set(propOrOldValue, value);
    else if (t2 === 3) {
      thing.add(value);
    } else
      thing[propOrOldValue] = value;
  }
  function is(x2, y2) {
    if (x2 === y2) {
      return x2 !== 0 || 1 / x2 === 1 / y2;
    } else {
      return x2 !== x2 && y2 !== y2;
    }
  }
  function isMap(target) {
    return target instanceof Map;
  }
  function isSet(target) {
    return target instanceof Set;
  }
  function latest(state) {
    return state.copy_ || state.base_;
  }
  function shallowCopy(base, strict) {
    if (isMap(base)) {
      return new Map(base);
    }
    if (isSet(base)) {
      return new Set(base);
    }
    if (Array.isArray(base))
      return Array.prototype.slice.call(base);
    const isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
      const descriptors = Object.getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      let keys = Reflect.ownKeys(descriptors);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(getPrototypeOf(base), descriptors);
    } else {
      const proto = getPrototypeOf(base);
      if (proto !== null && isPlain) {
        return { ...base };
      }
      const obj = Object.create(proto);
      return Object.assign(obj, base);
    }
  }
  function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
      return obj;
    if (getArchtype(obj) > 1) {
      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep)
      Object.entries(obj).forEach(([key, value]) => freeze(value, true));
    return obj;
  }
  function dontMutateFrozenCollections() {
    die(2);
  }
  function isFrozen(obj) {
    return Object.isFrozen(obj);
  }
  var plugins = {};
  function getPlugin(pluginKey) {
    const plugin2 = plugins[pluginKey];
    if (!plugin2) {
      die(0, pluginKey);
    }
    return plugin2;
  }
  var currentScope;
  function getCurrentScope() {
    return currentScope;
  }
  function createScope(parent_, immer_) {
    return {
      drafts_: [],
      parent_,
      immer_,
      // Whenever the modified draft contains a draft from another scope, we
      // need to prevent auto-freezing so the unowned draft can be finalized.
      canAutoFreeze_: true,
      unfinalizedDrafts_: 0
    };
  }
  function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
      getPlugin("Patches");
      scope.patches_ = [];
      scope.inversePatches_ = [];
      scope.patchListener_ = patchListener;
    }
  }
  function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
  }
  function leaveScope(scope) {
    if (scope === currentScope) {
      currentScope = scope.parent_;
    }
  }
  function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
  }
  function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 || state.type_ === 1)
      state.revoke_();
    else
      state.revoked_ = true;
  }
  function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
      if (baseDraft[DRAFT_STATE].modified_) {
        revokeScope(scope);
        die(4);
      }
      if (isDraftable(result)) {
        result = finalize(scope, result);
        if (!scope.parent_)
          maybeFreeze(scope, result);
      }
      if (scope.patches_) {
        getPlugin("Patches").generateReplacementPatches_(
          baseDraft[DRAFT_STATE].base_,
          result,
          scope.patches_,
          scope.inversePatches_
        );
      }
    } else {
      result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
      scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
  }
  function finalize(rootScope, value, path) {
    if (isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    if (!state) {
      each(
        value,
        (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
      );
      return value;
    }
    if (state.scope_ !== rootScope)
      return value;
    if (!state.modified_) {
      maybeFreeze(rootScope, state.base_, true);
      return state.base_;
    }
    if (!state.finalized_) {
      state.finalized_ = true;
      state.scope_.unfinalizedDrafts_--;
      const result = state.copy_;
      let resultEach = result;
      let isSet2 = false;
      if (state.type_ === 3) {
        resultEach = new Set(result);
        result.clear();
        isSet2 = true;
      }
      each(
        resultEach,
        (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
      );
      maybeFreeze(rootScope, result, false);
      if (path && rootScope.patches_) {
        getPlugin("Patches").generatePatches_(
          state,
          path,
          rootScope.patches_,
          rootScope.inversePatches_
        );
      }
    }
    return state.copy_;
  }
  function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (isDraft(childValue)) {
      const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
      !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
      const res = finalize(rootScope, childValue, path);
      set(targetObject, prop, res);
      if (isDraft(res)) {
        rootScope.canAutoFreeze_ = false;
      } else
        return;
    } else if (targetIsSet) {
      targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
      if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
        return;
      }
      finalize(rootScope, childValue);
      if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
        maybeFreeze(rootScope, childValue);
    }
  }
  function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
      freeze(value, deep);
    }
  }
  function createProxyProxy(base, parent) {
    const isArray = Array.isArray(base);
    const state = {
      type_: isArray ? 1 : 0,
      // Track which produce call this is associated with.
      scope_: parent ? parent.scope_ : getCurrentScope(),
      // True for both shallow and deep changes.
      modified_: false,
      // Used during finalization.
      finalized_: false,
      // Track which properties have been assigned (true) or deleted (false).
      assigned_: {},
      // The parent draft state.
      parent_: parent,
      // The base state.
      base_: base,
      // The base proxy.
      draft_: null,
      // set below
      // The base copy with any updated values.
      copy_: null,
      // Called by the `produce` function.
      revoke_: null,
      isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray) {
      target = [state];
      traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
  }
  var objectTraps = {
    get(state, prop) {
      if (prop === DRAFT_STATE)
        return state;
      const source = latest(state);
      if (!has(source, prop)) {
        return readPropFromProto(state, source, prop);
      }
      const value = source[prop];
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value === peek(state.base_, prop)) {
        prepareCopy(state);
        return state.copy_[prop] = createProxy(value, state);
      }
      return value;
    },
    has(state, prop) {
      return prop in latest(state);
    },
    ownKeys(state) {
      return Reflect.ownKeys(latest(state));
    },
    set(state, prop, value) {
      const desc = getDescriptorFromProto(latest(state), prop);
      if (desc == null ? void 0 : desc.set) {
        desc.set.call(state.draft_, value);
        return true;
      }
      if (!state.modified_) {
        const current2 = peek(latest(state), prop);
        const currentState = current2 == null ? void 0 : current2[DRAFT_STATE];
        if (currentState && currentState.base_ === value) {
          state.copy_[prop] = value;
          state.assigned_[prop] = false;
          return true;
        }
        if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
          return true;
        prepareCopy(state);
        markChanged(state);
      }
      if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
      (value !== void 0 || prop in state.copy_) || // special case: NaN
      Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
        return true;
      state.copy_[prop] = value;
      state.assigned_[prop] = true;
      return true;
    },
    deleteProperty(state, prop) {
      if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
        state.assigned_[prop] = false;
        prepareCopy(state);
        markChanged(state);
      } else {
        delete state.assigned_[prop];
      }
      if (state.copy_) {
        delete state.copy_[prop];
      }
      return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor(state, prop) {
      const owner = latest(state);
      const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
      if (!desc)
        return desc;
      return {
        writable: true,
        configurable: state.type_ !== 1 || prop !== "length",
        enumerable: desc.enumerable,
        value: owner[prop]
      };
    },
    defineProperty() {
      die(11);
    },
    getPrototypeOf(state) {
      return getPrototypeOf(state.base_);
    },
    setPrototypeOf() {
      die(12);
    }
  };
  var arrayTraps = {};
  each(objectTraps, (key, fn) => {
    arrayTraps[key] = function() {
      arguments[0] = arguments[0][0];
      return fn.apply(this, arguments);
    };
  });
  arrayTraps.deleteProperty = function(state, prop) {
    return arrayTraps.set.call(this, state, prop, void 0);
  };
  arrayTraps.set = function(state, prop, value) {
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
  };
  function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
  }
  function readPropFromProto(state, source, prop) {
    var _a;
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : (
      // This is a very special case, if the prop is a getter defined by the
      // prototype, we should invoke it with the draft as context!
      (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
    ) : void 0;
  }
  function getDescriptorFromProto(source, prop) {
    if (!(prop in source))
      return void 0;
    let proto = getPrototypeOf(source);
    while (proto) {
      const desc = Object.getOwnPropertyDescriptor(proto, prop);
      if (desc)
        return desc;
      proto = getPrototypeOf(proto);
    }
    return void 0;
  }
  function markChanged(state) {
    if (!state.modified_) {
      state.modified_ = true;
      if (state.parent_) {
        markChanged(state.parent_);
      }
    }
  }
  function prepareCopy(state) {
    if (!state.copy_) {
      state.copy_ = shallowCopy(
        state.base_,
        state.scope_.immer_.useStrictShallowCopy_
      );
    }
  }
  var Immer2 = class {
    constructor(config2) {
      this.autoFreeze_ = true;
      this.useStrictShallowCopy_ = false;
      this.produce = (base, recipe, patchListener) => {
        if (typeof base === "function" && typeof recipe !== "function") {
          const defaultBase = recipe;
          recipe = base;
          const self2 = this;
          return function curriedProduce(base2 = defaultBase, ...args) {
            return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
          };
        }
        if (typeof recipe !== "function")
          die(6);
        if (patchListener !== void 0 && typeof patchListener !== "function")
          die(7);
        let result;
        if (isDraftable(base)) {
          const scope = enterScope(this);
          const proxy = createProxy(base, void 0);
          let hasError = true;
          try {
            result = recipe(proxy);
            hasError = false;
          } finally {
            if (hasError)
              revokeScope(scope);
            else
              leaveScope(scope);
          }
          usePatchesInScope(scope, patchListener);
          return processResult(result, scope);
        } else if (!base || typeof base !== "object") {
          result = recipe(base);
          if (result === void 0)
            result = base;
          if (result === NOTHING)
            result = void 0;
          if (this.autoFreeze_)
            freeze(result, true);
          if (patchListener) {
            const p2 = [];
            const ip = [];
            getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
            patchListener(p2, ip);
          }
          return result;
        } else
          die(1, base);
      };
      this.produceWithPatches = (base, recipe) => {
        if (typeof base === "function") {
          return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
        }
        let patches, inversePatches;
        const result = this.produce(base, recipe, (p2, ip) => {
          patches = p2;
          inversePatches = ip;
        });
        return [result, patches, inversePatches];
      };
      if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
        this.setAutoFreeze(config2.autoFreeze);
      if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
        this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    }
    createDraft(base) {
      if (!isDraftable(base))
        die(8);
      if (isDraft(base))
        base = current(base);
      const scope = enterScope(this);
      const proxy = createProxy(base, void 0);
      proxy[DRAFT_STATE].isManual_ = true;
      leaveScope(scope);
      return proxy;
    }
    finishDraft(draft, patchListener) {
      const state = draft && draft[DRAFT_STATE];
      if (!state || !state.isManual_)
        die(9);
      const { scope_: scope } = state;
      usePatchesInScope(scope, patchListener);
      return processResult(void 0, scope);
    }
    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is enabled.
     */
    setAutoFreeze(value) {
      this.autoFreeze_ = value;
    }
    /**
     * Pass true to enable strict shallow copy.
     *
     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
     */
    setUseStrictShallowCopy(value) {
      this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
      let i;
      for (i = patches.length - 1; i >= 0; i--) {
        const patch = patches[i];
        if (patch.path.length === 0 && patch.op === "replace") {
          base = patch.value;
          break;
        }
      }
      if (i > -1) {
        patches = patches.slice(i + 1);
      }
      const applyPatchesImpl = getPlugin("Patches").applyPatches_;
      if (isDraft(base)) {
        return applyPatchesImpl(base, patches);
      }
      return this.produce(
        base,
        (draft) => applyPatchesImpl(draft, patches)
      );
    }
  };
  function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
  }
  function current(value) {
    if (!isDraft(value))
      die(10, value);
    return currentImpl(value);
  }
  function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    let copy2;
    if (state) {
      if (!state.modified_)
        return state.base_;
      state.finalized_ = true;
      copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
      copy2 = shallowCopy(value, true);
    }
    each(copy2, (key, childValue) => {
      set(copy2, key, currentImpl(childValue));
    });
    if (state) {
      state.finalized_ = false;
    }
    return copy2;
  }
  var immer = new Immer2();
  var produce = immer.produce;
  immer.produceWithPatches.bind(
    immer
  );
  immer.setAutoFreeze.bind(immer);
  immer.setUseStrictShallowCopy.bind(immer);
  immer.applyPatches.bind(immer);
  immer.createDraft.bind(immer);
  immer.finishDraft.bind(immer);
  function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
    if (typeof func !== "function") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
    if (typeof object2 !== "object") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
    if (!array2.every((item) => typeof item === "function")) {
      const itemTypes = array2.map(
        (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
      ).join(", ");
      throw new TypeError(`${errorMessage}[${itemTypes}]`);
    }
  }
  var ensureIsArray = (item) => {
    return Array.isArray(item) ? item : [item];
  };
  function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(
      dependencies,
      `createSelector expects all input-selectors to be functions, but received the following types: `
    );
    return dependencies;
  }
  function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length: length2 } = dependencies;
    for (let i = 0; i < length2; i++) {
      inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    }
    return inputSelectorResults;
  }
  var StrongRef = class {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  };
  var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
  var UNTERMINATED = 0;
  var TERMINATED = 1;
  function createCacheNode() {
    return {
      s: UNTERMINATED,
      v: void 0,
      o: null,
      p: null
    };
  }
  function weakMapMemoize(func, options = {}) {
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options;
    let lastResult;
    let resultsCount = 0;
    function memoized() {
      var _a;
      let cacheNode = fnNode;
      const { length: length2 } = arguments;
      for (let i = 0, l2 = length2; i < l2; i++) {
        const arg2 = arguments[i];
        if (typeof arg2 === "function" || typeof arg2 === "object" && arg2 !== null) {
          let objectCache = cacheNode.o;
          if (objectCache === null) {
            cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
          }
          const objectNode = objectCache.get(arg2);
          if (objectNode === void 0) {
            cacheNode = createCacheNode();
            objectCache.set(arg2, cacheNode);
          } else {
            cacheNode = objectNode;
          }
        } else {
          let primitiveCache = cacheNode.p;
          if (primitiveCache === null) {
            cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
          }
          const primitiveNode = primitiveCache.get(arg2);
          if (primitiveNode === void 0) {
            cacheNode = createCacheNode();
            primitiveCache.set(arg2, cacheNode);
          } else {
            cacheNode = primitiveNode;
          }
        }
      }
      const terminatedNode = cacheNode;
      let result;
      if (cacheNode.s === TERMINATED) {
        result = cacheNode.v;
      } else {
        result = func.apply(null, arguments);
        resultsCount++;
        if (resultEqualityCheck) {
          const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
            result = lastResultValue;
            resultsCount !== 0 && resultsCount--;
          }
          const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
          lastResult = needsWeakRef ? new Ref(result) : result;
        }
      }
      terminatedNode.s = TERMINATED;
      terminatedNode.v = result;
      return result;
    }
    memoized.clearCache = () => {
      fnNode = createCacheNode();
      memoized.resetResultsCount();
    };
    memoized.resultsCount = () => resultsCount;
    memoized.resetResultsCount = () => {
      resultsCount = 0;
    };
    return memoized;
  }
  function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
      memoize: memoizeOrOptions,
      memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = (...createSelectorArgs) => {
      let recomputations = 0;
      let dependencyRecomputations = 0;
      let lastResult;
      let directlyPassedOptions = {};
      let resultFunc = createSelectorArgs.pop();
      if (typeof resultFunc === "object") {
        directlyPassedOptions = resultFunc;
        resultFunc = createSelectorArgs.pop();
      }
      assertIsFunction(
        resultFunc,
        `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
      );
      const combinedOptions = {
        ...createSelectorCreatorOptions,
        ...directlyPassedOptions
      };
      const {
        memoize: memoize2,
        memoizeOptions = [],
        argsMemoize = weakMapMemoize,
        argsMemoizeOptions = [],
        devModeChecks = {}
      } = combinedOptions;
      const finalMemoizeOptions = ensureIsArray(memoizeOptions);
      const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
      const dependencies = getDependencies(createSelectorArgs);
      const memoizedResultFunc = memoize2(function recomputationWrapper() {
        recomputations++;
        return resultFunc.apply(
          null,
          arguments
        );
      }, ...finalMemoizeOptions);
      const selector = argsMemoize(function dependenciesChecker() {
        dependencyRecomputations++;
        const inputSelectorResults = collectInputSelectorResults(
          dependencies,
          arguments
        );
        lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
        return lastResult;
      }, ...finalArgsMemoizeOptions);
      return Object.assign(selector, {
        resultFunc,
        memoizedResultFunc,
        dependencies,
        dependencyRecomputations: () => dependencyRecomputations,
        resetDependencyRecomputations: () => {
          dependencyRecomputations = 0;
        },
        lastResult: () => lastResult,
        recomputations: () => recomputations,
        resetRecomputations: () => {
          recomputations = 0;
        },
        memoize: memoize2,
        argsMemoize
      });
    };
    Object.assign(createSelector2, {
      withTypes: () => createSelector2
    });
    return createSelector2;
  }
  var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
  var createStructuredSelector = Object.assign(
    (inputSelectorsObject, selectorCreator = createSelector) => {
      assertIsObject(
        inputSelectorsObject,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
      );
      const inputSelectorKeys = Object.keys(inputSelectorsObject);
      const dependencies = inputSelectorKeys.map(
        (key) => inputSelectorsObject[key]
      );
      const structuredSelector = selectorCreator(
        dependencies,
        (...inputSelectorResults) => {
          return inputSelectorResults.reduce((composition, value, index) => {
            composition[inputSelectorKeys[index]] = value;
            return composition;
          }, {});
        }
      );
      return structuredSelector;
    },
    { withTypes: () => createStructuredSelector }
  );
  function createThunkMiddleware(extraArgument) {
    const middleware2 = ({ dispatch, getState }) => (next2) => (action) => {
      if (typeof action === "function") {
        return action(dispatch, getState, extraArgument);
      }
      return next2(action);
    };
    return middleware2;
  }
  var thunk = createThunkMiddleware();
  var withExtraArgument = createThunkMiddleware;
  var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return compose;
    return compose.apply(null, arguments);
  };
  function createAction(type, prepareAction) {
    function actionCreator(...args) {
      if (prepareAction) {
        let prepared = prepareAction(...args);
        if (!prepared) {
          throw new Error(formatProdErrorMessage(0));
        }
        return {
          type,
          payload: prepared.payload,
          ..."meta" in prepared && {
            meta: prepared.meta
          },
          ..."error" in prepared && {
            error: prepared.error
          }
        };
      }
      return {
        type,
        payload: args[0]
      };
    }
    actionCreator.toString = () => `${type}`;
    actionCreator.type = type;
    actionCreator.match = (action) => isAction(action) && action.type === type;
    return actionCreator;
  }
  var Tuple = class _Tuple extends Array {
    constructor(...items) {
      super(...items);
      Object.setPrototypeOf(this, _Tuple.prototype);
    }
    static get [Symbol.species]() {
      return _Tuple;
    }
    concat(...arr) {
      return super.concat.apply(this, arr);
    }
    prepend(...arr) {
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new _Tuple(...arr[0].concat(this));
      }
      return new _Tuple(...arr.concat(this));
    }
  };
  function freezeDraftable(val) {
    return isDraftable(val) ? produce(val, () => {
    }) : val;
  }
  function emplace(map2, key, handler) {
    if (map2.has(key)) {
      let value = map2.get(key);
      if (handler.update) {
        value = handler.update(value, key, map2);
        map2.set(key, value);
      }
      return value;
    }
    if (!handler.insert) throw new Error(formatProdErrorMessage(10));
    const inserted = handler.insert(key, map2);
    map2.set(key, inserted);
    return inserted;
  }
  function isBoolean(x2) {
    return typeof x2 === "boolean";
  }
  var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
    const {
      thunk: thunk$1 = true,
      immutableCheck = true,
      serializableCheck = true,
      actionCreatorCheck = true
    } = options ?? {};
    let middlewareArray = new Tuple();
    if (thunk$1) {
      if (isBoolean(thunk$1)) {
        middlewareArray.push(thunk);
      } else {
        middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
      }
    }
    return middlewareArray;
  };
  var SHOULD_AUTOBATCH = "RTK_autoBatch";
  var createQueueWithTimer = (timeout) => {
    return (notify) => {
      setTimeout(notify, timeout);
    };
  };
  var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
  var autoBatchEnhancer = (options = {
    type: "raf"
  }) => (next2) => (...args) => {
    const store2 = next2(...args);
    let notifying = true;
    let shouldNotifyAtEndOfTick = false;
    let notificationQueued = false;
    const listeners = /* @__PURE__ */ new Set();
    const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? rAF : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
    const notifyListeners = () => {
      notificationQueued = false;
      if (shouldNotifyAtEndOfTick) {
        shouldNotifyAtEndOfTick = false;
        listeners.forEach((l2) => l2());
      }
    };
    return Object.assign({}, store2, {
      // Override the base `store.subscribe` method to keep original listeners
      // from running if we're delaying notifications
      subscribe(listener2) {
        const wrappedListener = () => notifying && listener2();
        const unsubscribe = store2.subscribe(wrappedListener);
        listeners.add(listener2);
        return () => {
          unsubscribe();
          listeners.delete(listener2);
        };
      },
      // Override the base `store.dispatch` method so that we can check actions
      // for the `shouldAutoBatch` flag and determine if batching is active
      dispatch(action) {
        var _a;
        try {
          notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
          shouldNotifyAtEndOfTick = !notifying;
          if (shouldNotifyAtEndOfTick) {
            if (!notificationQueued) {
              notificationQueued = true;
              queueCallback(notifyListeners);
            }
          }
          return store2.dispatch(action);
        } finally {
          notifying = true;
        }
      }
    });
  };
  var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
    const {
      autoBatch = true
    } = options ?? {};
    let enhancerArray = new Tuple(middlewareEnhancer);
    if (autoBatch) {
      enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
    }
    return enhancerArray;
  };
  function configureStore(options) {
    const getDefaultMiddleware = buildGetDefaultMiddleware();
    const {
      reducer = void 0,
      middleware: middleware2,
      devTools = true,
      preloadedState = void 0,
      enhancers = void 0
    } = options || {};
    let rootReducer;
    if (typeof reducer === "function") {
      rootReducer = reducer;
    } else if (isPlainObject$1(reducer)) {
      rootReducer = combineReducers(reducer);
    } else {
      throw new Error(formatProdErrorMessage(1));
    }
    let finalMiddleware;
    if (typeof middleware2 === "function") {
      finalMiddleware = middleware2(getDefaultMiddleware);
    } else {
      finalMiddleware = getDefaultMiddleware();
    }
    let finalCompose = compose;
    if (devTools) {
      finalCompose = composeWithDevTools({
        // Enable capture of stack traces for dispatched Redux actions
        trace: false,
        ...typeof devTools === "object" && devTools
      });
    }
    const middlewareEnhancer = applyMiddleware(...finalMiddleware);
    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
    let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
    const composedEnhancer = finalCompose(...storeEnhancers);
    return createStore(rootReducer, preloadedState, composedEnhancer);
  }
  function executeReducerBuilderCallback(builderCallback) {
    const actionsMap = {};
    const actionMatchers = [];
    let defaultCaseReducer;
    const builder = {
      addCase(typeOrActionCreator, reducer) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(formatProdErrorMessage(28));
        }
        if (type in actionsMap) {
          throw new Error(formatProdErrorMessage(29));
        }
        actionsMap[type] = reducer;
        return builder;
      },
      addMatcher(matcher, reducer) {
        actionMatchers.push({
          matcher,
          reducer
        });
        return builder;
      },
      addDefaultCase(reducer) {
        defaultCaseReducer = reducer;
        return builder;
      }
    };
    builderCallback(builder);
    return [actionsMap, actionMatchers, defaultCaseReducer];
  }
  function isStateFunction(x2) {
    return typeof x2 === "function";
  }
  function createReducer(initialState, mapOrBuilderCallback) {
    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
    let getInitialState;
    if (isStateFunction(initialState)) {
      getInitialState = () => freezeDraftable(initialState());
    } else {
      const frozenInitialState = freezeDraftable(initialState);
      getInitialState = () => frozenInitialState;
    }
    function reducer(state = getInitialState(), action) {
      let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
        matcher
      }) => matcher(action)).map(({
        reducer: reducer2
      }) => reducer2)];
      if (caseReducers.filter((cr) => !!cr).length === 0) {
        caseReducers = [finalDefaultCaseReducer];
      }
      return caseReducers.reduce((previousState, caseReducer) => {
        if (caseReducer) {
          if (isDraft(previousState)) {
            const draft = previousState;
            const result = caseReducer(draft, action);
            if (result === void 0) {
              return previousState;
            }
            return result;
          } else if (!isDraftable(previousState)) {
            const result = caseReducer(previousState, action);
            if (result === void 0) {
              if (previousState === null) {
                return previousState;
              }
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return result;
          } else {
            return produce(previousState, (draft) => {
              return caseReducer(draft, action);
            });
          }
        }
        return previousState;
      }, state);
    }
    reducer.getInitialState = getInitialState;
    return reducer;
  }
  var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
  function getType(slice2, actionKey) {
    return `${slice2}/${actionKey}`;
  }
  function buildCreateSlice({
    creators
  } = {}) {
    var _a;
    const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
    return function createSlice2(options) {
      const {
        name,
        reducerPath = name
      } = options;
      if (!name) {
        throw new Error(formatProdErrorMessage(11));
      }
      if (typeof process !== "undefined" && false) {
        if (options.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
      const reducerNames = Object.keys(reducers);
      const context = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: []
      };
      const contextMethods = {
        addCase(typeOrActionCreator, reducer2) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(formatProdErrorMessage(12));
          }
          if (type in context.sliceCaseReducersByType) {
            throw new Error(formatProdErrorMessage(13));
          }
          context.sliceCaseReducersByType[type] = reducer2;
          return contextMethods;
        },
        addMatcher(matcher, reducer2) {
          context.sliceMatchers.push({
            matcher,
            reducer: reducer2
          });
          return contextMethods;
        },
        exposeAction(name2, actionCreator) {
          context.actionCreators[name2] = actionCreator;
          return contextMethods;
        },
        exposeCaseReducer(name2, reducer2) {
          context.sliceCaseReducersByName[name2] = reducer2;
          return contextMethods;
        }
      };
      reducerNames.forEach((reducerName) => {
        const reducerDefinition = reducers[reducerName];
        const reducerDetails = {
          reducerName,
          type: getType(name, reducerName),
          createNotation: typeof options.reducers === "function"
        };
        if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
          handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
        } else {
          handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
        }
      });
      function buildReducer() {
        const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
        const finalCaseReducers = {
          ...extraReducers,
          ...context.sliceCaseReducersByType
        };
        return createReducer(options.initialState, (builder) => {
          for (let key in finalCaseReducers) {
            builder.addCase(key, finalCaseReducers[key]);
          }
          for (let sM of context.sliceMatchers) {
            builder.addMatcher(sM.matcher, sM.reducer);
          }
          for (let m2 of actionMatchers) {
            builder.addMatcher(m2.matcher, m2.reducer);
          }
          if (defaultCaseReducer) {
            builder.addDefaultCase(defaultCaseReducer);
          }
        });
      }
      const selectSelf = (state) => state;
      const injectedSelectorCache = /* @__PURE__ */ new Map();
      let _reducer;
      function reducer(state, action) {
        if (!_reducer) _reducer = buildReducer();
        return _reducer(state, action);
      }
      function getInitialState() {
        if (!_reducer) _reducer = buildReducer();
        return _reducer.getInitialState();
      }
      function makeSelectorProps(reducerPath2, injected = false) {
        function selectSlice(state) {
          let sliceState = state[reducerPath2];
          if (typeof sliceState === "undefined") {
            if (injected) {
              sliceState = getInitialState();
            }
          }
          return sliceState;
        }
        function getSelectors(selectState = selectSelf) {
          const selectorCache = emplace(injectedSelectorCache, injected, {
            insert: () => /* @__PURE__ */ new WeakMap()
          });
          return emplace(selectorCache, selectState, {
            insert: () => {
              const map2 = {};
              for (const [name2, selector] of Object.entries(options.selectors ?? {})) {
                map2[name2] = wrapSelector(selector, selectState, getInitialState, injected);
              }
              return map2;
            }
          });
        }
        return {
          reducerPath: reducerPath2,
          getSelectors,
          get selectors() {
            return getSelectors(selectSlice);
          },
          selectSlice
        };
      }
      const slice2 = {
        name,
        reducer,
        actions: context.actionCreators,
        caseReducers: context.sliceCaseReducersByName,
        getInitialState,
        ...makeSelectorProps(reducerPath),
        injectInto(injectable, {
          reducerPath: pathOpt,
          ...config2
        } = {}) {
          const newReducerPath = pathOpt ?? reducerPath;
          injectable.inject({
            reducerPath: newReducerPath,
            reducer
          }, config2);
          return {
            ...slice2,
            ...makeSelectorProps(newReducerPath, true)
          };
        }
      };
      return slice2;
    };
  }
  function wrapSelector(selector, selectState, getInitialState, injected) {
    function wrapper2(rootState, ...args) {
      let sliceState = selectState(rootState);
      if (typeof sliceState === "undefined") {
        if (injected) {
          sliceState = getInitialState();
        }
      }
      return selector(sliceState, ...args);
    }
    wrapper2.unwrapped = selector;
    return wrapper2;
  }
  var createSlice = /* @__PURE__ */ buildCreateSlice();
  function buildReducerCreators() {
    function asyncThunk(payloadCreator, config2) {
      return {
        _reducerDefinitionType: "asyncThunk",
        payloadCreator,
        ...config2
      };
    }
    asyncThunk.withTypes = () => asyncThunk;
    return {
      reducer(caseReducer) {
        return Object.assign({
          // hack so the wrapping function has the same name as the original
          // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
          [caseReducer.name](...args) {
            return caseReducer(...args);
          }
        }[caseReducer.name], {
          _reducerDefinitionType: "reducer"
          /* reducer */
        });
      },
      preparedReducer(prepare, reducer) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare,
          reducer
        };
      },
      asyncThunk
    };
  }
  function handleNormalReducerDefinition({
    type,
    reducerName,
    createNotation
  }, maybeReducerWithPrepare, context) {
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
        throw new Error(formatProdErrorMessage(17));
      }
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
  }
  function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "asyncThunk";
  }
  function isCaseReducerWithPrepareDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
  }
  function handleThunkCaseReducerDefinition({
    type,
    reducerName
  }, reducerDefinition, context, cAT) {
    if (!cAT) {
      throw new Error(formatProdErrorMessage(18));
    }
    const {
      payloadCreator,
      fulfilled,
      pending,
      rejected,
      settled,
      options
    } = reducerDefinition;
    const thunk2 = cAT(type, payloadCreator, options);
    context.exposeAction(reducerName, thunk2);
    if (fulfilled) {
      context.addCase(thunk2.fulfilled, fulfilled);
    }
    if (pending) {
      context.addCase(thunk2.pending, pending);
    }
    if (rejected) {
      context.addCase(thunk2.rejected, rejected);
    }
    if (settled) {
      context.addMatcher(thunk2.settled, settled);
    }
    context.exposeCaseReducer(reducerName, {
      fulfilled: fulfilled || noop,
      pending: pending || noop,
      rejected: rejected || noop,
      settled: settled || noop
    });
  }
  function noop() {
  }
  function formatProdErrorMessage(code) {
    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
  }
  const artistSlice = createSlice({
    name: "artist",
    initialState: { artistId: null },
    reducers: {
      setArtistId: (state, action) => {
        state.artistId = action.payload;
      }
    }
  });
  const { setArtistId } = artistSlice.actions;
  const artistReducer = artistSlice.reducer;
  const store = configureStore({
    reducer: {
      artist: artistReducer
      // Inclua o slice do artista
    }
  });
  async function main() {
    const link2 = document.createElement("link");
    link2.rel = "stylesheet";
    link2.href = "https://use.fontawesome.com/releases/v5.15.4/css/all.css";
    document.getElementsByTagName("head")[0].appendChild(link2);
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";
    document.getElementsByTagName("head")[0].appendChild(link);
    const googleapisfonts = document.createElement("link");
    googleapisfonts.rel = "preconnect";
    googleapisfonts.href = "https://fonts.googleapis.com";
    document.getElementsByTagName("head")[0].appendChild(googleapisfonts);
    const googleapisfonts2 = document.createElement("link");
    googleapisfonts2.rel = "preconnect";
    googleapisfonts2.href = "https://fonts.gstatic.com";
    googleapisfonts2.crossOrigin = "anonymous";
    document.getElementsByTagName("head")[0].appendChild(googleapisfonts2);
    await awaitElement("body");
    const firstMenu = document.querySelector("#ctl00_cphLeftColumn_ctl01_divLatestShows");
    if (firstMenu && firstMenu.parentNode) {
      const newBoxDiv = document.createElement("div");
      firstMenu.parentNode.insertBefore(newBoxDiv, firstMenu.nextSibling);
      const root = createRoot(newBoxDiv);
      const artistId = getArtistId();
      store.dispatch(setArtistId(artistId));
      root.render(
        /* @__PURE__ */ React$1.createElement(Provider_default, { store }, /* @__PURE__ */ React$1.createElement(App, null))
      );
    }
  }
  addLocationChangeCallback(() => {
    main().catch((e3) => {
    });
  });
})();
;
(function(){
                    const el = document.createElement("style");
                    el.innerText = "";
                    el.type = "text/css";
                    document.head.appendChild(el);
                })();